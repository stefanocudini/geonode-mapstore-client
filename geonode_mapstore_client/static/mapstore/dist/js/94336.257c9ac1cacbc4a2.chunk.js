(self.webpackChunkgeonode_mapstore_client=self.webpackChunkgeonode_mapstore_client||[]).push([[94336],{226675:e=>{function t(e,t){const r=new RegExp(t,"g"),i=e.match(r);return i?i.length:0}e.exports=t,e.exports.default=t},258556:(e,t,r)=>{const i=r(343614),s=r(148694),n=r(226675);function o(e,t,r){const o=r&&r.debug||!1,a=!(r&&!1===typeof r.nested),l=r&&r.startIndex||0;o&&console.log("[xml-utils] starting findTagByName with",t," and ",r);const h=i(e,`<${t}[ \n>/]`,l);if(o&&console.log("[xml-utils] start:",h),-1===h)return;const c=e.slice(h+t.length);let f=s(c,"^[^<]*[ /]>",0);const u=-1!==f&&"/"===c[f-1];if(o&&console.log("[xml-utils] selfClosing:",u),!1===u)if(a){let e=0,r=1,i=0;for(;-1!==(f=s(c,"[ /]"+t+">",e));){const s=c.substring(e,f+1);if(r+=n(s,"<"+t+"[ \n\t>]"),i+=n(s,"</"+t+">"),i>=r)break;e=f}}else f=s(c,"[ /]"+t+">",0);const d=h+t.length+f+1;if(o&&console.log("[xml-utils] end:",d),-1===d)return;const g=e.slice(h,d);let p;return p=u?null:g.slice(g.indexOf(">")+1,g.lastIndexOf("<")),{inner:p,outer:g,start:h,end:d}}e.exports=o,e.exports.default=o},60563:(e,t,r)=>{const i=r(258556);function s(e,t,r){const s=[],n=r&&r.debug||!1,o=!r||"boolean"!=typeof r.nested||r.nested;let a,l=r&&r.startIndex||0;for(;a=i(e,t,{debug:n,startIndex:l});)l=o?a.start+1+t.length:a.end,s.push(a);return n&&console.log("findTagsByName found",s.length,"tags"),s}e.exports=s,e.exports.default=s},527379:e=>{function t(e,t,r){const i=r&&r.debug||!1;i&&console.log("[xml-utils] getting "+t+" in "+e);const s="object"==typeof e?e.outer:e,n=s.slice(0,s.indexOf(">")+1),o=['"',"'"];for(let e=0;e<o.length;e++){const r=o[e],s=t+"\\="+r+"([^"+r+"]*)"+r;i&&console.log("[xml-utils] pattern:",s);const a=new RegExp(s).exec(n);if(i&&console.log("[xml-utils] match:",a),a)return a[1]}}e.exports=t,e.exports.default=t},148694:e=>{function t(e,t,r){const i=new RegExp(t).exec(e.slice(r));return i?r+i.index+i[0].length-1:-1}e.exports=t,e.exports.default=t},343614:e=>{function t(e,t,r){const i=new RegExp(t).exec(e.slice(r));return i?r+i.index:-1}e.exports=t,e.exports.default=t},250797:(e,t,r)=>{"use strict";function i(e,t){let r=e.length-t,i=0;do{for(let r=t;r>0;r--)e[i+t]+=e[i],i++;r-=t}while(r>0)}function s(e,t,r){let i=0,s=e.length;const n=s/r;for(;s>t;){for(let r=t;r>0;--r)e[i+t]+=e[i],++i;s-=t}const o=e.slice();for(let t=0;t<n;++t)for(let i=0;i<r;++i)e[r*t+i]=o[(r-i-1)*n+t]}r.d(t,{A:()=>n});class n{async decode(e,t){const r=await this.decodeBlock(t),n=e.Predictor||1;if(1!==n){const t=!e.StripOffsets;return function(e,t,r,n,o,a){if(!t||1===t)return e;for(let e=0;e<o.length;++e){if(o[e]%8!=0)throw new Error("When decoding with predictor, only multiple of 8 bits are supported.");if(o[e]!==o[0])throw new Error("When decoding with predictor, all samples must have the same size.")}const l=o[0]/8,h=2===a?1:o.length;for(let a=0;a<n&&!(a*h*r*l>=e.byteLength);++a){let n;if(2===t){switch(o[0]){case 8:n=new Uint8Array(e,a*h*r*l,h*r*l);break;case 16:n=new Uint16Array(e,a*h*r*l,h*r*l/2);break;case 32:n=new Uint32Array(e,a*h*r*l,h*r*l/4);break;default:throw new Error(`Predictor 2 not allowed with ${o[0]} bits per sample.`)}i(n,h)}else 3===t&&(n=new Uint8Array(e,a*h*r*l,h*r*l),s(n,h,l))}return e}(r,n,t?e.TileWidth:e.ImageWidth,t?e.TileLength:e.RowsPerStrip||e.ImageLength,e.BitsPerSample,e.PlanarConfiguration)}return r}}},970851:(e,t,r)=>{"use strict";r.d(t,{E:()=>s,f:()=>n});const i=new Map;function s(e,t){Array.isArray(e)||(e=[e]),e.forEach(e=>i.set(e,t))}async function n(e){const t=i.get(e.Compression);if(!t)throw new Error(`Unknown compression method identifier: ${e.Compression}`);return new(await t())(e)}s([void 0,1],()=>r.e(35121).then(r.bind(r,35121)).then(e=>e.default)),s(5,()=>r.e(12764).then(r.bind(r,512764)).then(e=>e.default)),s(6,()=>{throw new Error("old style JPEG compression is not supported.")}),s(7,()=>r.e(76457).then(r.bind(r,376457)).then(e=>e.default)),s([8,32946],()=>Promise.all([r.e(3075),r.e(50424)]).then(r.bind(r,850424)).then(e=>e.default)),s(32773,()=>r.e(1030).then(r.bind(r,101030)).then(e=>e.default)),s(34887,()=>Promise.all([r.e(3075),r.e(56885)]).then(r.bind(r,356885)).then(async e=>(await e.zstd.init(),e)).then(e=>e.default)),s(50001,()=>r.e(6568).then(r.bind(r,806568)).then(e=>e.default))},594336:(e,t,r)=>{"use strict";r.r(t),r.d(t,{BaseClient:()=>Je,BaseDecoder:()=>Mt.A,BaseResponse:()=>Ze,GeoTIFF:()=>kt,GeoTIFFImage:()=>Fe,MultiGeoTIFF:()=>Bt,Pool:()=>_e.A,addDecoder:()=>xe.E,default:()=>Lt,fromArrayBuffer:()=>Kt,fromBlob:()=>Vt,fromCustomClient:()=>Nt,fromFile:()=>zt,fromUrl:()=>vt,fromUrls:()=>Ht,getDecoder:()=>xe.f,globals:()=>we,rgb:()=>i,setLogger:()=>Ot,writeArrayBuffer:()=>jt});var i={};function s(e){return(t,...r)=>o(e,t,r)}function n(e,t){return s(c(e,t).get)}r.r(i),r.d(i,{fromBlackIsZero:()=>Se,fromCIELab:()=>De,fromCMYK:()=>Te,fromPalette:()=>be,fromWhiteIsZero:()=>me,fromYCbCr:()=>Ie});const{apply:o,construct:a,defineProperty:l,get:h,getOwnPropertyDescriptor:c,getPrototypeOf:f,has:u,ownKeys:d,set:g,setPrototypeOf:p}=Reflect,{EPSILON:y,MAX_SAFE_INTEGER:w,isFinite:m,isNaN:S}=Number,{iterator:b,species:T,toStringTag:I,for:A}=Symbol,E=Object,{create:P,defineProperty:D,freeze:x,is:C}=E,O=E.prototype,M=(O.__lookupGetter__&&s(O.__lookupGetter__),E.hasOwn||s(O.hasOwnProperty),Array),G=(M.isArray,M.prototype),F=(s(G.join),s(G.push),s(G.toLocaleString),G[b]),R=s(F),{abs:U,trunc:_}=Math,k=ArrayBuffer,L=(k.isView,k.prototype),B=(s(L.slice),n(L,"byteLength"),"undefined"!=typeof SharedArrayBuffer?SharedArrayBuffer:null),v=(B&&n(B.prototype,"byteLength"),f(Uint8Array)),N=(v.from,v.prototype),K=(N[b],s(N.keys),s(N.values),s(N.entries),s(N.set),s(N.reverse),s(N.fill),s(N.copyWithin),s(N.sort),s(N.slice),s(N.subarray),n(N,"buffer"),n(N,"byteOffset"),n(N,"length"),n(N,I),Uint8Array),z=Uint16Array,V=Uint32Array,H=Float32Array,j=f([][b]()),q=s(j.next),W=s(function*(){}().next),$=f(j),Y=DataView.prototype,X=s(Y.getUint16),Z=(s(Y.setUint16),TypeError,WeakSet.prototype),J=(s(Z.add),s(Z.has),WeakMap),Q=J.prototype,ee=s(Q.get),te=(s(Q.has),s(Q.set)),re=new J,ie=P(null,{next:{value:function(){const e=ee(re,this);return q(e)}},[b]:{value:function(){return this}}}),se=new J,ne=P($,{next:{value:function(){const e=ee(se,this);return W(e)},writable:!0,configurable:!0}});for(const e of d(j))"next"!==e&&D(ne,e,c(j,e));const oe=new k(4),ae=new H(oe),le=new V(oe),he=new z(512),ce=new K(512);for(let e=0;e<256;++e){const t=e-127;t<-24?(he[e]=0,he[256|e]=32768,ce[e]=24,ce[256|e]=24):t<-14?(he[e]=1024>>-t-14,he[256|e]=1024>>-t-14|32768,ce[e]=-t-1,ce[256|e]=-t-1):t<=15?(he[e]=t+15<<10,he[256|e]=t+15<<10|32768,ce[e]=13,ce[256|e]=13):t<128?(he[e]=31744,he[256|e]=64512,ce[e]=24,ce[256|e]=24):(he[e]=31744,he[256|e]=64512,ce[e]=13,ce[256|e]=13)}const fe=new V(2048);for(let e=1;e<1024;++e){let t=e<<13,r=0;for(;!(8388608&t);)t<<=1,r-=8388608;t&=-8388609,r+=947912704,fe[e]=t|r}for(let e=1024;e<2048;++e)fe[e]=939524096+(e-1024<<13);const ue=new V(64);for(let e=1;e<31;++e)ue[e]=e<<23;ue[31]=1199570944,ue[32]=2147483648;for(let e=33;e<63;++e)ue[e]=2147483648+(e-32<<23);ue[63]=3347054592;const de=new z(64);for(let e=1;e<64;++e)32!==e&&(de[e]=1024);function ge(e,t,...r){return function(e){const t=e>>10;return le[0]=fe[de[t]+(1023&e)]+ue[t],ae[0]}(X(e,t,...function(e){if(e[b]===F&&j.next===q)return e;const t=P(ie);return te(re,t,R(e)),t}(r)))}var pe=r(527379),ye=r(60563),we=r(698622);function me(e,t){const{width:r,height:i}=e,s=new Uint8Array(r*i*3);let n;for(let r=0,i=0;r<e.length;++r,i+=3)n=256-e[r]/t*256,s[i]=n,s[i+1]=n,s[i+2]=n;return s}function Se(e,t){const{width:r,height:i}=e,s=new Uint8Array(r*i*3);let n;for(let r=0,i=0;r<e.length;++r,i+=3)n=e[r]/t*256,s[i]=n,s[i+1]=n,s[i+2]=n;return s}function be(e,t){const{width:r,height:i}=e,s=new Uint8Array(r*i*3),n=t.length/3,o=t.length/3*2;for(let r=0,i=0;r<e.length;++r,i+=3){const a=e[r];s[i]=t[a]/65536*256,s[i+1]=t[a+n]/65536*256,s[i+2]=t[a+o]/65536*256}return s}function Te(e){const{width:t,height:r}=e,i=new Uint8Array(t*r*3);for(let t=0,r=0;t<e.length;t+=4,r+=3){const s=e[t],n=e[t+1],o=e[t+2],a=e[t+3];i[r]=(255-s)/256*255*((255-a)/256),i[r+1]=(255-n)/256*255*((255-a)/256),i[r+2]=(255-o)/256*255*((255-a)/256)}return i}function Ie(e){const{width:t,height:r}=e,i=new Uint8ClampedArray(t*r*3);for(let t=0,r=0;t<e.length;t+=3,r+=3){const s=e[t],n=e[t+1],o=e[t+2];i[r]=s+1.402*(o-128),i[r+1]=s-.34414*(n-128)-.71414*(o-128),i[r+2]=s+1.772*(n-128)}return i}const Ae=.95047,Ee=1,Pe=1.08883;function De(e){const{width:t,height:r}=e,i=new Uint8Array(t*r*3);for(let t=0,r=0;t<e.length;t+=3,r+=3){let s,n,o,a=(e[t+0]+16)/116,l=(e[t+1]<<24>>24)/500+a,h=a-(e[t+2]<<24>>24)/200;l=Ae*(l*l*l>.008856?l*l*l:(l-16/116)/7.787),a=Ee*(a*a*a>.008856?a*a*a:(a-16/116)/7.787),h=Pe*(h*h*h>.008856?h*h*h:(h-16/116)/7.787),s=3.2406*l+-1.5372*a+-.4986*h,n=-.9689*l+1.8758*a+.0415*h,o=.0557*l+-.204*a+1.057*h,s=s>.0031308?1.055*s**(1/2.4)-.055:12.92*s,n=n>.0031308?1.055*n**(1/2.4)-.055:12.92*n,o=o>.0031308?1.055*o**(1/2.4)-.055:12.92*o,i[r]=255*Math.max(0,Math.min(1,s)),i[r+1]=255*Math.max(0,Math.min(1,n)),i[r+2]=255*Math.max(0,Math.min(1,o))}return i}var xe=r(970851);function Ce(e,t,r,i=1){return new(Object.getPrototypeOf(e).constructor)(t*r*i)}function Oe(e,t,r){return(1-r)*e+r*t}function Me(e,t,r){let i=0;for(let s=t;s<r;++s)i+=e[s];return i}function Ge(e,t,r){switch(e){case 1:if(t<=8)return new Uint8Array(r);if(t<=16)return new Uint16Array(r);if(t<=32)return new Uint32Array(r);break;case 2:if(8===t)return new Int8Array(r);if(16===t)return new Int16Array(r);if(32===t)return new Int32Array(r);break;case 3:switch(t){case 16:case 32:return new Float32Array(r);case 64:return new Float64Array(r)}}throw Error("Unsupported data format/bitsPerSample")}const Fe=class{constructor(e,t,r,i,s,n){this.fileDirectory=e,this.geoKeys=t,this.dataView=r,this.littleEndian=i,this.tiles=s?{}:null,this.isTiled=!e.StripOffsets;const o=e.PlanarConfiguration;if(this.planarConfiguration=void 0===o?1:o,1!==this.planarConfiguration&&2!==this.planarConfiguration)throw new Error("Invalid planar configuration.");this.source=n}getFileDirectory(){return this.fileDirectory}getGeoKeys(){return this.geoKeys}getWidth(){return this.fileDirectory.ImageWidth}getHeight(){return this.fileDirectory.ImageLength}getSamplesPerPixel(){return void 0!==this.fileDirectory.SamplesPerPixel?this.fileDirectory.SamplesPerPixel:1}getTileWidth(){return this.isTiled?this.fileDirectory.TileWidth:this.getWidth()}getTileHeight(){return this.isTiled?this.fileDirectory.TileLength:void 0!==this.fileDirectory.RowsPerStrip?Math.min(this.fileDirectory.RowsPerStrip,this.getHeight()):this.getHeight()}getBlockWidth(){return this.getTileWidth()}getBlockHeight(e){return this.isTiled||(e+1)*this.getTileHeight()<=this.getHeight()?this.getTileHeight():this.getHeight()-e*this.getTileHeight()}getBytesPerPixel(){let e=0;for(let t=0;t<this.fileDirectory.BitsPerSample.length;++t)e+=this.getSampleByteSize(t);return e}getSampleByteSize(e){if(e>=this.fileDirectory.BitsPerSample.length)throw new RangeError(`Sample index ${e} is out of range.`);return Math.ceil(this.fileDirectory.BitsPerSample[e]/8)}getReaderForSample(e){const t=this.fileDirectory.SampleFormat?this.fileDirectory.SampleFormat[e]:1,r=this.fileDirectory.BitsPerSample[e];switch(t){case 1:if(r<=8)return DataView.prototype.getUint8;if(r<=16)return DataView.prototype.getUint16;if(r<=32)return DataView.prototype.getUint32;break;case 2:if(r<=8)return DataView.prototype.getInt8;if(r<=16)return DataView.prototype.getInt16;if(r<=32)return DataView.prototype.getInt32;break;case 3:switch(r){case 16:return function(e,t){return ge(this,e,t)};case 32:return DataView.prototype.getFloat32;case 64:return DataView.prototype.getFloat64}}throw Error("Unsupported data format/bitsPerSample")}getSampleFormat(e=0){return this.fileDirectory.SampleFormat?this.fileDirectory.SampleFormat[e]:1}getBitsPerSample(e=0){return this.fileDirectory.BitsPerSample[e]}getArrayForSample(e,t){return Ge(this.getSampleFormat(e),this.getBitsPerSample(e),t)}async getTileOrStrip(e,t,r,i,s){const n=Math.ceil(this.getWidth()/this.getTileWidth()),o=Math.ceil(this.getHeight()/this.getTileHeight());let a;const{tiles:l}=this;let h,c;1===this.planarConfiguration?a=t*n+e:2===this.planarConfiguration&&(a=r*n*o+t*n+e),this.isTiled?(h=this.fileDirectory.TileOffsets[a],c=this.fileDirectory.TileByteCounts[a]):(h=this.fileDirectory.StripOffsets[a],c=this.fileDirectory.StripByteCounts[a]);const f=(await this.source.fetch([{offset:h,length:c}],s))[0];let u;return null!==l&&l[a]?u=l[a]:(u=(async()=>{let e=await i.decode(this.fileDirectory,f);const r=this.getSampleFormat(),s=this.getBitsPerSample();return function(e,t){return(1!==e&&2!==e||!(t<=32)||t%8!=0)&&(3!==e||16!==t&&32!==t&&64!==t)}(r,s)&&(e=function(e,t,r,i,s,n,o){const a=new DataView(e),l=2===r?1:i,h=Ge(t,s,2===r?o*n:o*n*i),c=parseInt("1".repeat(s),2);if(1===t){let e;e=1===r?i*s:s;let t=n*e;7&t&&(t=t+7&-8);for(let e=0;e<o;++e){const r=e*t;for(let t=0;t<n;++t){const i=r+t*l*s;for(let r=0;r<l;++r){const o=i+r*s,f=(e*n+t)*l+r,u=Math.floor(o/8),d=o%8;if(d+s<=8)h[f]=a.getUint8(u)>>8-s-d&c;else if(d+s<=16)h[f]=a.getUint16(u)>>16-s-d&c;else if(d+s<=24){const e=a.getUint16(u)<<8|a.getUint8(u+2);h[f]=e>>24-s-d&c}else h[f]=a.getUint32(u)>>32-s-d&c}}}}return h.buffer}(e,r,this.planarConfiguration,this.getSamplesPerPixel(),s,this.getTileWidth(),this.getBlockHeight(t))),e})(),null!==l&&(l[a]=u)),{x:e,y:t,sample:r,data:await u}}async _readRaster(e,t,r,i,s,n,o,a,l){const h=this.getTileWidth(),c=this.getTileHeight(),f=this.getWidth(),u=this.getHeight(),d=Math.max(Math.floor(e[0]/h),0),g=Math.min(Math.ceil(e[2]/h),Math.ceil(f/h)),p=Math.max(Math.floor(e[1]/c),0),y=Math.min(Math.ceil(e[3]/c),Math.ceil(u/c)),w=e[2]-e[0];let m=this.getBytesPerPixel();const S=[],b=[];for(let e=0;e<t.length;++e)1===this.planarConfiguration?S.push(Me(this.fileDirectory.BitsPerSample,0,t[e])/8):S.push(0),b.push(this.getReaderForSample(t[e]));const T=[],{littleEndian:I}=this;for(let n=p;n<y;++n)for(let o=d;o<g;++o){let a;1===this.planarConfiguration&&(a=this.getTileOrStrip(o,n,0,s,l));for(let d=0;d<t.length;++d){const g=d,p=t[d];2===this.planarConfiguration&&(m=this.getSampleByteSize(p),a=this.getTileOrStrip(o,n,p,s,l));const y=a.then(s=>{const n=s.data,o=new DataView(n),a=this.getBlockHeight(s.y),l=s.y*c,d=s.x*h,p=l+a,y=(s.x+1)*h,T=b[g],A=Math.min(a,a-(p-e[3]),u-l),E=Math.min(h,h-(y-e[2]),f-d);for(let s=Math.max(0,e[1]-l);s<A;++s)for(let n=Math.max(0,e[0]-d);n<E;++n){const a=(s*h+n)*m,c=T.call(o,a+S[g],I);let f;i?(f=(s+l-e[1])*w*t.length+(n+d-e[0])*t.length+g,r[f]=c):(f=(s+l-e[1])*w+n+d-e[0],r[g][f]=c)}});T.push(y)}}if(await Promise.all(T),n&&e[2]-e[0]!==n||o&&e[3]-e[1]!==o){let s;return s=i?function(e,t,r,i,s,n,o="nearest"){switch(o.toLowerCase()){case"nearest":return function(e,t,r,i,s,n){const o=t/i,a=r/s,l=Ce(e,i,s,n);for(let h=0;h<s;++h){const s=Math.min(Math.round(a*h),r-1);for(let r=0;r<i;++r){const a=Math.min(Math.round(o*r),t-1);for(let o=0;o<n;++o){const c=e[s*t*n+a*n+o];l[h*i*n+r*n+o]=c}}}return l}(e,t,r,i,s,n);case"bilinear":case"linear":return function(e,t,r,i,s,n){const o=t/i,a=r/s,l=Ce(e,i,s,n);for(let h=0;h<s;++h){const s=a*h,c=Math.floor(s),f=Math.min(Math.ceil(s),r-1);for(let r=0;r<i;++r){const a=o*r,u=a%1,d=Math.floor(a),g=Math.min(Math.ceil(a),t-1);for(let o=0;o<n;++o){const a=e[c*t*n+d*n+o],p=e[c*t*n+g*n+o],y=e[f*t*n+d*n+o],w=e[f*t*n+g*n+o],m=Oe(Oe(a,p,u),Oe(y,w,u),s%1);l[h*i*n+r*n+o]=m}}}return l}(e,t,r,i,s,n);default:throw new Error(`Unsupported resampling method: '${o}'`)}}(r,e[2]-e[0],e[3]-e[1],n,o,t.length,a):function(e,t,r,i,s,n="nearest"){switch(n.toLowerCase()){case"nearest":return function(e,t,r,i,s){const n=t/i,o=r/s;return e.map(e=>{const a=Ce(e,i,s);for(let l=0;l<s;++l){const s=Math.min(Math.round(o*l),r-1);for(let r=0;r<i;++r){const o=Math.min(Math.round(n*r),t-1),h=e[s*t+o];a[l*i+r]=h}}return a})}(e,t,r,i,s);case"bilinear":case"linear":return function(e,t,r,i,s){const n=t/i,o=r/s;return e.map(e=>{const a=Ce(e,i,s);for(let l=0;l<s;++l){const s=o*l,h=Math.floor(s),c=Math.min(Math.ceil(s),r-1);for(let r=0;r<i;++r){const o=n*r,f=o%1,u=Math.floor(o),d=Math.min(Math.ceil(o),t-1),g=e[h*t+u],p=e[h*t+d],y=e[c*t+u],w=e[c*t+d],m=Oe(Oe(g,p,f),Oe(y,w,f),s%1);a[l*i+r]=m}}return a})}(e,t,r,i,s);default:throw new Error(`Unsupported resampling method: '${n}'`)}}(r,e[2]-e[0],e[3]-e[1],n,o,a),s.width=n,s.height=o,s}return r.width=n||e[2]-e[0],r.height=o||e[3]-e[1],r}async readRasters({window:e,samples:t=[],interleave:r,pool:i=null,width:s,height:n,resampleMethod:o,fillValue:a,signal:l}={}){const h=e||[0,0,this.getWidth(),this.getHeight()];if(h[0]>h[2]||h[1]>h[3])throw new Error("Invalid subsets");const c=(h[2]-h[0])*(h[3]-h[1]),f=this.getSamplesPerPixel();if(t&&t.length){for(let e=0;e<t.length;++e)if(t[e]>=f)return Promise.reject(new RangeError(`Invalid sample index '${t[e]}'.`))}else for(let e=0;e<f;++e)t.push(e);let u;if(r)u=Ge(this.fileDirectory.SampleFormat?Math.max.apply(null,this.fileDirectory.SampleFormat):1,Math.max.apply(null,this.fileDirectory.BitsPerSample),c*t.length),a&&u.fill(a);else{u=[];for(let e=0;e<t.length;++e){const r=this.getArrayForSample(t[e],c);Array.isArray(a)&&e<a.length?r.fill(a[e]):a&&!Array.isArray(a)&&r.fill(a),u.push(r)}}const d=i||await(0,xe.f)(this.fileDirectory);return await this._readRaster(h,t,u,r,d,s,n,o,l)}async readRGB({window:e,interleave:t=!0,pool:r=null,width:i,height:s,resampleMethod:n,enableAlpha:o=!1,signal:a}={}){const l=e||[0,0,this.getWidth(),this.getHeight()];if(l[0]>l[2]||l[1]>l[3])throw new Error("Invalid subsets");const h=this.fileDirectory.PhotometricInterpretation;if(h===we.photometricInterpretations.RGB){let l=[0,1,2];if(this.fileDirectory.ExtraSamples!==we.ExtraSamplesValues.Unspecified&&o){l=[];for(let e=0;e<this.fileDirectory.BitsPerSample.length;e+=1)l.push(e)}return this.readRasters({window:e,interleave:t,samples:l,pool:r,width:i,height:s,resampleMethod:n,signal:a})}let c;switch(h){case we.photometricInterpretations.WhiteIsZero:case we.photometricInterpretations.BlackIsZero:case we.photometricInterpretations.Palette:c=[0];break;case we.photometricInterpretations.CMYK:c=[0,1,2,3];break;case we.photometricInterpretations.YCbCr:case we.photometricInterpretations.CIELab:c=[0,1,2];break;default:throw new Error("Invalid or unsupported photometric interpretation.")}const f={window:l,interleave:!0,samples:c,pool:r,width:i,height:s,resampleMethod:n,signal:a},{fileDirectory:u}=this,d=await this.readRasters(f),g=2**this.fileDirectory.BitsPerSample[0];let p;switch(h){case we.photometricInterpretations.WhiteIsZero:p=me(d,g);break;case we.photometricInterpretations.BlackIsZero:p=Se(d,g);break;case we.photometricInterpretations.Palette:p=be(d,u.ColorMap);break;case we.photometricInterpretations.CMYK:p=Te(d);break;case we.photometricInterpretations.YCbCr:p=Ie(d);break;case we.photometricInterpretations.CIELab:p=De(d);break;default:throw new Error("Unsupported photometric interpretation.")}if(!t){const e=new Uint8Array(p.length/3),t=new Uint8Array(p.length/3),r=new Uint8Array(p.length/3);for(let i=0,s=0;i<p.length;i+=3,++s)e[s]=p[i],t[s]=p[i+1],r[s]=p[i+2];p=[e,t,r]}return p.width=d.width,p.height=d.height,p}getTiePoints(){if(!this.fileDirectory.ModelTiepoint)return[];const e=[];for(let t=0;t<this.fileDirectory.ModelTiepoint.length;t+=6)e.push({i:this.fileDirectory.ModelTiepoint[t],j:this.fileDirectory.ModelTiepoint[t+1],k:this.fileDirectory.ModelTiepoint[t+2],x:this.fileDirectory.ModelTiepoint[t+3],y:this.fileDirectory.ModelTiepoint[t+4],z:this.fileDirectory.ModelTiepoint[t+5]});return e}getGDALMetadata(e=null){const t={};if(!this.fileDirectory.GDAL_METADATA)return null;const r=this.fileDirectory.GDAL_METADATA;let i=ye(r,"Item");i=null===e?i.filter(e=>void 0===pe(e,"sample")):i.filter(t=>Number(pe(t,"sample"))===e);for(let e=0;e<i.length;++e){const r=i[e];t[pe(r,"name")]=r.inner}return t}getGDALNoData(){if(!this.fileDirectory.GDAL_NODATA)return null;const e=this.fileDirectory.GDAL_NODATA;return Number(e.substring(0,e.length-1))}getOrigin(){const e=this.fileDirectory.ModelTiepoint,t=this.fileDirectory.ModelTransformation;if(e&&6===e.length)return[e[3],e[4],e[5]];if(t)return[t[3],t[7],t[11]];throw new Error("The image does not have an affine transformation.")}getResolution(e=null){const t=this.fileDirectory.ModelPixelScale,r=this.fileDirectory.ModelTransformation;if(t)return[t[0],-t[1],t[2]];if(r)return 0===r[1]&&0===r[4]?[r[0],-r[5],r[10]]:[Math.sqrt(r[0]*r[0]+r[4]*r[4]),-Math.sqrt(r[1]*r[1]+r[5]*r[5]),r[10]];if(e){const[t,r,i]=e.getResolution();return[t*e.getWidth()/this.getWidth(),r*e.getHeight()/this.getHeight(),i*e.getWidth()/this.getWidth()]}throw new Error("The image does not have an affine transformation.")}pixelIsArea(){return 1===this.geoKeys.GTRasterTypeGeoKey}getBoundingBox(e=!1){const t=this.getHeight(),r=this.getWidth();if(this.fileDirectory.ModelTransformation&&!e){const[e,i,s,n,o,a,l,h]=this.fileDirectory.ModelTransformation,c=[[0,0],[0,t],[r,0],[r,t]].map(([t,r])=>[n+e*t+i*r,h+o*t+a*r]),f=c.map(e=>e[0]),u=c.map(e=>e[1]);return[Math.min(...f),Math.min(...u),Math.max(...f),Math.max(...u)]}{const e=this.getOrigin(),i=this.getResolution(),s=e[0],n=e[1],o=s+i[0]*r,a=n+i[1]*t;return[Math.min(s,o),Math.min(n,a),Math.max(s,o),Math.max(n,a)]}}};class Re{constructor(e){this._dataView=new DataView(e)}get buffer(){return this._dataView.buffer}getUint64(e,t){const r=this.getUint32(e,t),i=this.getUint32(e+4,t);let s;if(t){if(s=r+2**32*i,!Number.isSafeInteger(s))throw new Error(`${s} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);return s}if(s=2**32*r+i,!Number.isSafeInteger(s))throw new Error(`${s} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);return s}getInt64(e,t){let r=0;const i=(128&this._dataView.getUint8(e+(t?7:0)))>0;let s=!0;for(let n=0;n<8;n++){let o=this._dataView.getUint8(e+(t?n:7-n));i&&(s?0!==o&&(o=255&~(o-1),s=!1):o=255&~o),r+=o*256**n}return i&&(r=-r),r}getUint8(e,t){return this._dataView.getUint8(e,t)}getInt8(e,t){return this._dataView.getInt8(e,t)}getUint16(e,t){return this._dataView.getUint16(e,t)}getInt16(e,t){return this._dataView.getInt16(e,t)}getUint32(e,t){return this._dataView.getUint32(e,t)}getInt32(e,t){return this._dataView.getInt32(e,t)}getFloat16(e,t){return ge(this._dataView,e,t)}getFloat32(e,t){return this._dataView.getFloat32(e,t)}getFloat64(e,t){return this._dataView.getFloat64(e,t)}}class Ue{constructor(e,t,r,i){this._dataView=new DataView(e),this._sliceOffset=t,this._littleEndian=r,this._bigTiff=i}get sliceOffset(){return this._sliceOffset}get sliceTop(){return this._sliceOffset+this.buffer.byteLength}get littleEndian(){return this._littleEndian}get bigTiff(){return this._bigTiff}get buffer(){return this._dataView.buffer}covers(e,t){return this.sliceOffset<=e&&this.sliceTop>=e+t}readUint8(e){return this._dataView.getUint8(e-this._sliceOffset,this._littleEndian)}readInt8(e){return this._dataView.getInt8(e-this._sliceOffset,this._littleEndian)}readUint16(e){return this._dataView.getUint16(e-this._sliceOffset,this._littleEndian)}readInt16(e){return this._dataView.getInt16(e-this._sliceOffset,this._littleEndian)}readUint32(e){return this._dataView.getUint32(e-this._sliceOffset,this._littleEndian)}readInt32(e){return this._dataView.getInt32(e-this._sliceOffset,this._littleEndian)}readFloat32(e){return this._dataView.getFloat32(e-this._sliceOffset,this._littleEndian)}readFloat64(e){return this._dataView.getFloat64(e-this._sliceOffset,this._littleEndian)}readUint64(e){const t=this.readUint32(e),r=this.readUint32(e+4);let i;if(this._littleEndian){if(i=t+2**32*r,!Number.isSafeInteger(i))throw new Error(`${i} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);return i}if(i=2**32*t+r,!Number.isSafeInteger(i))throw new Error(`${i} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);return i}readInt64(e){let t=0;const r=(128&this._dataView.getUint8(e+(this._littleEndian?7:0)))>0;let i=!0;for(let s=0;s<8;s++){let n=this._dataView.getUint8(e+(this._littleEndian?s:7-s));r&&(i?0!==n&&(n=255&~(n-1),i=!1):n=255&~n),t+=n*256**s}return r&&(t=-t),t}readOffset(e){return this._bigTiff?this.readUint64(e):this.readUint32(e)}}var _e=r(227630);function ke(e){if(void 0!==Object.fromEntries)return Object.fromEntries(e);const t={};for(const[r,i]of e)t[r.toLowerCase()]=i;return t}function Le(e){return ke(e.split("\r\n").map(e=>{const t=e.split(":").map(e=>e.trim());return t[0]=t[0].toLowerCase(),t}))}function Be(e){let t,r,i;return e&&([,t,r,i]=e.match(/bytes (\d+)-(\d+)\/(\d+)/),t=parseInt(t,10),r=parseInt(r,10),i=parseInt(i,10)),{start:t,end:r,total:i}}class ve{async fetch(e,t=void 0){return Promise.all(e.map(e=>this.fetchSlice(e,t)))}async fetchSlice(e){throw new Error(`fetching of slice ${e} not possible, not implemented`)}get fileSize(){return null}async close(){}}class Ne extends Map{constructor(e={}){if(super(),!(e.maxSize&&e.maxSize>0))throw new TypeError("`maxSize` must be a number greater than 0");if("number"==typeof e.maxAge&&0===e.maxAge)throw new TypeError("`maxAge` must be a number greater than 0");this.maxSize=e.maxSize,this.maxAge=e.maxAge||Number.POSITIVE_INFINITY,this.onEviction=e.onEviction,this.cache=new Map,this.oldCache=new Map,this._size=0}_emitEvictions(e){if("function"==typeof this.onEviction)for(const[t,r]of e)this.onEviction(t,r.value)}_deleteIfExpired(e,t){return"number"==typeof t.expiry&&t.expiry<=Date.now()&&("function"==typeof this.onEviction&&this.onEviction(e,t.value),this.delete(e))}_getOrDeleteIfExpired(e,t){if(!1===this._deleteIfExpired(e,t))return t.value}_getItemValue(e,t){return t.expiry?this._getOrDeleteIfExpired(e,t):t.value}_peek(e,t){const r=t.get(e);return this._getItemValue(e,r)}_set(e,t){this.cache.set(e,t),this._size++,this._size>=this.maxSize&&(this._size=0,this._emitEvictions(this.oldCache),this.oldCache=this.cache,this.cache=new Map)}_moveToRecent(e,t){this.oldCache.delete(e),this._set(e,t)}*_entriesAscending(){for(const e of this.oldCache){const[t,r]=e;this.cache.has(t)||!1===this._deleteIfExpired(t,r)&&(yield e)}for(const e of this.cache){const[t,r]=e;!1===this._deleteIfExpired(t,r)&&(yield e)}}get(e){if(this.cache.has(e)){const t=this.cache.get(e);return this._getItemValue(e,t)}if(this.oldCache.has(e)){const t=this.oldCache.get(e);if(!1===this._deleteIfExpired(e,t))return this._moveToRecent(e,t),t.value}}set(e,t,{maxAge:r=this.maxAge}={}){const i="number"==typeof r&&r!==Number.POSITIVE_INFINITY?Date.now()+r:void 0;return this.cache.has(e)?this.cache.set(e,{value:t,expiry:i}):this._set(e,{value:t,expiry:i}),this}has(e){return this.cache.has(e)?!this._deleteIfExpired(e,this.cache.get(e)):!!this.oldCache.has(e)&&!this._deleteIfExpired(e,this.oldCache.get(e))}peek(e){return this.cache.has(e)?this._peek(e,this.cache):this.oldCache.has(e)?this._peek(e,this.oldCache):void 0}delete(e){const t=this.cache.delete(e);return t&&this._size--,this.oldCache.delete(e)||t}clear(){this.cache.clear(),this.oldCache.clear(),this._size=0}resize(e){if(!(e&&e>0))throw new TypeError("`maxSize` must be a number greater than 0");const t=[...this._entriesAscending()],r=t.length-e;r<0?(this.cache=new Map(t),this.oldCache=new Map,this._size=t.length):(r>0&&this._emitEvictions(t.slice(0,r)),this.oldCache=new Map(t.slice(r)),this.cache=new Map,this._size=0),this.maxSize=e}*keys(){for(const[e]of this)yield e}*values(){for(const[,e]of this)yield e}*[Symbol.iterator](){for(const e of this.cache){const[t,r]=e;!1===this._deleteIfExpired(t,r)&&(yield[t,r.value])}for(const e of this.oldCache){const[t,r]=e;this.cache.has(t)||!1===this._deleteIfExpired(t,r)&&(yield[t,r.value])}}*entriesDescending(){let e=[...this.cache];for(let t=e.length-1;t>=0;--t){const r=e[t],[i,s]=r;!1===this._deleteIfExpired(i,s)&&(yield[i,s.value])}e=[...this.oldCache];for(let t=e.length-1;t>=0;--t){const r=e[t],[i,s]=r;this.cache.has(i)||!1===this._deleteIfExpired(i,s)&&(yield[i,s.value])}}*entriesAscending(){for(const[e,t]of this._entriesAscending())yield[e,t.value]}get size(){if(!this._size)return this.oldCache.size;let e=0;for(const t of this.oldCache.keys())this.cache.has(t)||e++;return Math.min(this._size+e,this.maxSize)}entries(){return this.entriesAscending()}forEach(e,t=this){for(const[r,i]of this.entriesAscending())e.call(t,i,r,this)}get[Symbol.toStringTag](){return JSON.stringify([...this.entriesAscending()])}}function Ke(e,t){for(const r in t)t.hasOwnProperty(r)&&(e[r]=t[r])}function ze(e,t){return!(e.length<t.length)&&e.substr(e.length-t.length)===t}function Ve(e){const t={};for(const r in e)e.hasOwnProperty(r)&&(t[e[r]]=r);return t}function He(e,t){const r=[];for(let i=0;i<e;i++)r.push(t(i));return r}class je extends Error{constructor(e){super(e),Error.captureStackTrace&&Error.captureStackTrace(this,je),this.name="AbortError"}}class qe extends Error{constructor(e,t){super(t),this.errors=e,this.message=t,this.name="AggregateError"}}const We=qe;class $e{constructor(e,t,r=null){this.offset=e,this.length=t,this.data=r}get top(){return this.offset+this.length}}class Ye{constructor(e,t,r){this.offset=e,this.length=t,this.blockIds=r}}class Xe extends ve{constructor(e,{blockSize:t=65536,cacheSize:r=100}={}){super(),this.source=e,this.blockSize=t,this.blockCache=new Ne({maxSize:r,onEviction:(e,t)=>{this.evictedBlocks.set(e,t)}}),this.evictedBlocks=new Map,this.blockRequests=new Map,this.blockIdsToFetch=new Set,this.abortedBlockIds=new Set}get fileSize(){return this.source.fileSize}async fetch(e,t){const r=[],i=[],s=[];this.evictedBlocks.clear();for(const{offset:t,length:n}of e){let e=t+n;const{fileSize:o}=this;null!==o&&(e=Math.min(e,o));for(let n=Math.floor(t/this.blockSize)*this.blockSize;n<e;n+=this.blockSize){const e=Math.floor(n/this.blockSize);this.blockCache.has(e)||this.blockRequests.has(e)||(this.blockIdsToFetch.add(e),i.push(e)),this.blockRequests.has(e)&&r.push(this.blockRequests.get(e)),s.push(e)}}await async function(){return new Promise(e=>setTimeout(e,undefined))}(),this.fetchBlocks(t);const n=[];for(const e of i)this.blockRequests.has(e)&&n.push(this.blockRequests.get(e));await Promise.allSettled(r),await Promise.allSettled(n);const o=[],a=s.filter(e=>this.abortedBlockIds.has(e)||!this.blockCache.has(e));if(a.forEach(e=>this.blockIdsToFetch.add(e)),a.length>0&&t&&!t.aborted){this.fetchBlocks(null);for(const e of a){const t=this.blockRequests.get(e);if(!t)throw new Error(`Block ${e} is not in the block requests`);o.push(t)}await Promise.allSettled(o)}if(t&&t.aborted)throw new je("Request was aborted");const l=s.map(e=>this.blockCache.get(e)||this.evictedBlocks.get(e)),h=l.filter(e=>!e);if(h.length)throw new We(h,"Request failed");const c=new Map(function(e,t){const r=Array.isArray(e)?e:Array.from(e),i=Array.isArray(t)?t:Array.from(t);return r.map((e,t)=>[e,i[t]])}(s,l));return this.readSliceData(e,c)}fetchBlocks(e){if(this.blockIdsToFetch.size>0){const t=this.groupBlocks(this.blockIdsToFetch),r=this.source.fetch(t,e);for(let i=0;i<t.length;++i){const s=t[i];for(const t of s.blockIds)this.blockRequests.set(t,(async()=>{try{const e=(await r)[i],s=t*this.blockSize,n=s-e.offset,o=Math.min(n+this.blockSize,e.data.byteLength),a=e.data.slice(n,o),l=new $e(s,a.byteLength,a,t);this.blockCache.set(t,l),this.abortedBlockIds.delete(t)}catch(r){if("AbortError"!==r.name)throw r;r.signal=e,this.blockCache.delete(t),this.abortedBlockIds.add(t)}finally{this.blockRequests.delete(t)}})())}this.blockIdsToFetch.clear()}}groupBlocks(e){const t=Array.from(e).sort((e,t)=>e-t);if(0===t.length)return[];let r=[],i=null;const s=[];for(const e of t)null===i||i+1===e?(r.push(e),i=e):(s.push(new Ye(r[0]*this.blockSize,r.length*this.blockSize,r)),r=[e],i=e);return s.push(new Ye(r[0]*this.blockSize,r.length*this.blockSize,r)),s}readSliceData(e,t){return e.map(e=>{let r=e.offset+e.length;null!==this.fileSize&&(r=Math.min(this.fileSize,r));const i=Math.floor(e.offset/this.blockSize),s=Math.floor(r/this.blockSize),n=new ArrayBuffer(e.length),o=new Uint8Array(n);for(let n=i;n<=s;++n){const i=t.get(n),s=i.offset-e.offset;let a,l=0,h=0;s<0?l=-s:s>0&&(h=s),a=i.top-r<0?i.length-l:r-i.offset-l;const c=new Uint8Array(i.data,l,a);o.set(c,h)}return n})}}class Ze{get ok(){return this.status>=200&&this.status<=299}get status(){throw new Error("not implemented")}getHeader(e){throw new Error("not implemented")}async getData(){throw new Error("not implemented")}}class Je{constructor(e){this.url=e}async request({headers:e,signal:t}={}){throw new Error("request is not implemented")}}class Qe extends Ze{constructor(e){super(),this.response=e}get status(){return this.response.status}getHeader(e){return this.response.headers.get(e)}async getData(){return this.response.arrayBuffer?await this.response.arrayBuffer():(await this.response.buffer()).buffer}}class et extends Je{constructor(e,t){super(e),this.credentials=t}async request({headers:e,signal:t}={}){const r=await fetch(this.url,{headers:e,credentials:this.credentials,signal:t});return new Qe(r)}}class tt extends Ze{constructor(e,t){super(),this.xhr=e,this.data=t}get status(){return this.xhr.status}getHeader(e){return this.xhr.getResponseHeader(e)}async getData(){return this.data}}class rt extends Je{constructRequest(e,t){return new Promise((r,i)=>{const s=new XMLHttpRequest;s.open("GET",this.url),s.responseType="arraybuffer";for(const[t,r]of Object.entries(e))s.setRequestHeader(t,r);s.onload=()=>{const e=s.response;r(new tt(s,e))},s.onerror=i,s.onabort=()=>i(new je("Request aborted")),s.send(),t&&(t.aborted&&s.abort(),t.addEventListener("abort",()=>s.abort()))})}async request({headers:e,signal:t}={}){return await this.constructRequest(e,t)}}var it=r(928625),st=r(556504),nt=r(994911),ot=r(348287).Buffer;class at extends Ze{constructor(e,t){super(),this.response=e,this.dataPromise=t}get status(){return this.response.statusCode}getHeader(e){return this.response.headers[e]}async getData(){return await this.dataPromise}}class lt extends Je{constructor(e){super(e),this.parsedUrl=nt.parse(this.url),this.httpApi="http:"===this.parsedUrl.protocol?it:st}constructRequest(e,t){return new Promise((r,i)=>{const s=this.httpApi.get({...this.parsedUrl,headers:e},e=>{const t=new Promise(t=>{const r=[];e.on("data",e=>{r.push(e)}),e.on("end",()=>{const e=ot.concat(r).buffer;t(e)}),e.on("error",i)});r(new at(e,t))});s.on("error",i),t&&(t.aborted&&s.destroy(new je("Request aborted")),t.addEventListener("abort",()=>s.destroy(new je("Request aborted"))))})}async request({headers:e,signal:t}={}){return await this.constructRequest(e,t)}}class ht extends ve{constructor(e,t,r,i){super(),this.client=e,this.headers=t,this.maxRanges=r,this.allowFullFile=i,this._fileSize=null}async fetch(e,t){return this.maxRanges>=e.length?this.fetchSlices(e,t):(this.maxRanges>0&&e.length,Promise.all(e.map(e=>this.fetchSlice(e,t))))}async fetchSlices(e,t){const r=await this.client.request({headers:{...this.headers,Range:`bytes=${e.map(({offset:e,length:t})=>`${e}-${e+t}`).join(",")}`},signal:t});if(r.ok){if(206===r.status){const{type:i,params:s}=function(e){const[t,...r]=e.split(";").map(e=>e.trim());return{type:t,params:ke(r.map(e=>e.split("=")))}}(r.getHeader("content-type"));if("multipart/byteranges"===i){const e=function(e,t){let r=null;const i=new TextDecoder("ascii"),s=[],n=`--${t}`,o=`${n}--`;for(let t=0;t<10;++t)i.decode(new Uint8Array(e,t,n.length))===n&&(r=t);if(null===r)throw new Error("Could not find initial boundary");for(;r<e.byteLength;){const t=i.decode(new Uint8Array(e,r,Math.min(n.length+1024,e.byteLength-r)));if(0===t.length||t.startsWith(o))break;if(!t.startsWith(n))throw new Error("Part does not start with boundary");const a=t.substr(n.length+2);if(0===a.length)break;const l=a.indexOf("\r\n\r\n"),h=Le(a.substr(0,l)),{start:c,end:f,total:u}=Be(h["content-range"]),d=r+n.length+l+4,g=parseInt(f,10)+1-parseInt(c,10);s.push({headers:h,data:e.slice(d,d+g),offset:c,length:g,fileSize:u}),r=d+g+4}return s}(await r.getData(),s.boundary);return this._fileSize=e[0].fileSize||null,e}const n=await r.getData(),{start:o,end:a,total:l}=Be(r.getHeader("content-range"));this._fileSize=l||null;const h=[{data:n,offset:o,length:a-o}];if(e.length>1){const r=await Promise.all(e.slice(1).map(e=>this.fetchSlice(e,t)));return h.concat(r)}return h}{if(!this.allowFullFile)throw new Error("Server responded with full file");const e=await r.getData();return this._fileSize=e.byteLength,[{data:e,offset:0,length:e.byteLength}]}}throw new Error("Error fetching data.")}async fetchSlice(e,t){const{offset:r,length:i}=e,s=await this.client.request({headers:{...this.headers,Range:`bytes=${r}-${r+i}`},signal:t});if(s.ok){if(206===s.status){const e=await s.getData(),{total:t}=Be(s.getHeader("content-range"));return this._fileSize=t||null,{data:e,offset:r,length:i}}{if(!this.allowFullFile)throw new Error("Server responded with full file");const e=await s.getData();return this._fileSize=e.byteLength,{data:e,offset:0,length:e.byteLength}}}throw new Error("Error fetching data.")}get fileSize(){return this._fileSize}}function ct(e,{blockSize:t,cacheSize:r}){return null===t?e:new Xe(e,{blockSize:t,cacheSize:r})}function ft(e,{forceXHR:t=!1,...r}={}){return"function"!=typeof fetch||t?"undefined"!=typeof XMLHttpRequest?function(e,{headers:t={},maxRanges:r=0,allowFullFile:i=!1,...s}={}){const n=new rt(e);return ct(new ht(n,t,r,i),s)}(e,r):function(e,{headers:t={},maxRanges:r=0,allowFullFile:i=!1,...s}={}){const n=new lt(e);return ct(new ht(n,t,r,i),s)}(e,r):function(e,{headers:t={},credentials:r,maxRanges:i=0,allowFullFile:s=!1,...n}={}){const o=new et(e,r);return ct(new ht(o,t,i,s),n)}(e,r)}class ut extends ve{constructor(e){super(),this.arrayBuffer=e}fetchSlice(e,t){if(t&&t.aborted)throw new je("Request aborted");return this.arrayBuffer.slice(e.offset,e.offset+e.length)}}class dt extends ve{constructor(e){super(),this.file=e}async fetchSlice(e,t){return new Promise((r,i)=>{const s=this.file.slice(e.offset,e.offset+e.length),n=new FileReader;n.onload=e=>r(e.target.result),n.onerror=i,n.onabort=i,n.readAsArrayBuffer(s),t&&t.addEventListener("abort",()=>n.abort())})}}var gt=r(368236),pt=r(348287).Buffer;class yt extends ve{constructor(e){super(),this.path=e,this.openRequest=function(e){return new Promise((t,r)=>{gt.open(e,"r",undefined,(e,i)=>{e?r(e):t(i)})})}(e)}async fetchSlice(e){const t=await this.openRequest,{buffer:r}=await function(...e){return new Promise((t,r)=>{gt.read(...e,(e,i,s)=>{e?r(e):t({bytesRead:i,buffer:s})})})}(t,pt.alloc(e.length),0,e.length,e.offset);return r.buffer}async close(){const e=await this.openRequest;await function(e){return new Promise((t,r)=>{gt.close(e,e=>{e?r(e):t()})})}(e)}}const wt=Ve(we.fieldTagNames),mt=Ve(we.geoKeyNames),St={};Ke(St,wt),Ke(St,mt);const bt=Ve(we.fieldTypeNames),Tt=1e3,It={nextZero:(e,t)=>{let r=t;for(;0!==e[r];)r++;return r},readUshort:(e,t)=>e[t]<<8|e[t+1],readShort:(e,t)=>{const r=It.ui8;return r[0]=e[t+1],r[1]=e[t+0],It.i16[0]},readInt:(e,t)=>{const r=It.ui8;return r[0]=e[t+3],r[1]=e[t+2],r[2]=e[t+1],r[3]=e[t+0],It.i32[0]},readUint:(e,t)=>{const r=It.ui8;return r[0]=e[t+3],r[1]=e[t+2],r[2]=e[t+1],r[3]=e[t+0],It.ui32[0]},readASCII:(e,t,r)=>r.map(r=>String.fromCharCode(e[t+r])).join(""),readFloat:(e,t)=>{const r=It.ui8;return He(4,i=>{r[i]=e[t+3-i]}),It.fl32[0]},readDouble:(e,t)=>{const r=It.ui8;return He(8,i=>{r[i]=e[t+7-i]}),It.fl64[0]},writeUshort:(e,t,r)=>{e[t]=r>>8&255,e[t+1]=255&r},writeUint:(e,t,r)=>{e[t]=r>>24&255,e[t+1]=r>>16&255,e[t+2]=r>>8&255,e[t+3]=255&r},writeASCII:(e,t,r)=>{He(r.length,i=>{e[t+i]=r.charCodeAt(i)})},ui8:new Uint8Array(8)};It.fl64=new Float64Array(It.ui8.buffer),It.writeDouble=(e,t,r)=>{It.fl64[0]=r,He(8,r=>{e[t+r]=It.ui8[7-r]})};const At=(e,t,r,i)=>{if(null==r)throw new Error(`you passed into encodeImage a width of type ${r}`);if(null==t)throw new Error(`you passed into encodeImage a width of type ${t}`);const s={256:[t],257:[r],273:[Tt],278:[r],305:"geotiff.js"};if(i)for(const e in i)i.hasOwnProperty(e)&&(s[e]=i[e]);const n=new Uint8Array((e=>{const t=new Uint8Array(Tt);let r=4;const i=It;t[0]=77,t[1]=77,t[3]=42;let s=8;if(i.writeUint(t,r,s),r+=4,e.forEach((r,n)=>{const o=((e,t,r,i)=>{let s=r;const n=Object.keys(i).filter(e=>null!=e&&"undefined"!==e);e.writeUshort(t,s,n.length),s+=2;let o=s+12*n.length+4;for(const r of n){let n=null;"number"==typeof r?n=r:"string"==typeof r&&(n=parseInt(r,10));const a=we.fieldTagTypes[n],l=bt[a];if(null==a||void 0===a||void 0===a)throw new Error(`unknown type of tag: ${n}`);let h=i[r];if(void 0===h)throw new Error(`failed to get value for key ${r}`);"ASCII"===a&&"string"==typeof h&&!1===ze(h,"\0")&&(h+="\0");const c=h.length;e.writeUshort(t,s,n),s+=2,e.writeUshort(t,s,l),s+=2,e.writeUint(t,s,c),s+=4;let f=[-1,1,1,2,4,8,0,0,0,0,0,0,8][l]*c,u=s;f>4&&(e.writeUint(t,s,o),u=o),"ASCII"===a?e.writeASCII(t,u,h):"SHORT"===a?He(c,r=>{e.writeUshort(t,u+2*r,h[r])}):"LONG"===a?He(c,r=>{e.writeUint(t,u+4*r,h[r])}):"RATIONAL"===a?He(c,r=>{e.writeUint(t,u+8*r,Math.round(1e4*h[r])),e.writeUint(t,u+8*r+4,1e4)}):"DOUBLE"===a&&He(c,r=>{e.writeDouble(t,u+8*r,h[r])}),f>4&&(f+=1&f,o+=f),s+=4}return[s,o]})(i,t,s,r);s=o[1],n<e.length-1&&i.writeUint(t,o[0],s)}),t.slice)return t.slice(0,s).buffer;const n=new Uint8Array(s);for(let e=0;e<s;e++)n[e]=t[e];return n.buffer})([s])),o=new Uint8Array(e),a=s[277],l=new Uint8Array(Tt+t*r*a);return He(n.length,e=>{l[e]=n[e]}),function(e,t){const{length:r}=e;for(let i=0;i<r;i++)t(e[i],i)}(o,(e,t)=>{l[Tt+t]=e}),l.buffer},Et=e=>{const t={};for(const r in e)"StripOffsets"!==r&&(St[r]||console.error(r,"not in name2code:",Object.keys(St)),t[St[r]]=e[r]);return t},Pt=e=>Array.isArray(e)?e:[e],Dt=[["Compression",1],["PlanarConfiguration",1],["ExtraSamples",0]];class xt{log(){}debug(){}info(){}warn(){}error(){}time(){}timeEnd(){}}let Ct=new xt;function Ot(e=new xt){Ct=e}var Mt=r(250797);function Gt(e){switch(e){case we.fieldTypes.BYTE:case we.fieldTypes.ASCII:case we.fieldTypes.SBYTE:case we.fieldTypes.UNDEFINED:return 1;case we.fieldTypes.SHORT:case we.fieldTypes.SSHORT:return 2;case we.fieldTypes.LONG:case we.fieldTypes.SLONG:case we.fieldTypes.FLOAT:case we.fieldTypes.IFD:return 4;case we.fieldTypes.RATIONAL:case we.fieldTypes.SRATIONAL:case we.fieldTypes.DOUBLE:case we.fieldTypes.LONG8:case we.fieldTypes.SLONG8:case we.fieldTypes.IFD8:return 8;default:throw new RangeError(`Invalid field type: ${e}`)}}function Ft(e,t,r,i){let s=null,n=null;const o=Gt(t);switch(t){case we.fieldTypes.BYTE:case we.fieldTypes.ASCII:case we.fieldTypes.UNDEFINED:s=new Uint8Array(r),n=e.readUint8;break;case we.fieldTypes.SBYTE:s=new Int8Array(r),n=e.readInt8;break;case we.fieldTypes.SHORT:s=new Uint16Array(r),n=e.readUint16;break;case we.fieldTypes.SSHORT:s=new Int16Array(r),n=e.readInt16;break;case we.fieldTypes.LONG:case we.fieldTypes.IFD:s=new Uint32Array(r),n=e.readUint32;break;case we.fieldTypes.SLONG:s=new Int32Array(r),n=e.readInt32;break;case we.fieldTypes.LONG8:case we.fieldTypes.IFD8:s=new Array(r),n=e.readUint64;break;case we.fieldTypes.SLONG8:s=new Array(r),n=e.readInt64;break;case we.fieldTypes.RATIONAL:s=new Uint32Array(2*r),n=e.readUint32;break;case we.fieldTypes.SRATIONAL:s=new Int32Array(2*r),n=e.readInt32;break;case we.fieldTypes.FLOAT:s=new Float32Array(r),n=e.readFloat32;break;case we.fieldTypes.DOUBLE:s=new Float64Array(r),n=e.readFloat64;break;default:throw new RangeError(`Invalid field type: ${t}`)}if(t!==we.fieldTypes.RATIONAL&&t!==we.fieldTypes.SRATIONAL)for(let t=0;t<r;++t)s[t]=n.call(e,i+t*o);else for(let t=0;t<r;t+=2)s[t]=n.call(e,i+t*o),s[t+1]=n.call(e,i+(t*o+4));return t===we.fieldTypes.ASCII?new TextDecoder("utf-8").decode(s):s}class Rt{constructor(e,t,r){this.fileDirectory=e,this.geoKeyDirectory=t,this.nextIFDByteOffset=r}}class Ut extends Error{constructor(e){super(`No image at index ${e}`),this.index=e}}class _t{async readRasters(e={}){const{window:t,width:r,height:i}=e;let{resX:s,resY:n,bbox:o}=e;const a=await this.getImage();let l=a;const h=await this.getImageCount(),c=a.getBoundingBox();if(t&&o)throw new Error('Both "bbox" and "window" passed.');if(r||i){if(t){const[e,r]=a.getOrigin(),[i,s]=a.getResolution();o=[e+t[0]*i,r+t[1]*s,e+t[2]*i,r+t[3]*s]}const e=o||c;if(r){if(s)throw new Error("Both width and resX passed");s=(e[2]-e[0])/r}if(i){if(n)throw new Error("Both width and resY passed");n=(e[3]-e[1])/i}}if(s||n){const e=[];for(let t=0;t<h;++t){const r=await this.getImage(t),{SubfileType:i,NewSubfileType:s}=r.fileDirectory;(0===t||2===i||1&s)&&e.push(r)}e.sort((e,t)=>e.getWidth()-t.getWidth());for(let t=0;t<e.length;++t){const r=e[t],i=(c[2]-c[0])/r.getWidth(),o=(c[3]-c[1])/r.getHeight();if(l=r,s&&s>i||n&&n>o)break}}let f=t;if(o){const[e,t]=a.getOrigin(),[r,i]=l.getResolution(a);f=[Math.round((o[0]-e)/r),Math.round((o[1]-t)/i),Math.round((o[2]-e)/r),Math.round((o[3]-t)/i)],f=[Math.min(f[0],f[2]),Math.min(f[1],f[3]),Math.max(f[0],f[2]),Math.max(f[1],f[3])]}return l.readRasters({...e,window:f})}}class kt extends _t{constructor(e,t,r,i,s={}){super(),this.source=e,this.littleEndian=t,this.bigTiff=r,this.firstIFDOffset=i,this.cache=s.cache||!1,this.ifdRequests=[],this.ghostValues=null}async getSlice(e,t){const r=this.bigTiff?4048:1024;return new Ue((await this.source.fetch([{offset:e,length:void 0!==t?t:r}]))[0],e,this.littleEndian,this.bigTiff)}async parseFileDirectoryAt(e){const t=this.bigTiff?20:12,r=this.bigTiff?8:2;let i=await this.getSlice(e);const s=this.bigTiff?i.readUint64(e):i.readUint16(e),n=s*t+(this.bigTiff?16:6);i.covers(e,n)||(i=await this.getSlice(e,n));const o={};let a=e+(this.bigTiff?8:2);for(let e=0;e<s;a+=t,++e){const e=i.readUint16(a),t=i.readUint16(a+2),r=this.bigTiff?i.readUint64(a+4):i.readUint32(a+4);let s,n;const l=Gt(t),h=a+(this.bigTiff?12:8);if(l*r<=(this.bigTiff?8:4))s=Ft(i,t,r,h);else{const e=i.readOffset(h),n=Gt(t)*r;s=i.covers(e,n)?Ft(i,t,r,e):Ft(await this.getSlice(e,n),t,r,e)}n=1===r&&-1===we.arrayFields.indexOf(e)&&t!==we.fieldTypes.RATIONAL&&t!==we.fieldTypes.SRATIONAL?s[0]:s,o[we.fieldTagNames[e]]=n}const l=function(e){const t=e.GeoKeyDirectory;if(!t)return null;const r={};for(let i=4;i<=4*t[3];i+=4){const s=we.geoKeyNames[t[i]],n=t[i+1]?we.fieldTagNames[t[i+1]]:null,o=t[i+2],a=t[i+3];let l=null;if(n){if(l=e[n],null==l)throw new Error(`Could not get value of geoKey '${s}'.`);"string"==typeof l?l=l.substring(a,a+o-1):l.subarray&&(l=l.subarray(a,a+o),1===o&&(l=l[0]))}else l=a;r[s]=l}return r}(o),h=i.readOffset(e+r+t*s);return new Rt(o,l,h)}async requestIFD(e){if(this.ifdRequests[e])return this.ifdRequests[e];if(0===e)return this.ifdRequests[e]=this.parseFileDirectoryAt(this.firstIFDOffset),this.ifdRequests[e];if(!this.ifdRequests[e-1])try{this.ifdRequests[e-1]=this.requestIFD(e-1)}catch(t){if(t instanceof Ut)throw new Ut(e);throw t}return this.ifdRequests[e]=(async()=>{const t=await this.ifdRequests[e-1];if(0===t.nextIFDByteOffset)throw new Ut(e);return this.parseFileDirectoryAt(t.nextIFDByteOffset)})(),this.ifdRequests[e]}async getImage(e=0){const t=await this.requestIFD(e);return new Fe(t.fileDirectory,t.geoKeyDirectory,this.dataView,this.littleEndian,this.cache,this.source)}async getImageCount(){let e=0,t=!0;for(;t;)try{await this.requestIFD(e),++e}catch(e){if(!(e instanceof Ut))throw e;t=!1}return e}async getGhostValues(){const e=this.bigTiff?16:8;if(this.ghostValues)return this.ghostValues;let t=await this.getSlice(e,130);if("GDAL_STRUCTURAL_METADATA_SIZE="===Ft(t,we.fieldTypes.ASCII,30,e)){const r=Ft(t,we.fieldTypes.ASCII,130,e).split("\n")[0],i=Number(r.split("=")[1].split(" ")[0])+r.length;i>130&&(t=await this.getSlice(e,i));const s=Ft(t,we.fieldTypes.ASCII,i,e);this.ghostValues={},s.split("\n").filter(e=>e.length>0).map(e=>e.split("=")).forEach(([e,t])=>{this.ghostValues[e]=t})}return this.ghostValues}static async fromSource(e,t,r){const i=(await e.fetch([{offset:0,length:1024}],r))[0],s=new Re(i),n=s.getUint16(0,0);let o;if(18761===n)o=!0;else{if(19789!==n)throw new TypeError("Invalid byte order value.");o=!1}const a=s.getUint16(2,o);let l;if(42===a)l=!1;else{if(43!==a)throw new TypeError("Invalid magic number.");if(l=!0,8!==s.getUint16(4,o))throw new Error("Unsupported offset byte-size.")}const h=l?s.getUint64(8,o):s.getUint32(4,o);return new kt(e,o,l,h,t)}close(){return"function"==typeof this.source.close&&this.source.close()}}const Lt=kt;class Bt extends _t{constructor(e,t){super(),this.mainFile=e,this.overviewFiles=t,this.imageFiles=[e].concat(t),this.fileDirectoriesPerFile=null,this.fileDirectoriesPerFileParsing=null,this.imageCount=null}async parseFileDirectoriesPerFile(){const e=[this.mainFile.parseFileDirectoryAt(this.mainFile.firstIFDOffset)].concat(this.overviewFiles.map(e=>e.parseFileDirectoryAt(e.firstIFDOffset)));return this.fileDirectoriesPerFile=await Promise.all(e),this.fileDirectoriesPerFile}async getImage(e=0){await this.getImageCount(),await this.parseFileDirectoriesPerFile();let t=0,r=0;for(let i=0;i<this.imageFiles.length;i++){const s=this.imageFiles[i];for(let n=0;n<this.imageCounts[i];n++){if(e===t){const e=await s.requestIFD(r);return new Fe(e.fileDirectory,e.geoKeyDirectory,s.dataView,s.littleEndian,s.cache,s.source)}t++,r++}r=0}throw new RangeError("Invalid image index")}async getImageCount(){if(null!==this.imageCount)return this.imageCount;const e=[this.mainFile.getImageCount()].concat(this.overviewFiles.map(e=>e.getImageCount()));return this.imageCounts=await Promise.all(e),this.imageCount=this.imageCounts.reduce((e,t)=>e+t,0),this.imageCount}}async function vt(e,t={},r){return kt.fromSource(ft(e,t),r)}async function Nt(e,t={},r){return kt.fromSource(function(e,{headers:t={},maxRanges:r=0,allowFullFile:i=!1,...s}={}){return ct(new ht(e,t,r,i),s)}(e,t),r)}async function Kt(e,t){return kt.fromSource(function(e){return new ut(e)}(e),t)}async function zt(e,t){return kt.fromSource(function(e){return new yt(e)}(e),t)}async function Vt(e,t){return kt.fromSource(new dt(e),t)}async function Ht(e,t=[],r={},i){const s=await kt.fromSource(ft(e,r),i),n=await Promise.all(t.map(e=>kt.fromSource(ft(e,r))));return new Bt(s,n)}function jt(e,t){return function(e,t){let r,i,s,n;"number"==typeof e[0]?(r=t.height||t.ImageLength,s=t.width||t.ImageWidth,i=e.length/(r*s),n=e):(i=e.length,r=e[0].length,s=e[0][0].length,n=[],He(r,t=>{He(s,r=>{He(i,i=>{n.push(e[i][t][r])})})})),t.ImageLength=r,delete t.height,t.ImageWidth=s,delete t.width,t.BitsPerSample||(t.BitsPerSample=He(i,()=>8)),Dt.forEach(e=>{const r=e[0];if(!t[r]){const i=e[1];t[r]=i}}),t.PhotometricInterpretation||(t.PhotometricInterpretation=3===t.BitsPerSample.length?2:1),t.SamplesPerPixel||(t.SamplesPerPixel=[i]),t.StripByteCounts||(t.StripByteCounts=[i*r*s]),t.ModelPixelScale||(t.ModelPixelScale=[360/s,180/r,0]),t.SampleFormat||(t.SampleFormat=He(i,()=>1)),t.hasOwnProperty("GeographicTypeGeoKey")||t.hasOwnProperty("ProjectedCSTypeGeoKey")||(t.GeographicTypeGeoKey=4326,t.ModelTiepoint=[0,0,0,-180,90,0],t.GeogCitationGeoKey="WGS 84",t.GTModelTypeGeoKey=2);const o=Object.keys(t).filter(e=>ze(e,"GeoKey")).sort((e,t)=>St[e]-St[t]);if(!t.GeoAsciiParams){let e="";o.forEach(r=>{const i=Number(St[r]);"ASCII"===we.fieldTagTypes[i]&&(e+=`${t[r].toString()}\0`)}),e.length>0&&(t.GeoAsciiParams=e)}if(!t.GeoKeyDirectory){const e=[1,1,0,o.length];o.forEach(r=>{const i=Number(St[r]);let s,n,o;e.push(i),"SHORT"===we.fieldTagTypes[i]?(s=1,n=0,o=t[r]):"GeogCitationGeoKey"===r?(s=t.GeoAsciiParams.length,n=Number(St.GeoAsciiParams),o=0):console.log(`[geotiff.js] couldn't get TIFFTagLocation for ${r}`),e.push(n),e.push(s),e.push(o)}),t.GeoKeyDirectory=e}for(const e of o)t.hasOwnProperty(e)&&delete t[e];["Compression","ExtraSamples","GeographicTypeGeoKey","GTModelTypeGeoKey","GTRasterTypeGeoKey","ImageLength","ImageWidth","Orientation","PhotometricInterpretation","ProjectedCSTypeGeoKey","PlanarConfiguration","ResolutionUnit","SamplesPerPixel","XPosition","YPosition","RowsPerStrip"].forEach(e=>{t[e]&&(t[e]=Pt(t[e]))});const a=Et(t);return At(n,s,r,a)}(e,t)}},698622:(e,t,r)=>{"use strict";r.r(t),r.d(t,{ExtraSamplesValues:()=>c,LercAddCompression:()=>u,LercParameters:()=>f,arrayFields:()=>o,fieldTagNames:()=>i,fieldTagTypes:()=>n,fieldTags:()=>s,fieldTypeNames:()=>a,fieldTypes:()=>l,geoKeyNames:()=>d,geoKeys:()=>g,photometricInterpretations:()=>h});const i={315:"Artist",258:"BitsPerSample",265:"CellLength",264:"CellWidth",320:"ColorMap",259:"Compression",33432:"Copyright",306:"DateTime",338:"ExtraSamples",266:"FillOrder",289:"FreeByteCounts",288:"FreeOffsets",291:"GrayResponseCurve",290:"GrayResponseUnit",316:"HostComputer",270:"ImageDescription",257:"ImageLength",256:"ImageWidth",271:"Make",281:"MaxSampleValue",280:"MinSampleValue",272:"Model",254:"NewSubfileType",274:"Orientation",262:"PhotometricInterpretation",284:"PlanarConfiguration",296:"ResolutionUnit",278:"RowsPerStrip",277:"SamplesPerPixel",305:"Software",279:"StripByteCounts",273:"StripOffsets",255:"SubfileType",263:"Threshholding",282:"XResolution",283:"YResolution",326:"BadFaxLines",327:"CleanFaxData",343:"ClipPath",328:"ConsecutiveBadFaxLines",433:"Decode",434:"DefaultImageColor",269:"DocumentName",336:"DotRange",321:"HalftoneHints",346:"Indexed",347:"JPEGTables",285:"PageName",297:"PageNumber",317:"Predictor",319:"PrimaryChromaticities",532:"ReferenceBlackWhite",339:"SampleFormat",340:"SMinSampleValue",341:"SMaxSampleValue",559:"StripRowCounts",330:"SubIFDs",292:"T4Options",293:"T6Options",325:"TileByteCounts",323:"TileLength",324:"TileOffsets",322:"TileWidth",301:"TransferFunction",318:"WhitePoint",344:"XClipPathUnits",286:"XPosition",529:"YCbCrCoefficients",531:"YCbCrPositioning",530:"YCbCrSubSampling",345:"YClipPathUnits",287:"YPosition",37378:"ApertureValue",40961:"ColorSpace",36868:"DateTimeDigitized",36867:"DateTimeOriginal",34665:"Exif IFD",36864:"ExifVersion",33434:"ExposureTime",41728:"FileSource",37385:"Flash",40960:"FlashpixVersion",33437:"FNumber",42016:"ImageUniqueID",37384:"LightSource",37500:"MakerNote",37377:"ShutterSpeedValue",37510:"UserComment",33723:"IPTC",34675:"ICC Profile",700:"XMP",42112:"GDAL_METADATA",42113:"GDAL_NODATA",34377:"Photoshop",33550:"ModelPixelScale",33922:"ModelTiepoint",34264:"ModelTransformation",34735:"GeoKeyDirectory",34736:"GeoDoubleParams",34737:"GeoAsciiParams",50674:"LercParameters"},s={};for(const e in i)i.hasOwnProperty(e)&&(s[i[e]]=parseInt(e,10));const n={256:"SHORT",257:"SHORT",258:"SHORT",259:"SHORT",262:"SHORT",273:"LONG",274:"SHORT",277:"SHORT",278:"LONG",279:"LONG",282:"RATIONAL",283:"RATIONAL",284:"SHORT",286:"SHORT",287:"RATIONAL",296:"SHORT",297:"SHORT",305:"ASCII",306:"ASCII",338:"SHORT",339:"SHORT",513:"LONG",514:"LONG",1024:"SHORT",1025:"SHORT",2048:"SHORT",2049:"ASCII",3072:"SHORT",3073:"ASCII",33550:"DOUBLE",33922:"DOUBLE",34264:"DOUBLE",34665:"LONG",34735:"SHORT",34736:"DOUBLE",34737:"ASCII",42113:"ASCII"},o=[s.BitsPerSample,s.ExtraSamples,s.SampleFormat,s.StripByteCounts,s.StripOffsets,s.StripRowCounts,s.TileByteCounts,s.TileOffsets,s.SubIFDs],a={1:"BYTE",2:"ASCII",3:"SHORT",4:"LONG",5:"RATIONAL",6:"SBYTE",7:"UNDEFINED",8:"SSHORT",9:"SLONG",10:"SRATIONAL",11:"FLOAT",12:"DOUBLE",13:"IFD",16:"LONG8",17:"SLONG8",18:"IFD8"},l={};for(const e in a)a.hasOwnProperty(e)&&(l[a[e]]=parseInt(e,10));const h={WhiteIsZero:0,BlackIsZero:1,RGB:2,Palette:3,TransparencyMask:4,CMYK:5,YCbCr:6,CIELab:8,ICCLab:9},c={Unspecified:0,Assocalpha:1,Unassalpha:2},f={Version:0,AddCompression:1},u={None:0,Deflate:1,Zstandard:2},d={1024:"GTModelTypeGeoKey",1025:"GTRasterTypeGeoKey",1026:"GTCitationGeoKey",2048:"GeographicTypeGeoKey",2049:"GeogCitationGeoKey",2050:"GeogGeodeticDatumGeoKey",2051:"GeogPrimeMeridianGeoKey",2052:"GeogLinearUnitsGeoKey",2053:"GeogLinearUnitSizeGeoKey",2054:"GeogAngularUnitsGeoKey",2055:"GeogAngularUnitSizeGeoKey",2056:"GeogEllipsoidGeoKey",2057:"GeogSemiMajorAxisGeoKey",2058:"GeogSemiMinorAxisGeoKey",2059:"GeogInvFlatteningGeoKey",2060:"GeogAzimuthUnitsGeoKey",2061:"GeogPrimeMeridianLongGeoKey",2062:"GeogTOWGS84GeoKey",3072:"ProjectedCSTypeGeoKey",3073:"PCSCitationGeoKey",3074:"ProjectionGeoKey",3075:"ProjCoordTransGeoKey",3076:"ProjLinearUnitsGeoKey",3077:"ProjLinearUnitSizeGeoKey",3078:"ProjStdParallel1GeoKey",3079:"ProjStdParallel2GeoKey",3080:"ProjNatOriginLongGeoKey",3081:"ProjNatOriginLatGeoKey",3082:"ProjFalseEastingGeoKey",3083:"ProjFalseNorthingGeoKey",3084:"ProjFalseOriginLongGeoKey",3085:"ProjFalseOriginLatGeoKey",3086:"ProjFalseOriginEastingGeoKey",3087:"ProjFalseOriginNorthingGeoKey",3088:"ProjCenterLongGeoKey",3089:"ProjCenterLatGeoKey",3090:"ProjCenterEastingGeoKey",3091:"ProjCenterNorthingGeoKey",3092:"ProjScaleAtNatOriginGeoKey",3093:"ProjScaleAtCenterGeoKey",3094:"ProjAzimuthAngleGeoKey",3095:"ProjStraightVertPoleLongGeoKey",3096:"ProjRectifiedGridAngleGeoKey",4096:"VerticalCSTypeGeoKey",4097:"VerticalCitationGeoKey",4098:"VerticalDatumGeoKey",4099:"VerticalUnitsGeoKey"},g={};for(const e in d)d.hasOwnProperty(e)&&(g[d[e]]=parseInt(e,10))},227630:(e,t,r)=>{"use strict";r.d(t,{A:()=>n});var i=r(970851);const s="undefined"!=typeof navigator&&navigator.hardwareConcurrency||2,n=class{constructor(e=s,t){this.workers=null,this._awaitingDecoder=null,this.size=e,this.messageId=0,e&&(this._awaitingDecoder=t?Promise.resolve(t):new Promise(e=>{r.e(55719).then(r.bind(r,255719)).then(t=>{e(t.create)})}),this._awaitingDecoder.then(t=>{this._awaitingDecoder=null,this.workers=[];for(let r=0;r<e;r++)this.workers.push({worker:t(),idle:!0})}))}async decode(e,t){return this._awaitingDecoder&&await this._awaitingDecoder,0===this.size?(0,i.f)(e).then(r=>r.decode(e,t)):new Promise(r=>{const i=this.workers.find(e=>e.idle)||this.workers[Math.floor(Math.random()*this.size)];i.idle=!1;const s=this.messageId++,n=e=>{e.data.id===s&&(i.idle=!0,r(e.data.decoded),i.worker.removeEventListener("message",n))};i.worker.addEventListener("message",n),i.worker.postMessage({fileDirectory:e,buffer:t,id:s},[t])})}destroy(){this.workers&&(this.workers.forEach(e=>{e.worker.terminate()}),this.workers=null)}}}}]);