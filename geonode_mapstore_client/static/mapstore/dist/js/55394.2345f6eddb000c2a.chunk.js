(self.webpackChunkgeonode_mapstore_client=self.webpackChunkgeonode_mapstore_client||[]).push([[55394],{527288:e=>{"use strict";e.exports=function(e,i){i||(i={});var o,r,a,s,c,l,h,u,d,p,m,f=null==i.cutoff?.25:i.cutoff,A=null==i.radius?8:i.radius,_=i.channel||0;if(ArrayBuffer.isView(e)||Array.isArray(e)){if(!i.width||!i.height)throw Error("For raw data width and height should be provided by options");o=i.width,r=i.height,s=e,l=i.stride?i.stride:Math.floor(e.length/o/r)}else window.HTMLCanvasElement&&e instanceof window.HTMLCanvasElement?(h=(u=e).getContext("2d"),o=u.width,r=u.height,s=(d=h.getImageData(0,0,o,r)).data,l=4):window.CanvasRenderingContext2D&&e instanceof window.CanvasRenderingContext2D?(h=e,o=(u=e.canvas).width,r=u.height,s=(d=h.getImageData(0,0,o,r)).data,l=4):window.ImageData&&e instanceof window.ImageData&&(d=e,o=e.width,r=e.height,s=d.data,l=4);if(a=Math.max(o,r),window.Uint8ClampedArray&&s instanceof window.Uint8ClampedArray||window.Uint8Array&&s instanceof window.Uint8Array)for(c=s,s=Array(o*r),p=0,m=Math.floor(c.length/l);p<m;p++)s[p]=c[p*l+_]/255;else if(1!==l)throw Error("Raw data can have only 1 value per pixel");var g=Array(o*r),y=Array(o*r),v=Array(a),b=Array(a),w=Array(a+1),T=Array(a);for(p=0,m=o*r;p<m;p++){var x=s[p];g[p]=1===x?0:0===x?t:Math.pow(Math.max(0,.5-x),2),y[p]=1===x?t:0===x?0:Math.pow(Math.max(0,x-.5),2)}n(g,o,r,v,b,T,w),n(y,o,r,v,b,T,w);var C=window.Float32Array?new Float32Array(o*r):new Array(o*r);for(p=0,m=o*r;p<m;p++)C[p]=Math.min(Math.max(1-((g[p]-y[p])/A+f),0),1);return C};var t=1e20;function n(e,t,n,o,r,a,s){for(var c=0;c<t;c++){for(var l=0;l<n;l++)o[l]=e[l*t+c];for(i(o,r,a,s,n),l=0;l<n;l++)e[l*t+c]=r[l]}for(l=0;l<n;l++){for(c=0;c<t;c++)o[c]=e[l*t+c];for(i(o,r,a,s,t),c=0;c<t;c++)e[l*t+c]=Math.sqrt(r[c])}}function i(e,n,i,o,r){i[0]=0,o[0]=-t,o[1]=+t;for(var a=1,s=0;a<r;a++){for(var c=(e[a]+a*a-(e[i[s]]+i[s]*i[s]))/(2*a-2*i[s]);c<=o[s];)s--,c=(e[a]+a*a-(e[i[s]]+i[s]*i[s]))/(2*a-2*i[s]);i[++s]=a,o[s]=c,o[s+1]=+t}for(a=0,s=0;a<r;a++){for(;o[s+1]<a;)s++;n[a]=(a-i[s])*(a-i[s])+e[i[s]]}}},62052:e=>{e.exports&&(e.exports=function(){var e=3,t=4,n=12,i=13,o=16,r=17;function a(e,t){return 55296<=e.charCodeAt(t)&&e.charCodeAt(t)<=56319&&56320<=e.charCodeAt(t+1)&&e.charCodeAt(t+1)<=57343}function s(e,t){void 0===t&&(t=0);var n=e.charCodeAt(t);if(55296<=n&&n<=56319&&t<e.length-1){var i=n;return 56320<=(o=e.charCodeAt(t+1))&&o<=57343?1024*(i-55296)+(o-56320)+65536:i}if(56320<=n&&n<=57343&&t>=1){var o=n;return 55296<=(i=e.charCodeAt(t-1))&&i<=56319?1024*(i-55296)+(o-56320)+65536:o}return n}function c(a,s,c){var l=[a].concat(s).concat([c]),h=l[l.length-2],u=c,d=l.lastIndexOf(14);if(d>1&&l.slice(1,d).every(function(t){return t==e})&&-1==[e,i,r].indexOf(a))return 2;var p=l.lastIndexOf(t);if(p>0&&l.slice(1,p).every(function(e){return e==t})&&-1==[n,t].indexOf(h))return l.filter(function(e){return e==t}).length%2==1?3:4;if(0==h&&1==u)return 0;if(2==h||0==h||1==h)return 14==u&&s.every(function(t){return t==e})?2:1;if(2==u||0==u||1==u)return 1;if(6==h&&(6==u||7==u||9==u||10==u))return 0;if(!(9!=h&&7!=h||7!=u&&8!=u))return 0;if((10==h||8==h)&&8==u)return 0;if(u==e||15==u)return 0;if(5==u)return 0;if(h==n)return 0;var m=-1!=l.indexOf(e)?l.lastIndexOf(e)-1:l.length-2;return-1!=[i,r].indexOf(l[m])&&l.slice(m+1,-1).every(function(t){return t==e})&&14==u||15==h&&-1!=[o,r].indexOf(u)?0:-1!=s.indexOf(t)?2:h==t&&u==t?0:1}function l(a){return 1536<=a&&a<=1541||1757==a||1807==a||2274==a||3406==a||69821==a||70082<=a&&a<=70083||72250==a||72326<=a&&a<=72329||73030==a?n:13==a?0:10==a?1:0<=a&&a<=9||11<=a&&a<=12||14<=a&&a<=31||127<=a&&a<=159||173==a||1564==a||6158==a||8203==a||8206<=a&&a<=8207||8232==a||8233==a||8234<=a&&a<=8238||8288<=a&&a<=8292||8293==a||8294<=a&&a<=8303||55296<=a&&a<=57343||65279==a||65520<=a&&a<=65528||65529<=a&&a<=65531||113824<=a&&a<=113827||119155<=a&&a<=119162||917504==a||917505==a||917506<=a&&a<=917535||917632<=a&&a<=917759||918e3<=a&&a<=921599?2:768<=a&&a<=879||1155<=a&&a<=1159||1160<=a&&a<=1161||1425<=a&&a<=1469||1471==a||1473<=a&&a<=1474||1476<=a&&a<=1477||1479==a||1552<=a&&a<=1562||1611<=a&&a<=1631||1648==a||1750<=a&&a<=1756||1759<=a&&a<=1764||1767<=a&&a<=1768||1770<=a&&a<=1773||1809==a||1840<=a&&a<=1866||1958<=a&&a<=1968||2027<=a&&a<=2035||2070<=a&&a<=2073||2075<=a&&a<=2083||2085<=a&&a<=2087||2089<=a&&a<=2093||2137<=a&&a<=2139||2260<=a&&a<=2273||2275<=a&&a<=2306||2362==a||2364==a||2369<=a&&a<=2376||2381==a||2385<=a&&a<=2391||2402<=a&&a<=2403||2433==a||2492==a||2494==a||2497<=a&&a<=2500||2509==a||2519==a||2530<=a&&a<=2531||2561<=a&&a<=2562||2620==a||2625<=a&&a<=2626||2631<=a&&a<=2632||2635<=a&&a<=2637||2641==a||2672<=a&&a<=2673||2677==a||2689<=a&&a<=2690||2748==a||2753<=a&&a<=2757||2759<=a&&a<=2760||2765==a||2786<=a&&a<=2787||2810<=a&&a<=2815||2817==a||2876==a||2878==a||2879==a||2881<=a&&a<=2884||2893==a||2902==a||2903==a||2914<=a&&a<=2915||2946==a||3006==a||3008==a||3021==a||3031==a||3072==a||3134<=a&&a<=3136||3142<=a&&a<=3144||3146<=a&&a<=3149||3157<=a&&a<=3158||3170<=a&&a<=3171||3201==a||3260==a||3263==a||3266==a||3270==a||3276<=a&&a<=3277||3285<=a&&a<=3286||3298<=a&&a<=3299||3328<=a&&a<=3329||3387<=a&&a<=3388||3390==a||3393<=a&&a<=3396||3405==a||3415==a||3426<=a&&a<=3427||3530==a||3535==a||3538<=a&&a<=3540||3542==a||3551==a||3633==a||3636<=a&&a<=3642||3655<=a&&a<=3662||3761==a||3764<=a&&a<=3769||3771<=a&&a<=3772||3784<=a&&a<=3789||3864<=a&&a<=3865||3893==a||3895==a||3897==a||3953<=a&&a<=3966||3968<=a&&a<=3972||3974<=a&&a<=3975||3981<=a&&a<=3991||3993<=a&&a<=4028||4038==a||4141<=a&&a<=4144||4146<=a&&a<=4151||4153<=a&&a<=4154||4157<=a&&a<=4158||4184<=a&&a<=4185||4190<=a&&a<=4192||4209<=a&&a<=4212||4226==a||4229<=a&&a<=4230||4237==a||4253==a||4957<=a&&a<=4959||5906<=a&&a<=5908||5938<=a&&a<=5940||5970<=a&&a<=5971||6002<=a&&a<=6003||6068<=a&&a<=6069||6071<=a&&a<=6077||6086==a||6089<=a&&a<=6099||6109==a||6155<=a&&a<=6157||6277<=a&&a<=6278||6313==a||6432<=a&&a<=6434||6439<=a&&a<=6440||6450==a||6457<=a&&a<=6459||6679<=a&&a<=6680||6683==a||6742==a||6744<=a&&a<=6750||6752==a||6754==a||6757<=a&&a<=6764||6771<=a&&a<=6780||6783==a||6832<=a&&a<=6845||6846==a||6912<=a&&a<=6915||6964==a||6966<=a&&a<=6970||6972==a||6978==a||7019<=a&&a<=7027||7040<=a&&a<=7041||7074<=a&&a<=7077||7080<=a&&a<=7081||7083<=a&&a<=7085||7142==a||7144<=a&&a<=7145||7149==a||7151<=a&&a<=7153||7212<=a&&a<=7219||7222<=a&&a<=7223||7376<=a&&a<=7378||7380<=a&&a<=7392||7394<=a&&a<=7400||7405==a||7412==a||7416<=a&&a<=7417||7616<=a&&a<=7673||7675<=a&&a<=7679||8204==a||8400<=a&&a<=8412||8413<=a&&a<=8416||8417==a||8418<=a&&a<=8420||8421<=a&&a<=8432||11503<=a&&a<=11505||11647==a||11744<=a&&a<=11775||12330<=a&&a<=12333||12334<=a&&a<=12335||12441<=a&&a<=12442||42607==a||42608<=a&&a<=42610||42612<=a&&a<=42621||42654<=a&&a<=42655||42736<=a&&a<=42737||43010==a||43014==a||43019==a||43045<=a&&a<=43046||43204<=a&&a<=43205||43232<=a&&a<=43249||43302<=a&&a<=43309||43335<=a&&a<=43345||43392<=a&&a<=43394||43443==a||43446<=a&&a<=43449||43452==a||43493==a||43561<=a&&a<=43566||43569<=a&&a<=43570||43573<=a&&a<=43574||43587==a||43596==a||43644==a||43696==a||43698<=a&&a<=43700||43703<=a&&a<=43704||43710<=a&&a<=43711||43713==a||43756<=a&&a<=43757||43766==a||44005==a||44008==a||44013==a||64286==a||65024<=a&&a<=65039||65056<=a&&a<=65071||65438<=a&&a<=65439||66045==a||66272==a||66422<=a&&a<=66426||68097<=a&&a<=68099||68101<=a&&a<=68102||68108<=a&&a<=68111||68152<=a&&a<=68154||68159==a||68325<=a&&a<=68326||69633==a||69688<=a&&a<=69702||69759<=a&&a<=69761||69811<=a&&a<=69814||69817<=a&&a<=69818||69888<=a&&a<=69890||69927<=a&&a<=69931||69933<=a&&a<=69940||70003==a||70016<=a&&a<=70017||70070<=a&&a<=70078||70090<=a&&a<=70092||70191<=a&&a<=70193||70196==a||70198<=a&&a<=70199||70206==a||70367==a||70371<=a&&a<=70378||70400<=a&&a<=70401||70460==a||70462==a||70464==a||70487==a||70502<=a&&a<=70508||70512<=a&&a<=70516||70712<=a&&a<=70719||70722<=a&&a<=70724||70726==a||70832==a||70835<=a&&a<=70840||70842==a||70845==a||70847<=a&&a<=70848||70850<=a&&a<=70851||71087==a||71090<=a&&a<=71093||71100<=a&&a<=71101||71103<=a&&a<=71104||71132<=a&&a<=71133||71219<=a&&a<=71226||71229==a||71231<=a&&a<=71232||71339==a||71341==a||71344<=a&&a<=71349||71351==a||71453<=a&&a<=71455||71458<=a&&a<=71461||71463<=a&&a<=71467||72193<=a&&a<=72198||72201<=a&&a<=72202||72243<=a&&a<=72248||72251<=a&&a<=72254||72263==a||72273<=a&&a<=72278||72281<=a&&a<=72283||72330<=a&&a<=72342||72344<=a&&a<=72345||72752<=a&&a<=72758||72760<=a&&a<=72765||72767==a||72850<=a&&a<=72871||72874<=a&&a<=72880||72882<=a&&a<=72883||72885<=a&&a<=72886||73009<=a&&a<=73014||73018==a||73020<=a&&a<=73021||73023<=a&&a<=73029||73031==a||92912<=a&&a<=92916||92976<=a&&a<=92982||94095<=a&&a<=94098||113821<=a&&a<=113822||119141==a||119143<=a&&a<=119145||119150<=a&&a<=119154||119163<=a&&a<=119170||119173<=a&&a<=119179||119210<=a&&a<=119213||119362<=a&&a<=119364||121344<=a&&a<=121398||121403<=a&&a<=121452||121461==a||121476==a||121499<=a&&a<=121503||121505<=a&&a<=121519||122880<=a&&a<=122886||122888<=a&&a<=122904||122907<=a&&a<=122913||122915<=a&&a<=122916||122918<=a&&a<=122922||125136<=a&&a<=125142||125252<=a&&a<=125258||917536<=a&&a<=917631||917760<=a&&a<=917999?e:127462<=a&&a<=127487?t:2307==a||2363==a||2366<=a&&a<=2368||2377<=a&&a<=2380||2382<=a&&a<=2383||2434<=a&&a<=2435||2495<=a&&a<=2496||2503<=a&&a<=2504||2507<=a&&a<=2508||2563==a||2622<=a&&a<=2624||2691==a||2750<=a&&a<=2752||2761==a||2763<=a&&a<=2764||2818<=a&&a<=2819||2880==a||2887<=a&&a<=2888||2891<=a&&a<=2892||3007==a||3009<=a&&a<=3010||3014<=a&&a<=3016||3018<=a&&a<=3020||3073<=a&&a<=3075||3137<=a&&a<=3140||3202<=a&&a<=3203||3262==a||3264<=a&&a<=3265||3267<=a&&a<=3268||3271<=a&&a<=3272||3274<=a&&a<=3275||3330<=a&&a<=3331||3391<=a&&a<=3392||3398<=a&&a<=3400||3402<=a&&a<=3404||3458<=a&&a<=3459||3536<=a&&a<=3537||3544<=a&&a<=3550||3570<=a&&a<=3571||3635==a||3763==a||3902<=a&&a<=3903||3967==a||4145==a||4155<=a&&a<=4156||4182<=a&&a<=4183||4228==a||6070==a||6078<=a&&a<=6085||6087<=a&&a<=6088||6435<=a&&a<=6438||6441<=a&&a<=6443||6448<=a&&a<=6449||6451<=a&&a<=6456||6681<=a&&a<=6682||6741==a||6743==a||6765<=a&&a<=6770||6916==a||6965==a||6971==a||6973<=a&&a<=6977||6979<=a&&a<=6980||7042==a||7073==a||7078<=a&&a<=7079||7082==a||7143==a||7146<=a&&a<=7148||7150==a||7154<=a&&a<=7155||7204<=a&&a<=7211||7220<=a&&a<=7221||7393==a||7410<=a&&a<=7411||7415==a||43043<=a&&a<=43044||43047==a||43136<=a&&a<=43137||43188<=a&&a<=43203||43346<=a&&a<=43347||43395==a||43444<=a&&a<=43445||43450<=a&&a<=43451||43453<=a&&a<=43456||43567<=a&&a<=43568||43571<=a&&a<=43572||43597==a||43755==a||43758<=a&&a<=43759||43765==a||44003<=a&&a<=44004||44006<=a&&a<=44007||44009<=a&&a<=44010||44012==a||69632==a||69634==a||69762==a||69808<=a&&a<=69810||69815<=a&&a<=69816||69932==a||70018==a||70067<=a&&a<=70069||70079<=a&&a<=70080||70188<=a&&a<=70190||70194<=a&&a<=70195||70197==a||70368<=a&&a<=70370||70402<=a&&a<=70403||70463==a||70465<=a&&a<=70468||70471<=a&&a<=70472||70475<=a&&a<=70477||70498<=a&&a<=70499||70709<=a&&a<=70711||70720<=a&&a<=70721||70725==a||70833<=a&&a<=70834||70841==a||70843<=a&&a<=70844||70846==a||70849==a||71088<=a&&a<=71089||71096<=a&&a<=71099||71102==a||71216<=a&&a<=71218||71227<=a&&a<=71228||71230==a||71340==a||71342<=a&&a<=71343||71350==a||71456<=a&&a<=71457||71462==a||72199<=a&&a<=72200||72249==a||72279<=a&&a<=72280||72343==a||72751==a||72766==a||72873==a||72881==a||72884==a||94033<=a&&a<=94078||119142==a||119149==a?5:4352<=a&&a<=4447||43360<=a&&a<=43388?6:4448<=a&&a<=4519||55216<=a&&a<=55238?7:4520<=a&&a<=4607||55243<=a&&a<=55291?8:44032==a||44060==a||44088==a||44116==a||44144==a||44172==a||44200==a||44228==a||44256==a||44284==a||44312==a||44340==a||44368==a||44396==a||44424==a||44452==a||44480==a||44508==a||44536==a||44564==a||44592==a||44620==a||44648==a||44676==a||44704==a||44732==a||44760==a||44788==a||44816==a||44844==a||44872==a||44900==a||44928==a||44956==a||44984==a||45012==a||45040==a||45068==a||45096==a||45124==a||45152==a||45180==a||45208==a||45236==a||45264==a||45292==a||45320==a||45348==a||45376==a||45404==a||45432==a||45460==a||45488==a||45516==a||45544==a||45572==a||45600==a||45628==a||45656==a||45684==a||45712==a||45740==a||45768==a||45796==a||45824==a||45852==a||45880==a||45908==a||45936==a||45964==a||45992==a||46020==a||46048==a||46076==a||46104==a||46132==a||46160==a||46188==a||46216==a||46244==a||46272==a||46300==a||46328==a||46356==a||46384==a||46412==a||46440==a||46468==a||46496==a||46524==a||46552==a||46580==a||46608==a||46636==a||46664==a||46692==a||46720==a||46748==a||46776==a||46804==a||46832==a||46860==a||46888==a||46916==a||46944==a||46972==a||47e3==a||47028==a||47056==a||47084==a||47112==a||47140==a||47168==a||47196==a||47224==a||47252==a||47280==a||47308==a||47336==a||47364==a||47392==a||47420==a||47448==a||47476==a||47504==a||47532==a||47560==a||47588==a||47616==a||47644==a||47672==a||47700==a||47728==a||47756==a||47784==a||47812==a||47840==a||47868==a||47896==a||47924==a||47952==a||47980==a||48008==a||48036==a||48064==a||48092==a||48120==a||48148==a||48176==a||48204==a||48232==a||48260==a||48288==a||48316==a||48344==a||48372==a||48400==a||48428==a||48456==a||48484==a||48512==a||48540==a||48568==a||48596==a||48624==a||48652==a||48680==a||48708==a||48736==a||48764==a||48792==a||48820==a||48848==a||48876==a||48904==a||48932==a||48960==a||48988==a||49016==a||49044==a||49072==a||49100==a||49128==a||49156==a||49184==a||49212==a||49240==a||49268==a||49296==a||49324==a||49352==a||49380==a||49408==a||49436==a||49464==a||49492==a||49520==a||49548==a||49576==a||49604==a||49632==a||49660==a||49688==a||49716==a||49744==a||49772==a||49800==a||49828==a||49856==a||49884==a||49912==a||49940==a||49968==a||49996==a||50024==a||50052==a||50080==a||50108==a||50136==a||50164==a||50192==a||50220==a||50248==a||50276==a||50304==a||50332==a||50360==a||50388==a||50416==a||50444==a||50472==a||50500==a||50528==a||50556==a||50584==a||50612==a||50640==a||50668==a||50696==a||50724==a||50752==a||50780==a||50808==a||50836==a||50864==a||50892==a||50920==a||50948==a||50976==a||51004==a||51032==a||51060==a||51088==a||51116==a||51144==a||51172==a||51200==a||51228==a||51256==a||51284==a||51312==a||51340==a||51368==a||51396==a||51424==a||51452==a||51480==a||51508==a||51536==a||51564==a||51592==a||51620==a||51648==a||51676==a||51704==a||51732==a||51760==a||51788==a||51816==a||51844==a||51872==a||51900==a||51928==a||51956==a||51984==a||52012==a||52040==a||52068==a||52096==a||52124==a||52152==a||52180==a||52208==a||52236==a||52264==a||52292==a||52320==a||52348==a||52376==a||52404==a||52432==a||52460==a||52488==a||52516==a||52544==a||52572==a||52600==a||52628==a||52656==a||52684==a||52712==a||52740==a||52768==a||52796==a||52824==a||52852==a||52880==a||52908==a||52936==a||52964==a||52992==a||53020==a||53048==a||53076==a||53104==a||53132==a||53160==a||53188==a||53216==a||53244==a||53272==a||53300==a||53328==a||53356==a||53384==a||53412==a||53440==a||53468==a||53496==a||53524==a||53552==a||53580==a||53608==a||53636==a||53664==a||53692==a||53720==a||53748==a||53776==a||53804==a||53832==a||53860==a||53888==a||53916==a||53944==a||53972==a||54e3==a||54028==a||54056==a||54084==a||54112==a||54140==a||54168==a||54196==a||54224==a||54252==a||54280==a||54308==a||54336==a||54364==a||54392==a||54420==a||54448==a||54476==a||54504==a||54532==a||54560==a||54588==a||54616==a||54644==a||54672==a||54700==a||54728==a||54756==a||54784==a||54812==a||54840==a||54868==a||54896==a||54924==a||54952==a||54980==a||55008==a||55036==a||55064==a||55092==a||55120==a||55148==a||55176==a?9:44033<=a&&a<=44059||44061<=a&&a<=44087||44089<=a&&a<=44115||44117<=a&&a<=44143||44145<=a&&a<=44171||44173<=a&&a<=44199||44201<=a&&a<=44227||44229<=a&&a<=44255||44257<=a&&a<=44283||44285<=a&&a<=44311||44313<=a&&a<=44339||44341<=a&&a<=44367||44369<=a&&a<=44395||44397<=a&&a<=44423||44425<=a&&a<=44451||44453<=a&&a<=44479||44481<=a&&a<=44507||44509<=a&&a<=44535||44537<=a&&a<=44563||44565<=a&&a<=44591||44593<=a&&a<=44619||44621<=a&&a<=44647||44649<=a&&a<=44675||44677<=a&&a<=44703||44705<=a&&a<=44731||44733<=a&&a<=44759||44761<=a&&a<=44787||44789<=a&&a<=44815||44817<=a&&a<=44843||44845<=a&&a<=44871||44873<=a&&a<=44899||44901<=a&&a<=44927||44929<=a&&a<=44955||44957<=a&&a<=44983||44985<=a&&a<=45011||45013<=a&&a<=45039||45041<=a&&a<=45067||45069<=a&&a<=45095||45097<=a&&a<=45123||45125<=a&&a<=45151||45153<=a&&a<=45179||45181<=a&&a<=45207||45209<=a&&a<=45235||45237<=a&&a<=45263||45265<=a&&a<=45291||45293<=a&&a<=45319||45321<=a&&a<=45347||45349<=a&&a<=45375||45377<=a&&a<=45403||45405<=a&&a<=45431||45433<=a&&a<=45459||45461<=a&&a<=45487||45489<=a&&a<=45515||45517<=a&&a<=45543||45545<=a&&a<=45571||45573<=a&&a<=45599||45601<=a&&a<=45627||45629<=a&&a<=45655||45657<=a&&a<=45683||45685<=a&&a<=45711||45713<=a&&a<=45739||45741<=a&&a<=45767||45769<=a&&a<=45795||45797<=a&&a<=45823||45825<=a&&a<=45851||45853<=a&&a<=45879||45881<=a&&a<=45907||45909<=a&&a<=45935||45937<=a&&a<=45963||45965<=a&&a<=45991||45993<=a&&a<=46019||46021<=a&&a<=46047||46049<=a&&a<=46075||46077<=a&&a<=46103||46105<=a&&a<=46131||46133<=a&&a<=46159||46161<=a&&a<=46187||46189<=a&&a<=46215||46217<=a&&a<=46243||46245<=a&&a<=46271||46273<=a&&a<=46299||46301<=a&&a<=46327||46329<=a&&a<=46355||46357<=a&&a<=46383||46385<=a&&a<=46411||46413<=a&&a<=46439||46441<=a&&a<=46467||46469<=a&&a<=46495||46497<=a&&a<=46523||46525<=a&&a<=46551||46553<=a&&a<=46579||46581<=a&&a<=46607||46609<=a&&a<=46635||46637<=a&&a<=46663||46665<=a&&a<=46691||46693<=a&&a<=46719||46721<=a&&a<=46747||46749<=a&&a<=46775||46777<=a&&a<=46803||46805<=a&&a<=46831||46833<=a&&a<=46859||46861<=a&&a<=46887||46889<=a&&a<=46915||46917<=a&&a<=46943||46945<=a&&a<=46971||46973<=a&&a<=46999||47001<=a&&a<=47027||47029<=a&&a<=47055||47057<=a&&a<=47083||47085<=a&&a<=47111||47113<=a&&a<=47139||47141<=a&&a<=47167||47169<=a&&a<=47195||47197<=a&&a<=47223||47225<=a&&a<=47251||47253<=a&&a<=47279||47281<=a&&a<=47307||47309<=a&&a<=47335||47337<=a&&a<=47363||47365<=a&&a<=47391||47393<=a&&a<=47419||47421<=a&&a<=47447||47449<=a&&a<=47475||47477<=a&&a<=47503||47505<=a&&a<=47531||47533<=a&&a<=47559||47561<=a&&a<=47587||47589<=a&&a<=47615||47617<=a&&a<=47643||47645<=a&&a<=47671||47673<=a&&a<=47699||47701<=a&&a<=47727||47729<=a&&a<=47755||47757<=a&&a<=47783||47785<=a&&a<=47811||47813<=a&&a<=47839||47841<=a&&a<=47867||47869<=a&&a<=47895||47897<=a&&a<=47923||47925<=a&&a<=47951||47953<=a&&a<=47979||47981<=a&&a<=48007||48009<=a&&a<=48035||48037<=a&&a<=48063||48065<=a&&a<=48091||48093<=a&&a<=48119||48121<=a&&a<=48147||48149<=a&&a<=48175||48177<=a&&a<=48203||48205<=a&&a<=48231||48233<=a&&a<=48259||48261<=a&&a<=48287||48289<=a&&a<=48315||48317<=a&&a<=48343||48345<=a&&a<=48371||48373<=a&&a<=48399||48401<=a&&a<=48427||48429<=a&&a<=48455||48457<=a&&a<=48483||48485<=a&&a<=48511||48513<=a&&a<=48539||48541<=a&&a<=48567||48569<=a&&a<=48595||48597<=a&&a<=48623||48625<=a&&a<=48651||48653<=a&&a<=48679||48681<=a&&a<=48707||48709<=a&&a<=48735||48737<=a&&a<=48763||48765<=a&&a<=48791||48793<=a&&a<=48819||48821<=a&&a<=48847||48849<=a&&a<=48875||48877<=a&&a<=48903||48905<=a&&a<=48931||48933<=a&&a<=48959||48961<=a&&a<=48987||48989<=a&&a<=49015||49017<=a&&a<=49043||49045<=a&&a<=49071||49073<=a&&a<=49099||49101<=a&&a<=49127||49129<=a&&a<=49155||49157<=a&&a<=49183||49185<=a&&a<=49211||49213<=a&&a<=49239||49241<=a&&a<=49267||49269<=a&&a<=49295||49297<=a&&a<=49323||49325<=a&&a<=49351||49353<=a&&a<=49379||49381<=a&&a<=49407||49409<=a&&a<=49435||49437<=a&&a<=49463||49465<=a&&a<=49491||49493<=a&&a<=49519||49521<=a&&a<=49547||49549<=a&&a<=49575||49577<=a&&a<=49603||49605<=a&&a<=49631||49633<=a&&a<=49659||49661<=a&&a<=49687||49689<=a&&a<=49715||49717<=a&&a<=49743||49745<=a&&a<=49771||49773<=a&&a<=49799||49801<=a&&a<=49827||49829<=a&&a<=49855||49857<=a&&a<=49883||49885<=a&&a<=49911||49913<=a&&a<=49939||49941<=a&&a<=49967||49969<=a&&a<=49995||49997<=a&&a<=50023||50025<=a&&a<=50051||50053<=a&&a<=50079||50081<=a&&a<=50107||50109<=a&&a<=50135||50137<=a&&a<=50163||50165<=a&&a<=50191||50193<=a&&a<=50219||50221<=a&&a<=50247||50249<=a&&a<=50275||50277<=a&&a<=50303||50305<=a&&a<=50331||50333<=a&&a<=50359||50361<=a&&a<=50387||50389<=a&&a<=50415||50417<=a&&a<=50443||50445<=a&&a<=50471||50473<=a&&a<=50499||50501<=a&&a<=50527||50529<=a&&a<=50555||50557<=a&&a<=50583||50585<=a&&a<=50611||50613<=a&&a<=50639||50641<=a&&a<=50667||50669<=a&&a<=50695||50697<=a&&a<=50723||50725<=a&&a<=50751||50753<=a&&a<=50779||50781<=a&&a<=50807||50809<=a&&a<=50835||50837<=a&&a<=50863||50865<=a&&a<=50891||50893<=a&&a<=50919||50921<=a&&a<=50947||50949<=a&&a<=50975||50977<=a&&a<=51003||51005<=a&&a<=51031||51033<=a&&a<=51059||51061<=a&&a<=51087||51089<=a&&a<=51115||51117<=a&&a<=51143||51145<=a&&a<=51171||51173<=a&&a<=51199||51201<=a&&a<=51227||51229<=a&&a<=51255||51257<=a&&a<=51283||51285<=a&&a<=51311||51313<=a&&a<=51339||51341<=a&&a<=51367||51369<=a&&a<=51395||51397<=a&&a<=51423||51425<=a&&a<=51451||51453<=a&&a<=51479||51481<=a&&a<=51507||51509<=a&&a<=51535||51537<=a&&a<=51563||51565<=a&&a<=51591||51593<=a&&a<=51619||51621<=a&&a<=51647||51649<=a&&a<=51675||51677<=a&&a<=51703||51705<=a&&a<=51731||51733<=a&&a<=51759||51761<=a&&a<=51787||51789<=a&&a<=51815||51817<=a&&a<=51843||51845<=a&&a<=51871||51873<=a&&a<=51899||51901<=a&&a<=51927||51929<=a&&a<=51955||51957<=a&&a<=51983||51985<=a&&a<=52011||52013<=a&&a<=52039||52041<=a&&a<=52067||52069<=a&&a<=52095||52097<=a&&a<=52123||52125<=a&&a<=52151||52153<=a&&a<=52179||52181<=a&&a<=52207||52209<=a&&a<=52235||52237<=a&&a<=52263||52265<=a&&a<=52291||52293<=a&&a<=52319||52321<=a&&a<=52347||52349<=a&&a<=52375||52377<=a&&a<=52403||52405<=a&&a<=52431||52433<=a&&a<=52459||52461<=a&&a<=52487||52489<=a&&a<=52515||52517<=a&&a<=52543||52545<=a&&a<=52571||52573<=a&&a<=52599||52601<=a&&a<=52627||52629<=a&&a<=52655||52657<=a&&a<=52683||52685<=a&&a<=52711||52713<=a&&a<=52739||52741<=a&&a<=52767||52769<=a&&a<=52795||52797<=a&&a<=52823||52825<=a&&a<=52851||52853<=a&&a<=52879||52881<=a&&a<=52907||52909<=a&&a<=52935||52937<=a&&a<=52963||52965<=a&&a<=52991||52993<=a&&a<=53019||53021<=a&&a<=53047||53049<=a&&a<=53075||53077<=a&&a<=53103||53105<=a&&a<=53131||53133<=a&&a<=53159||53161<=a&&a<=53187||53189<=a&&a<=53215||53217<=a&&a<=53243||53245<=a&&a<=53271||53273<=a&&a<=53299||53301<=a&&a<=53327||53329<=a&&a<=53355||53357<=a&&a<=53383||53385<=a&&a<=53411||53413<=a&&a<=53439||53441<=a&&a<=53467||53469<=a&&a<=53495||53497<=a&&a<=53523||53525<=a&&a<=53551||53553<=a&&a<=53579||53581<=a&&a<=53607||53609<=a&&a<=53635||53637<=a&&a<=53663||53665<=a&&a<=53691||53693<=a&&a<=53719||53721<=a&&a<=53747||53749<=a&&a<=53775||53777<=a&&a<=53803||53805<=a&&a<=53831||53833<=a&&a<=53859||53861<=a&&a<=53887||53889<=a&&a<=53915||53917<=a&&a<=53943||53945<=a&&a<=53971||53973<=a&&a<=53999||54001<=a&&a<=54027||54029<=a&&a<=54055||54057<=a&&a<=54083||54085<=a&&a<=54111||54113<=a&&a<=54139||54141<=a&&a<=54167||54169<=a&&a<=54195||54197<=a&&a<=54223||54225<=a&&a<=54251||54253<=a&&a<=54279||54281<=a&&a<=54307||54309<=a&&a<=54335||54337<=a&&a<=54363||54365<=a&&a<=54391||54393<=a&&a<=54419||54421<=a&&a<=54447||54449<=a&&a<=54475||54477<=a&&a<=54503||54505<=a&&a<=54531||54533<=a&&a<=54559||54561<=a&&a<=54587||54589<=a&&a<=54615||54617<=a&&a<=54643||54645<=a&&a<=54671||54673<=a&&a<=54699||54701<=a&&a<=54727||54729<=a&&a<=54755||54757<=a&&a<=54783||54785<=a&&a<=54811||54813<=a&&a<=54839||54841<=a&&a<=54867||54869<=a&&a<=54895||54897<=a&&a<=54923||54925<=a&&a<=54951||54953<=a&&a<=54979||54981<=a&&a<=55007||55009<=a&&a<=55035||55037<=a&&a<=55063||55065<=a&&a<=55091||55093<=a&&a<=55119||55121<=a&&a<=55147||55149<=a&&a<=55175||55177<=a&&a<=55203?10:9757==a||9977==a||9994<=a&&a<=9997||127877==a||127938<=a&&a<=127940||127943==a||127946<=a&&a<=127948||128066<=a&&a<=128067||128070<=a&&a<=128080||128110==a||128112<=a&&a<=128120||128124==a||128129<=a&&a<=128131||128133<=a&&a<=128135||128170==a||128372<=a&&a<=128373||128378==a||128400==a||128405<=a&&a<=128406||128581<=a&&a<=128583||128587<=a&&a<=128591||128675==a||128692<=a&&a<=128694||128704==a||128716==a||129304<=a&&a<=129308||129310<=a&&a<=129311||129318==a||129328<=a&&a<=129337||129341<=a&&a<=129342||129489<=a&&a<=129501?i:127995<=a&&a<=127999?14:8205==a?15:9792==a||9794==a||9877<=a&&a<=9878||9992==a||10084==a||127752==a||127806==a||127859==a||127891==a||127908==a||127912==a||127979==a||127981==a||128139==a||128187<=a&&a<=128188||128295==a||128300==a||128488==a||128640==a||128658==a?o:128102<=a&&a<=128105?r:11}return this.nextBreak=function(e,t){if(void 0===t&&(t=0),t<0)return 0;if(t>=e.length-1)return e.length;for(var n=l(s(e,t)),i=[],o=t+1;o<e.length;o++)if(!a(e,o-1)){var r=l(s(e,o));if(c(n,i,r))return o;i.push(r)}return e.length},this.splitGraphemes=function(e){for(var t,n=[],i=0;(t=this.nextBreak(e,i))<e.length;)n.push(e.slice(i,t)),i=t;return i<e.length&&n.push(e.slice(i)),n},this.iterateGraphemes=function(e){var t=0,n={next:function(){var n,i;return(i=this.nextBreak(e,t))<e.length?(n=e.slice(t,i),t=i,{value:n,done:!1}):t<e.length?(n=e.slice(t),t=e.length,{value:n,done:!1}):{value:void 0,done:!0}}.bind(this)};return"undefined"!=typeof Symbol&&Symbol.iterator&&(n[Symbol.iterator]=function(){return n}),n},this.countGraphemes=function(e){for(var t,n=0,i=0;(t=this.nextBreak(e,i))<e.length;)i=t,n++;return i<e.length&&n++,n},this})},564886:(e,t,n)=>{"use strict";n.d(t,{A:()=>E});var i=n(660662),o=n(303578),r=n(434067),a=n(267980),s=n(336946),c=n(369031),l=n(491446),h=n(605971),u=n(610750),d=n(182348),p=n(697422),m=n(744603);const f=new a.A,A=new a.A,_=new s.A,g=new a.A,y=new a.A,v=new i.A,b=new d.A,w=[new s.A,new s.A,new s.A,new s.A],T=new r.A,x={};function C(e){s.A.fromRadians(e.east,e.north,0,w[0]),s.A.fromRadians(e.west,e.north,0,w[1]),s.A.fromRadians(e.east,e.south,0,w[2]),s.A.fromRadians(e.west,e.south,0,w[3]);let t=0,n=0,i=0,o=0;const r=x._terrainHeightsMaxLevel;let a;for(a=0;a<=r;++a){let e=!1;for(let t=0;t<4;++t){const n=w[t];if(b.positionToTileXY(n,a,T),0===t)i=T.x,o=T.y;else if(i!==T.x||o!==T.y){e=!0;break}}if(e)break;t=i,n=o}if(0!==a)return{x:t,y:n,level:a>r?r:a-1}}x.initialize=function(){let e=x._initPromise;return(0,l.A)(e)||(e=m.A.fetchJson((0,o.A)("Assets/approximateTerrainHeights.json")).then(function(e){x._terrainHeights=e}),x._initPromise=e),e},x.getMinimumMaximumHeights=function(e,t){if(c.A.defined("rectangle",e),!(0,l.A)(x._terrainHeights))throw new h.A("You must call ApproximateTerrainHeights.initialize and wait for the promise to resolve before using this function");t=t??u.A.default;const n=C(e);let i=x._defaultMinTerrainHeight,o=x._defaultMaxTerrainHeight;if((0,l.A)(n)){const r=`${n.level}-${n.x}-${n.y}`,s=x._terrainHeights[r];(0,l.A)(s)&&(i=s[0],o=s[1]),t.cartographicToCartesian(p.A.northeast(e,_),f),t.cartographicToCartesian(p.A.southwest(e,_),A),a.A.midpoint(A,f,g);const c=t.scaleToGeodeticSurface(g,y);if((0,l.A)(c)){const e=a.A.distance(g,c);i=Math.min(i,-e)}else i=x._defaultMinTerrainHeight}return i=Math.max(x._defaultMinTerrainHeight,i),{minimumTerrainHeight:i,maximumTerrainHeight:o}},x.getBoundingSphere=function(e,t){if(c.A.defined("rectangle",e),!(0,l.A)(x._terrainHeights))throw new h.A("You must call ApproximateTerrainHeights.initialize and wait for the promise to resolve before using this function");t=t??u.A.default;const n=C(e);let o=x._defaultMaxTerrainHeight;if((0,l.A)(n)){const e=`${n.level}-${n.x}-${n.y}`,t=x._terrainHeights[e];(0,l.A)(t)&&(o=t[1])}const r=i.A.fromRectangle3D(e,t,0);return i.A.fromRectangle3D(e,t,o,v),i.A.union(r,v,r)},x._terrainHeightsMaxLevel=6,x._defaultMaxTerrainHeight=9e3,x._defaultMinTerrainHeight=-1e5,x._terrainHeights=void 0,x._initPromise=void 0,Object.defineProperties(x,{initialized:{get:function(){return(0,l.A)(x._terrainHeights)}}});const E=x},215327:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i=Object.freeze({NONE:0,GEODESIC:1,RHUMB:2})},961645:(e,t,n)=>{"use strict";n.d(t,{A:()=>g});var i=n(434067),o=n(267980),r=n(571804),a=n(369031),s=n(491446),c=n(605971),l=n(367817),h=n(730839);const u=1/256,d={octEncodeInRange:function(e,t,n){a.A.defined("vector",e),a.A.defined("result",n);const i=o.A.magnitudeSquared(e);if(Math.abs(i-1)>l.A.EPSILON6)throw new c.A("vector must be normalized.");if(n.x=e.x/(Math.abs(e.x)+Math.abs(e.y)+Math.abs(e.z)),n.y=e.y/(Math.abs(e.x)+Math.abs(e.y)+Math.abs(e.z)),e.z<0){const e=n.x,t=n.y;n.x=(1-Math.abs(t))*l.A.signNotZero(e),n.y=(1-Math.abs(e))*l.A.signNotZero(t)}return n.x=l.A.toSNorm(n.x,t),n.y=l.A.toSNorm(n.y,t),n},octEncode:function(e,t){return d.octEncodeInRange(e,255,t)}},p=new i.A,m=new Uint8Array(1);function f(e){return m[0]=e,m[0]}d.octEncodeToCartesian4=function(e,t){return d.octEncodeInRange(e,65535,p),t.x=f(p.x*u),t.y=f(p.x),t.z=f(p.y*u),t.w=f(p.y),t},d.octDecodeInRange=function(e,t,n,i){if(a.A.defined("result",i),e<0||e>n||t<0||t>n)throw new c.A(`x and y must be unsigned normalized integers between 0 and ${n}`);if(i.x=l.A.fromSNorm(e,n),i.y=l.A.fromSNorm(t,n),i.z=1-(Math.abs(i.x)+Math.abs(i.y)),i.z<0){const e=i.x;i.x=(1-Math.abs(i.y))*l.A.signNotZero(e),i.y=(1-Math.abs(e))*l.A.signNotZero(i.y)}return o.A.normalize(i,i)},d.octDecode=function(e,t,n){return d.octDecodeInRange(e,t,255,n)},d.octDecodeFromCartesian4=function(e,t){a.A.typeOf.object("encoded",e),a.A.typeOf.object("result",t);const n=e.x,i=e.y,o=e.z,r=e.w;if(n<0||n>255||i<0||i>255||o<0||o>255||r<0||r>255)throw new c.A("x, y, z, and w must be unsigned normalized integers between 0 and 255");const s=256*n+i,l=256*o+r;return d.octDecodeInRange(s,l,65535,t)},d.octPackFloat=function(e){return a.A.defined("encoded",e),256*e.x+e.y};const A=new i.A;function _(e){return e>>1^-(1&e)}d.octEncodeFloat=function(e){return d.octEncode(e,A),d.octPackFloat(A)},d.octDecodeFloat=function(e,t){a.A.defined("value",e);const n=e/256,i=Math.floor(n),o=256*(n-i);return d.octDecode(i,o,t)},d.octPack=function(e,t,n,i){a.A.defined("v1",e),a.A.defined("v2",t),a.A.defined("v3",n),a.A.defined("result",i);const o=d.octEncodeFloat(e),r=d.octEncodeFloat(t),s=d.octEncode(n,A);return i.x=65536*s.x+o,i.y=65536*s.y+r,i},d.octUnpack=function(e,t,n,i){a.A.defined("packed",e),a.A.defined("v1",t),a.A.defined("v2",n),a.A.defined("v3",i);let o=e.x/65536;const r=Math.floor(o),s=65536*(o-r);o=e.y/65536;const c=Math.floor(o),l=65536*(o-c);d.octDecodeFloat(s,t),d.octDecodeFloat(l,n),d.octDecode(r,c,i)},d.compressTextureCoordinates=function(e){return a.A.defined("textureCoordinates",e),4096*(4095*e.x|0)+(4095*e.y|0)},d.decompressTextureCoordinates=function(e,t){a.A.defined("compressed",e),a.A.defined("result",t);const n=e/4096,i=Math.floor(n);return t.x=i/4095,t.y=(e-4096*i)/4095,t},d.zigZagDeltaDecode=function(e,t,n){a.A.defined("uBuffer",e),a.A.defined("vBuffer",t),a.A.typeOf.number.equals("uBuffer.length","vBuffer.length",e.length,t.length),(0,s.A)(n)&&a.A.typeOf.number.equals("uBuffer.length","heightBuffer.length",e.length,n.length);const i=e.length;let o=0,r=0,c=0;for(let a=0;a<i;++a)o+=_(e[a]),r+=_(t[a]),e[a]=o,t[a]=r,(0,s.A)(n)&&(c+=_(n[a]),n[a]=c)},d.dequantize=function(e,t,n,i){a.A.defined("typedArray",e),a.A.defined("componentDatatype",t),a.A.defined("type",n),a.A.defined("count",i);const o=h.A.getNumberOfComponents(n);let s;switch(t){case r.A.BYTE:s=127;break;case r.A.UNSIGNED_BYTE:s=255;break;case r.A.SHORT:s=32767;break;case r.A.UNSIGNED_SHORT:s=65535;break;case r.A.INT:s=2147483647;break;case r.A.UNSIGNED_INT:s=4294967295;break;default:throw new c.A(`Cannot dequantize component datatype: ${t}`)}const l=new Float32Array(i*o);for(let t=0;t<i;t++)for(let n=0;n<o;n++){const i=t*o+n;l[i]=Math.max(e[i]/s,-1)}return l},d.decodeRGB565=function(e,t){a.A.defined("typedArray",e);const n=3*e.length;(0,s.A)(t)&&a.A.typeOf.number.equals("result.length","typedArray.length * 3",t.length,n);const i=e.length;(0,s.A)(t)||(t=new Float32Array(3*i));const o=1/31,r=1/63;for(let n=0;n<i;n++){const i=e[n],a=i>>11,s=i>>5&63,c=31&i,l=3*n;t[l]=a*o,t[l+1]=s*r,t[l+2]=c*o}return t};const g=d},807135:(e,t,n)=>{"use strict";n.d(t,{A:()=>l});var i=n(267980),o=n(369031),r=n(491446),a=n(647326);function s(e,t,n){this.minimum=i.A.clone(e??i.A.ZERO),this.maximum=i.A.clone(t??i.A.ZERO),n=(0,r.A)(n)?i.A.clone(n):i.A.midpoint(this.minimum,this.maximum,new i.A),this.center=n}s.fromCorners=function(e,t,n){return o.A.defined("minimum",e),o.A.defined("maximum",t),(0,r.A)(n)||(n=new s),n.minimum=i.A.clone(e,n.minimum),n.maximum=i.A.clone(t,n.maximum),n.center=i.A.midpoint(e,t,n.center),n},s.fromPoints=function(e,t){if((0,r.A)(t)||(t=new s),!(0,r.A)(e)||0===e.length)return t.minimum=i.A.clone(i.A.ZERO,t.minimum),t.maximum=i.A.clone(i.A.ZERO,t.maximum),t.center=i.A.clone(i.A.ZERO,t.center),t;let n=e[0].x,o=e[0].y,a=e[0].z,c=e[0].x,l=e[0].y,h=e[0].z;const u=e.length;for(let t=1;t<u;t++){const i=e[t],r=i.x,s=i.y,u=i.z;n=Math.min(r,n),c=Math.max(r,c),o=Math.min(s,o),l=Math.max(s,l),a=Math.min(u,a),h=Math.max(u,h)}const d=t.minimum;d.x=n,d.y=o,d.z=a;const p=t.maximum;return p.x=c,p.y=l,p.z=h,t.center=i.A.midpoint(d,p,t.center),t},s.clone=function(e,t){if((0,r.A)(e))return(0,r.A)(t)?(t.minimum=i.A.clone(e.minimum,t.minimum),t.maximum=i.A.clone(e.maximum,t.maximum),t.center=i.A.clone(e.center,t.center),t):new s(e.minimum,e.maximum,e.center)},s.equals=function(e,t){return e===t||(0,r.A)(e)&&(0,r.A)(t)&&i.A.equals(e.center,t.center)&&i.A.equals(e.minimum,t.minimum)&&i.A.equals(e.maximum,t.maximum)};let c=new i.A;s.intersectPlane=function(e,t){o.A.defined("box",e),o.A.defined("plane",t),c=i.A.subtract(e.maximum,e.minimum,c);const n=i.A.multiplyByScalar(c,.5,c),r=t.normal,s=n.x*Math.abs(r.x)+n.y*Math.abs(r.y)+n.z*Math.abs(r.z),l=i.A.dot(e.center,r)+t.distance;return l-s>0?a.A.INSIDE:l+s<0?a.A.OUTSIDE:a.A.INTERSECTING},s.prototype.clone=function(e){return s.clone(this,e)},s.prototype.intersectPlane=function(e){return s.intersectPlane(this,e)},s.prototype.equals=function(e){return s.equals(this,e)};const l=s},647934:(e,t,n)=>{"use strict";n.d(t,{A:()=>f});var i=n(434067),o=n(336946),r=n(369031),a=n(491446),s=n(610750),c=n(653577),l=n(647326),h=n(697422);function u(e,t,n,i){this.x=e??0,this.y=t??0,this.width=n??0,this.height=i??0}u.packedLength=4,u.pack=function(e,t,n){return r.A.typeOf.object("value",e),r.A.defined("array",t),n=n??0,t[n++]=e.x,t[n++]=e.y,t[n++]=e.width,t[n]=e.height,t},u.unpack=function(e,t,n){return r.A.defined("array",e),t=t??0,(0,a.A)(n)||(n=new u),n.x=e[t++],n.y=e[t++],n.width=e[t++],n.height=e[t],n},u.fromPoints=function(e,t){if((0,a.A)(t)||(t=new u),!(0,a.A)(e)||0===e.length)return t.x=0,t.y=0,t.width=0,t.height=0,t;const n=e.length;let i=e[0].x,o=e[0].y,r=e[0].x,s=e[0].y;for(let t=1;t<n;t++){const n=e[t],a=n.x,c=n.y;i=Math.min(a,i),r=Math.max(a,r),o=Math.min(c,o),s=Math.max(c,s)}return t.x=i,t.y=o,t.width=r-i,t.height=s-o,t};const d=new c.A,p=new o.A,m=new o.A;u.fromRectangle=function(e,t,n){if((0,a.A)(n)||(n=new u),!(0,a.A)(e))return n.x=0,n.y=0,n.width=0,n.height=0,n;d._ellipsoid=s.A.default;const o=(t=t??d).project(h.A.southwest(e,p)),r=t.project(h.A.northeast(e,m));return i.A.subtract(r,o,r),n.x=o.x,n.y=o.y,n.width=r.x,n.height=r.y,n},u.clone=function(e,t){if((0,a.A)(e))return(0,a.A)(t)?(t.x=e.x,t.y=e.y,t.width=e.width,t.height=e.height,t):new u(e.x,e.y,e.width,e.height)},u.union=function(e,t,n){r.A.typeOf.object("left",e),r.A.typeOf.object("right",t),(0,a.A)(n)||(n=new u);const i=Math.min(e.x,t.x),o=Math.min(e.y,t.y),s=Math.max(e.x+e.width,t.x+t.width),c=Math.max(e.y+e.height,t.y+t.height);return n.x=i,n.y=o,n.width=s-i,n.height=c-o,n},u.expand=function(e,t,n){r.A.typeOf.object("rectangle",e),r.A.typeOf.object("point",t),n=u.clone(e,n);const i=t.x-n.x,o=t.y-n.y;return i>n.width?n.width=i:i<0&&(n.width-=i,n.x=t.x),o>n.height?n.height=o:o<0&&(n.height-=o,n.y=t.y),n},u.intersect=function(e,t){r.A.typeOf.object("left",e),r.A.typeOf.object("right",t);const n=e.x,i=e.y,o=t.x,a=t.y;return n>o+t.width||n+e.width<o||i+e.height<a||i>a+t.height?l.A.OUTSIDE:l.A.INTERSECTING},u.equals=function(e,t){return e===t||(0,a.A)(e)&&(0,a.A)(t)&&e.x===t.x&&e.y===t.y&&e.width===t.width&&e.height===t.height},u.prototype.clone=function(e){return u.clone(this,e)},u.prototype.intersect=function(e){return u.intersect(this,e)},u.prototype.equals=function(e){return u.equals(this,e)};const f=u},660662:(e,t,n)=>{"use strict";n.d(t,{A:()=>ee});var i=n(267980),o=n(336946),r=n(369031),a=n(491446),s=n(610750),c=n(653577),l=n(647326),h=n(33914),u=n(367817),d=n(331185),p=n(584164),m=n(697422);function f(e,t){this.center=i.A.clone(e??i.A.ZERO),this.radius=t??0}const A=new i.A,_=new i.A,g=new i.A,y=new i.A,v=new i.A,b=new i.A,w=new i.A,T=new i.A,x=new i.A,C=new i.A,E=new i.A,S=new i.A,D=4/3*u.A.PI;f.fromPoints=function(e,t){if((0,a.A)(t)||(t=new f),!(0,a.A)(e)||0===e.length)return t.center=i.A.clone(i.A.ZERO,t.center),t.radius=0,t;const n=i.A.clone(e[0],w),o=i.A.clone(n,A),r=i.A.clone(n,_),s=i.A.clone(n,g),c=i.A.clone(n,y),l=i.A.clone(n,v),h=i.A.clone(n,b),u=e.length;let d;for(d=1;d<u;d++){i.A.clone(e[d],n);const t=n.x,a=n.y,u=n.z;t<o.x&&i.A.clone(n,o),t>c.x&&i.A.clone(n,c),a<r.y&&i.A.clone(n,r),a>l.y&&i.A.clone(n,l),u<s.z&&i.A.clone(n,s),u>h.z&&i.A.clone(n,h)}const p=i.A.magnitudeSquared(i.A.subtract(c,o,T)),m=i.A.magnitudeSquared(i.A.subtract(l,r,T)),D=i.A.magnitudeSquared(i.A.subtract(h,s,T));let O=o,z=c,I=p;m>I&&(I=m,O=r,z=l),D>I&&(I=D,O=s,z=h);const P=x;P.x=.5*(O.x+z.x),P.y=.5*(O.y+z.y),P.z=.5*(O.z+z.z);let R=i.A.magnitudeSquared(i.A.subtract(z,P,T)),N=Math.sqrt(R);const L=C;L.x=o.x,L.y=r.y,L.z=s.z;const M=E;M.x=c.x,M.y=l.y,M.z=h.z;const F=i.A.midpoint(L,M,S);let B=0;for(d=0;d<u;d++){i.A.clone(e[d],n);const t=i.A.magnitude(i.A.subtract(n,F,T));t>B&&(B=t);const o=i.A.magnitudeSquared(i.A.subtract(n,P,T));if(o>R){const e=Math.sqrt(o);N=.5*(N+e),R=N*N;const t=e-N;P.x=(N*P.x+t*n.x)/e,P.y=(N*P.y+t*n.y)/e,P.z=(N*P.z+t*n.z)/e}}return N<B?(i.A.clone(P,t.center),t.radius=N):(i.A.clone(F,t.center),t.radius=B),t};const O=new c.A,z=new i.A,I=new i.A,P=new o.A,R=new o.A;f.fromRectangle2D=function(e,t,n){return f.fromRectangleWithHeights2D(e,t,0,0,n)},f.fromRectangleWithHeights2D=function(e,t,n,o,r){if((0,a.A)(r)||(r=new f),!(0,a.A)(e))return r.center=i.A.clone(i.A.ZERO,r.center),r.radius=0,r;O._ellipsoid=s.A.default,t=t??O,m.A.southwest(e,P),P.height=n,m.A.northeast(e,R),R.height=o;const c=t.project(P,z),l=t.project(R,I),h=l.x-c.x,u=l.y-c.y,d=l.z-c.z;r.radius=.5*Math.sqrt(h*h+u*u+d*d);const p=r.center;return p.x=c.x+.5*h,p.y=c.y+.5*u,p.z=c.z+.5*d,r};const N=[];f.fromRectangle3D=function(e,t,n,o){if(t=t??s.A.default,n=n??0,(0,a.A)(o)||(o=new f),!(0,a.A)(e))return o.center=i.A.clone(i.A.ZERO,o.center),o.radius=0,o;const r=m.A.subsample(e,t,n,N);return f.fromPoints(r,o)},f.fromVertices=function(e,t,n,o){if((0,a.A)(o)||(o=new f),!(0,a.A)(e)||0===e.length)return o.center=i.A.clone(i.A.ZERO,o.center),o.radius=0,o;t=t??i.A.ZERO,n=n??3,r.A.typeOf.number.greaterThanOrEquals("stride",n,3);const s=w;s.x=e[0]+t.x,s.y=e[1]+t.y,s.z=e[2]+t.z;const c=i.A.clone(s,A),l=i.A.clone(s,_),h=i.A.clone(s,g),u=i.A.clone(s,y),d=i.A.clone(s,v),p=i.A.clone(s,b),m=e.length;let D;for(D=0;D<m;D+=n){const n=e[D]+t.x,o=e[D+1]+t.y,r=e[D+2]+t.z;s.x=n,s.y=o,s.z=r,n<c.x&&i.A.clone(s,c),n>u.x&&i.A.clone(s,u),o<l.y&&i.A.clone(s,l),o>d.y&&i.A.clone(s,d),r<h.z&&i.A.clone(s,h),r>p.z&&i.A.clone(s,p)}const O=i.A.magnitudeSquared(i.A.subtract(u,c,T)),z=i.A.magnitudeSquared(i.A.subtract(d,l,T)),I=i.A.magnitudeSquared(i.A.subtract(p,h,T));let P=c,R=u,N=O;z>N&&(N=z,P=l,R=d),I>N&&(N=I,P=h,R=p);const L=x;L.x=.5*(P.x+R.x),L.y=.5*(P.y+R.y),L.z=.5*(P.z+R.z);let M=i.A.magnitudeSquared(i.A.subtract(R,L,T)),F=Math.sqrt(M);const B=C;B.x=c.x,B.y=l.y,B.z=h.z;const k=E;k.x=u.x,k.y=d.y,k.z=p.z;const V=i.A.midpoint(B,k,S);let G=0;for(D=0;D<m;D+=n){s.x=e[D]+t.x,s.y=e[D+1]+t.y,s.z=e[D+2]+t.z;const n=i.A.magnitude(i.A.subtract(s,V,T));n>G&&(G=n);const o=i.A.magnitudeSquared(i.A.subtract(s,L,T));if(o>M){const e=Math.sqrt(o);F=.5*(F+e),M=F*F;const t=e-F;L.x=(F*L.x+t*s.x)/e,L.y=(F*L.y+t*s.y)/e,L.z=(F*L.z+t*s.z)/e}}return F<G?(i.A.clone(L,o.center),o.radius=F):(i.A.clone(V,o.center),o.radius=G),o},f.fromEncodedCartesianVertices=function(e,t,n){if((0,a.A)(n)||(n=new f),!(0,a.A)(e)||!(0,a.A)(t)||e.length!==t.length||0===e.length)return n.center=i.A.clone(i.A.ZERO,n.center),n.radius=0,n;const o=w;o.x=e[0]+t[0],o.y=e[1]+t[1],o.z=e[2]+t[2];const r=i.A.clone(o,A),s=i.A.clone(o,_),c=i.A.clone(o,g),l=i.A.clone(o,y),h=i.A.clone(o,v),u=i.A.clone(o,b),d=e.length;let p;for(p=0;p<d;p+=3){const n=e[p]+t[p],a=e[p+1]+t[p+1],d=e[p+2]+t[p+2];o.x=n,o.y=a,o.z=d,n<r.x&&i.A.clone(o,r),n>l.x&&i.A.clone(o,l),a<s.y&&i.A.clone(o,s),a>h.y&&i.A.clone(o,h),d<c.z&&i.A.clone(o,c),d>u.z&&i.A.clone(o,u)}const m=i.A.magnitudeSquared(i.A.subtract(l,r,T)),D=i.A.magnitudeSquared(i.A.subtract(h,s,T)),O=i.A.magnitudeSquared(i.A.subtract(u,c,T));let z=r,I=l,P=m;D>P&&(P=D,z=s,I=h),O>P&&(P=O,z=c,I=u);const R=x;R.x=.5*(z.x+I.x),R.y=.5*(z.y+I.y),R.z=.5*(z.z+I.z);let N=i.A.magnitudeSquared(i.A.subtract(I,R,T)),L=Math.sqrt(N);const M=C;M.x=r.x,M.y=s.y,M.z=c.z;const F=E;F.x=l.x,F.y=h.y,F.z=u.z;const B=i.A.midpoint(M,F,S);let k=0;for(p=0;p<d;p+=3){o.x=e[p]+t[p],o.y=e[p+1]+t[p+1],o.z=e[p+2]+t[p+2];const n=i.A.magnitude(i.A.subtract(o,B,T));n>k&&(k=n);const r=i.A.magnitudeSquared(i.A.subtract(o,R,T));if(r>N){const e=Math.sqrt(r);L=.5*(L+e),N=L*L;const t=e-L;R.x=(L*R.x+t*o.x)/e,R.y=(L*R.y+t*o.y)/e,R.z=(L*R.z+t*o.z)/e}}return L<k?(i.A.clone(R,n.center),n.radius=L):(i.A.clone(B,n.center),n.radius=k),n},f.fromCornerPoints=function(e,t,n){r.A.typeOf.object("corner",e),r.A.typeOf.object("oppositeCorner",t),(0,a.A)(n)||(n=new f);const o=i.A.midpoint(e,t,n.center);return n.radius=i.A.distance(o,t),n},f.fromEllipsoid=function(e,t){return r.A.typeOf.object("ellipsoid",e),(0,a.A)(t)||(t=new f),i.A.clone(i.A.ZERO,t.center),t.radius=e.maximumRadius,t};const L=new i.A;f.fromBoundingSpheres=function(e,t){if((0,a.A)(t)||(t=new f),!(0,a.A)(e)||0===e.length)return t.center=i.A.clone(i.A.ZERO,t.center),t.radius=0,t;const n=e.length;if(1===n)return f.clone(e[0],t);if(2===n)return f.union(e[0],e[1],t);const o=[];let r;for(r=0;r<n;r++)o.push(e[r].center);const s=(t=f.fromPoints(o,t)).center;let c=t.radius;for(r=0;r<n;r++){const t=e[r];c=Math.max(c,i.A.distance(s,t.center,L)+t.radius)}return t.radius=c,t};const M=new i.A,F=new i.A,B=new i.A;f.fromOrientedBoundingBox=function(e,t){r.A.defined("orientedBoundingBox",e),(0,a.A)(t)||(t=new f);const n=e.halfAxes,o=d.A.getColumn(n,0,M),s=d.A.getColumn(n,1,F),c=d.A.getColumn(n,2,B);return i.A.add(o,s,o),i.A.add(o,c,o),t.center=i.A.clone(e.center,t.center),t.radius=i.A.magnitude(o),t};const k=new i.A,V=new i.A;f.fromTransformation=function(e,t){r.A.typeOf.object("transformation",e),(0,a.A)(t)||(t=new f);const n=p.A.getTranslation(e,k),o=p.A.getScale(e,V),s=.5*i.A.magnitude(o);return t.center=i.A.clone(n,t.center),t.radius=s,t},f.clone=function(e,t){if((0,a.A)(e))return(0,a.A)(t)?(t.center=i.A.clone(e.center,t.center),t.radius=e.radius,t):new f(e.center,e.radius)},f.packedLength=4,f.pack=function(e,t,n){r.A.typeOf.object("value",e),r.A.defined("array",t),n=n??0;const i=e.center;return t[n++]=i.x,t[n++]=i.y,t[n++]=i.z,t[n]=e.radius,t},f.unpack=function(e,t,n){r.A.defined("array",e),t=t??0,(0,a.A)(n)||(n=new f);const i=n.center;return i.x=e[t++],i.y=e[t++],i.z=e[t++],n.radius=e[t],n};const G=new i.A,H=new i.A;f.union=function(e,t,n){r.A.typeOf.object("left",e),r.A.typeOf.object("right",t),(0,a.A)(n)||(n=new f);const o=e.center,s=e.radius,c=t.center,l=t.radius,h=i.A.subtract(c,o,G),u=i.A.magnitude(h);if(s>=u+l)return e.clone(n),n;if(l>=u+s)return t.clone(n),n;const d=.5*(s+u+l),p=i.A.multiplyByScalar(h,(-s+d)/u,H);return i.A.add(p,o,p),i.A.clone(p,n.center),n.radius=d,n};const U=new i.A;f.expand=function(e,t,n){r.A.typeOf.object("sphere",e),r.A.typeOf.object("point",t),n=f.clone(e,n);const o=i.A.magnitude(i.A.subtract(t,n.center,U));return o>n.radius&&(n.radius=o),n},f.intersectPlane=function(e,t){r.A.typeOf.object("sphere",e),r.A.typeOf.object("plane",t);const n=e.center,o=e.radius,a=t.normal,s=i.A.dot(a,n)+t.distance;return s<-o?l.A.OUTSIDE:s<o?l.A.INTERSECTING:l.A.INSIDE},f.transform=function(e,t,n){return r.A.typeOf.object("sphere",e),r.A.typeOf.object("transform",t),(0,a.A)(n)||(n=new f),n.center=p.A.multiplyByPoint(t,e.center,n.center),n.radius=p.A.getMaximumScale(t)*e.radius,n};const W=new i.A;f.distanceSquaredTo=function(e,t){r.A.typeOf.object("sphere",e),r.A.typeOf.object("cartesian",t);const n=i.A.subtract(e.center,t,W),o=i.A.magnitude(n)-e.radius;return o<=0?0:o*o},f.transformWithoutScale=function(e,t,n){return r.A.typeOf.object("sphere",e),r.A.typeOf.object("transform",t),(0,a.A)(n)||(n=new f),n.center=p.A.multiplyByPoint(t,e.center,n.center),n.radius=e.radius,n};const q=new i.A;f.computePlaneDistances=function(e,t,n,o){r.A.typeOf.object("sphere",e),r.A.typeOf.object("position",t),r.A.typeOf.object("direction",n),(0,a.A)(o)||(o=new h.A);const s=i.A.subtract(e.center,t,q),c=i.A.dot(n,s);return o.start=c-e.radius,o.stop=c+e.radius,o};const j=new i.A,Y=new i.A,X=new i.A,$=new i.A,Z=new i.A,K=new o.A,Q=new Array(8);for(let e=0;e<8;++e)Q[e]=new i.A;const J=new c.A;f.projectTo2D=function(e,t,n){r.A.typeOf.object("sphere",e),J._ellipsoid=s.A.default;const o=(t=t??J).ellipsoid;let a=e.center;const c=e.radius;let l;l=i.A.equals(a,i.A.ZERO)?i.A.clone(i.A.UNIT_X,j):o.geodeticSurfaceNormal(a,j);const h=i.A.cross(i.A.UNIT_Z,l,Y);i.A.normalize(h,h);const u=i.A.cross(l,h,X);i.A.normalize(u,u),i.A.multiplyByScalar(l,c,l),i.A.multiplyByScalar(u,c,u),i.A.multiplyByScalar(h,c,h);const d=i.A.negate(u,Z),p=i.A.negate(h,$),m=Q;let A=m[0];i.A.add(l,u,A),i.A.add(A,h,A),A=m[1],i.A.add(l,u,A),i.A.add(A,p,A),A=m[2],i.A.add(l,d,A),i.A.add(A,p,A),A=m[3],i.A.add(l,d,A),i.A.add(A,h,A),i.A.negate(l,l),A=m[4],i.A.add(l,u,A),i.A.add(A,h,A),A=m[5],i.A.add(l,u,A),i.A.add(A,p,A),A=m[6],i.A.add(l,d,A),i.A.add(A,p,A),A=m[7],i.A.add(l,d,A),i.A.add(A,h,A);const _=m.length;for(let e=0;e<_;++e){const n=m[e];i.A.add(a,n,n);const r=o.cartesianToCartographic(n,K);t.project(r,n)}a=(n=f.fromPoints(m,n)).center;const g=a.x,y=a.y,v=a.z;return a.x=v,a.y=g,a.z=y,n},f.isOccluded=function(e,t){return r.A.typeOf.object("sphere",e),r.A.typeOf.object("occluder",t),!t.isBoundingSphereVisible(e)},f.equals=function(e,t){return e===t||(0,a.A)(e)&&(0,a.A)(t)&&i.A.equals(e.center,t.center)&&e.radius===t.radius},f.prototype.intersectPlane=function(e){return f.intersectPlane(this,e)},f.prototype.distanceSquaredTo=function(e){return f.distanceSquaredTo(this,e)},f.prototype.computePlaneDistances=function(e,t,n){return f.computePlaneDistances(this,e,t,n)},f.prototype.isOccluded=function(e){return f.isOccluded(this,e)},f.prototype.equals=function(e){return f.equals(this,e)},f.prototype.clone=function(e){return f.clone(this,e)},f.prototype.volume=function(){const e=this.radius;return D*e*e*e};const ee=f},554630:(e,t,n)=>{"use strict";n.d(t,{A:()=>T});var i=n(660662),o=n(267980),r=n(369031),a=n(571804),s=n(915325),c=n(491446),l=n(605971),h=n(944479),u=n(305439),d=n(46362),p=n(794554),m=n(402330),f=n(769534);const A=new o.A;function _(e){const t=(e=e??s.A.EMPTY_OBJECT).minimum,n=e.maximum;if(r.A.typeOf.object("min",t),r.A.typeOf.object("max",n),(0,c.A)(e.offsetAttribute)&&e.offsetAttribute===p.A.TOP)throw new l.A("GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.");const i=e.vertexFormat??f.A.DEFAULT;this._minimum=o.A.clone(t),this._maximum=o.A.clone(n),this._vertexFormat=i,this._offsetAttribute=e.offsetAttribute,this._workerName="createBoxGeometry"}_.fromDimensions=function(e){const t=(e=e??s.A.EMPTY_OBJECT).dimensions;r.A.typeOf.object("dimensions",t),r.A.typeOf.number.greaterThanOrEquals("dimensions.x",t.x,0),r.A.typeOf.number.greaterThanOrEquals("dimensions.y",t.y,0),r.A.typeOf.number.greaterThanOrEquals("dimensions.z",t.z,0);const n=o.A.multiplyByScalar(t,.5,new o.A);return new _({minimum:o.A.negate(n,new o.A),maximum:n,vertexFormat:e.vertexFormat,offsetAttribute:e.offsetAttribute})},_.fromAxisAlignedBoundingBox=function(e){return r.A.typeOf.object("boundingBox",e),new _({minimum:e.minimum,maximum:e.maximum})},_.packedLength=2*o.A.packedLength+f.A.packedLength+1,_.pack=function(e,t,n){return r.A.typeOf.object("value",e),r.A.defined("array",t),n=n??0,o.A.pack(e._minimum,t,n),o.A.pack(e._maximum,t,n+o.A.packedLength),f.A.pack(e._vertexFormat,t,n+2*o.A.packedLength),t[n+2*o.A.packedLength+f.A.packedLength]=e._offsetAttribute??-1,t};const g=new o.A,y=new o.A,v=new f.A,b={minimum:g,maximum:y,vertexFormat:v,offsetAttribute:void 0};let w;_.unpack=function(e,t,n){r.A.defined("array",e),t=t??0;const i=o.A.unpack(e,t,g),a=o.A.unpack(e,t+o.A.packedLength,y),s=f.A.unpack(e,t+2*o.A.packedLength,v),l=e[t+2*o.A.packedLength+f.A.packedLength];return(0,c.A)(n)?(n._minimum=o.A.clone(i,n._minimum),n._maximum=o.A.clone(a,n._maximum),n._vertexFormat=f.A.clone(s,n._vertexFormat),n._offsetAttribute=-1===l?void 0:l,n):(b.offsetAttribute=-1===l?void 0:l,new _(b))},_.createGeometry=function(e){const t=e._minimum,n=e._maximum,r=e._vertexFormat;if(o.A.equals(t,n))return;const s=new d.A;let l,f;if(r.position&&(r.st||r.normal||r.tangent||r.bitangent)){if(r.position&&(f=new Float64Array(72),f[0]=t.x,f[1]=t.y,f[2]=n.z,f[3]=n.x,f[4]=t.y,f[5]=n.z,f[6]=n.x,f[7]=n.y,f[8]=n.z,f[9]=t.x,f[10]=n.y,f[11]=n.z,f[12]=t.x,f[13]=t.y,f[14]=t.z,f[15]=n.x,f[16]=t.y,f[17]=t.z,f[18]=n.x,f[19]=n.y,f[20]=t.z,f[21]=t.x,f[22]=n.y,f[23]=t.z,f[24]=n.x,f[25]=t.y,f[26]=t.z,f[27]=n.x,f[28]=n.y,f[29]=t.z,f[30]=n.x,f[31]=n.y,f[32]=n.z,f[33]=n.x,f[34]=t.y,f[35]=n.z,f[36]=t.x,f[37]=t.y,f[38]=t.z,f[39]=t.x,f[40]=n.y,f[41]=t.z,f[42]=t.x,f[43]=n.y,f[44]=n.z,f[45]=t.x,f[46]=t.y,f[47]=n.z,f[48]=t.x,f[49]=n.y,f[50]=t.z,f[51]=n.x,f[52]=n.y,f[53]=t.z,f[54]=n.x,f[55]=n.y,f[56]=n.z,f[57]=t.x,f[58]=n.y,f[59]=n.z,f[60]=t.x,f[61]=t.y,f[62]=t.z,f[63]=n.x,f[64]=t.y,f[65]=t.z,f[66]=n.x,f[67]=t.y,f[68]=n.z,f[69]=t.x,f[70]=t.y,f[71]=n.z,s.position=new u.A({componentDatatype:a.A.DOUBLE,componentsPerAttribute:3,values:f})),r.normal){const e=new Float32Array(72);e[0]=0,e[1]=0,e[2]=1,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=1,e[9]=0,e[10]=0,e[11]=1,e[12]=0,e[13]=0,e[14]=-1,e[15]=0,e[16]=0,e[17]=-1,e[18]=0,e[19]=0,e[20]=-1,e[21]=0,e[22]=0,e[23]=-1,e[24]=1,e[25]=0,e[26]=0,e[27]=1,e[28]=0,e[29]=0,e[30]=1,e[31]=0,e[32]=0,e[33]=1,e[34]=0,e[35]=0,e[36]=-1,e[37]=0,e[38]=0,e[39]=-1,e[40]=0,e[41]=0,e[42]=-1,e[43]=0,e[44]=0,e[45]=-1,e[46]=0,e[47]=0,e[48]=0,e[49]=1,e[50]=0,e[51]=0,e[52]=1,e[53]=0,e[54]=0,e[55]=1,e[56]=0,e[57]=0,e[58]=1,e[59]=0,e[60]=0,e[61]=-1,e[62]=0,e[63]=0,e[64]=-1,e[65]=0,e[66]=0,e[67]=-1,e[68]=0,e[69]=0,e[70]=-1,e[71]=0,s.normal=new u.A({componentDatatype:a.A.FLOAT,componentsPerAttribute:3,values:e})}if(r.st){const e=new Float32Array(48);e[0]=0,e[1]=0,e[2]=1,e[3]=0,e[4]=1,e[5]=1,e[6]=0,e[7]=1,e[8]=1,e[9]=0,e[10]=0,e[11]=0,e[12]=0,e[13]=1,e[14]=1,e[15]=1,e[16]=0,e[17]=0,e[18]=1,e[19]=0,e[20]=1,e[21]=1,e[22]=0,e[23]=1,e[24]=1,e[25]=0,e[26]=0,e[27]=0,e[28]=0,e[29]=1,e[30]=1,e[31]=1,e[32]=1,e[33]=0,e[34]=0,e[35]=0,e[36]=0,e[37]=1,e[38]=1,e[39]=1,e[40]=0,e[41]=0,e[42]=1,e[43]=0,e[44]=1,e[45]=1,e[46]=0,e[47]=1,s.st=new u.A({componentDatatype:a.A.FLOAT,componentsPerAttribute:2,values:e})}if(r.tangent){const e=new Float32Array(72);e[0]=1,e[1]=0,e[2]=0,e[3]=1,e[4]=0,e[5]=0,e[6]=1,e[7]=0,e[8]=0,e[9]=1,e[10]=0,e[11]=0,e[12]=-1,e[13]=0,e[14]=0,e[15]=-1,e[16]=0,e[17]=0,e[18]=-1,e[19]=0,e[20]=0,e[21]=-1,e[22]=0,e[23]=0,e[24]=0,e[25]=1,e[26]=0,e[27]=0,e[28]=1,e[29]=0,e[30]=0,e[31]=1,e[32]=0,e[33]=0,e[34]=1,e[35]=0,e[36]=0,e[37]=-1,e[38]=0,e[39]=0,e[40]=-1,e[41]=0,e[42]=0,e[43]=-1,e[44]=0,e[45]=0,e[46]=-1,e[47]=0,e[48]=-1,e[49]=0,e[50]=0,e[51]=-1,e[52]=0,e[53]=0,e[54]=-1,e[55]=0,e[56]=0,e[57]=-1,e[58]=0,e[59]=0,e[60]=1,e[61]=0,e[62]=0,e[63]=1,e[64]=0,e[65]=0,e[66]=1,e[67]=0,e[68]=0,e[69]=1,e[70]=0,e[71]=0,s.tangent=new u.A({componentDatatype:a.A.FLOAT,componentsPerAttribute:3,values:e})}if(r.bitangent){const e=new Float32Array(72);e[0]=0,e[1]=1,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=1,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=1,e[14]=0,e[15]=0,e[16]=1,e[17]=0,e[18]=0,e[19]=1,e[20]=0,e[21]=0,e[22]=1,e[23]=0,e[24]=0,e[25]=0,e[26]=1,e[27]=0,e[28]=0,e[29]=1,e[30]=0,e[31]=0,e[32]=1,e[33]=0,e[34]=0,e[35]=1,e[36]=0,e[37]=0,e[38]=1,e[39]=0,e[40]=0,e[41]=1,e[42]=0,e[43]=0,e[44]=1,e[45]=0,e[46]=0,e[47]=1,e[48]=0,e[49]=0,e[50]=1,e[51]=0,e[52]=0,e[53]=1,e[54]=0,e[55]=0,e[56]=1,e[57]=0,e[58]=0,e[59]=1,e[60]=0,e[61]=0,e[62]=1,e[63]=0,e[64]=0,e[65]=1,e[66]=0,e[67]=0,e[68]=1,e[69]=0,e[70]=0,e[71]=1,s.bitangent=new u.A({componentDatatype:a.A.FLOAT,componentsPerAttribute:3,values:e})}l=new Uint16Array(36),l[0]=0,l[1]=1,l[2]=2,l[3]=0,l[4]=2,l[5]=3,l[6]=6,l[7]=5,l[8]=4,l[9]=7,l[10]=6,l[11]=4,l[12]=8,l[13]=9,l[14]=10,l[15]=8,l[16]=10,l[17]=11,l[18]=14,l[19]=13,l[20]=12,l[21]=15,l[22]=14,l[23]=12,l[24]=18,l[25]=17,l[26]=16,l[27]=19,l[28]=18,l[29]=16,l[30]=20,l[31]=21,l[32]=22,l[33]=20,l[34]=22,l[35]=23}else f=new Float64Array(24),f[0]=t.x,f[1]=t.y,f[2]=t.z,f[3]=n.x,f[4]=t.y,f[5]=t.z,f[6]=n.x,f[7]=n.y,f[8]=t.z,f[9]=t.x,f[10]=n.y,f[11]=t.z,f[12]=t.x,f[13]=t.y,f[14]=n.z,f[15]=n.x,f[16]=t.y,f[17]=n.z,f[18]=n.x,f[19]=n.y,f[20]=n.z,f[21]=t.x,f[22]=n.y,f[23]=n.z,s.position=new u.A({componentDatatype:a.A.DOUBLE,componentsPerAttribute:3,values:f}),l=new Uint16Array(36),l[0]=4,l[1]=5,l[2]=6,l[3]=4,l[4]=6,l[5]=7,l[6]=1,l[7]=0,l[8]=3,l[9]=1,l[10]=3,l[11]=2,l[12]=1,l[13]=6,l[14]=5,l[15]=1,l[16]=2,l[17]=6,l[18]=2,l[19]=3,l[20]=7,l[21]=2,l[22]=7,l[23]=6,l[24]=3,l[25]=0,l[26]=4,l[27]=3,l[28]=4,l[29]=7,l[30]=0,l[31]=1,l[32]=5,l[33]=0,l[34]=5,l[35]=4;const _=o.A.subtract(n,t,A),g=.5*o.A.magnitude(_);if((0,c.A)(e._offsetAttribute)){const t=f.length,n=e._offsetAttribute===p.A.NONE?0:1,i=new Uint8Array(t/3).fill(n);s.applyOffset=new u.A({componentDatatype:a.A.UNSIGNED_BYTE,componentsPerAttribute:1,values:i})}return new h.A({attributes:s,indices:l,primitiveType:m.A.TRIANGLES,boundingSphere:new i.A(o.A.ZERO,g),offsetAttribute:e._offsetAttribute})},_.getUnitBox=function(){return(0,c.A)(w)||(w=_.createGeometry(_.fromDimensions({dimensions:new o.A(1,1,1),vertexFormat:f.A.POSITION_ONLY}))),w};const T=_},56233:(e,t,n)=>{"use strict";n.d(t,{A:()=>r});var i=n(491446);function o(e,t,n,i,o){this._format=e,this._datatype=t,this._width=n,this._height=i,this._buffer=o}Object.defineProperties(o.prototype,{internalFormat:{get:function(){return this._format}},pixelDatatype:{get:function(){return this._datatype}},width:{get:function(){return this._width}},height:{get:function(){return this._height}},bufferView:{get:function(){return this._buffer}},arrayBufferView:{get:function(){return this._buffer}}}),o.clone=function(e){if((0,i.A)(e))return new o(e._format,e._datatype,e._width,e._height,e._buffer)},o.prototype.clone=function(){return o.clone(this)};const r=o},703983:(e,t,n)=>{"use strict";n.d(t,{A:()=>s});var i=n(605971),o=n(118135);const r={};function a(e,t,n,i){const o=e,r=t/3,a=n/3,s=i,c=o*a,l=r*s,h=r*r,u=a*a,d=o*a-h,p=o*s-r*a,m=r*s-u,f=4*d*m-p*p;let A,_;if(f<0){let e,t,n;h*l>=c*u?(e=o,t=d,n=-2*r*d+o*p):(e=s,t=m,n=-s*p+2*a*m);const i=-(n<0?-1:1)*Math.abs(e)*Math.sqrt(-f);_=-n+i;const g=_/2,y=g<0?-Math.pow(-g,1/3):Math.pow(g,1/3),v=_===i?-y:-t/y;return A=t<=0?y+v:-n/(y*y+v*v+t),h*l>=c*u?[(A-r)/o]:[-s/(A+a)]}const g=d,y=-2*r*d+o*p,v=m,b=-s*p+2*a*m,w=Math.sqrt(f),T=Math.sqrt(3)/2;let x=Math.abs(Math.atan2(o*w,-y)/3);A=2*Math.sqrt(-g);let C=Math.cos(x);_=A*C;let E=A*(-C/2-T*Math.sin(x));const S=_+E>2*r?_-r:E-r,D=o,O=S/D;x=Math.abs(Math.atan2(s*w,-b)/3),A=2*Math.sqrt(-v),C=Math.cos(x),_=A*C,E=A*(-C/2-T*Math.sin(x));const z=-s,I=_+E<2*a?_+a:E+a,P=z/I,R=-S*I-D*z,N=(a*R-r*(S*z))/(-r*R+a*(D*I));return O<=N?O<=P?N<=P?[O,N,P]:[O,P,N]:[P,O,N]:O<=P?[N,O,P]:N<=P?[N,P,O]:[P,N,O]}r.computeDiscriminant=function(e,t,n,o){if("number"!=typeof e)throw new i.A("a is a required number.");if("number"!=typeof t)throw new i.A("b is a required number.");if("number"!=typeof n)throw new i.A("c is a required number.");if("number"!=typeof o)throw new i.A("d is a required number.");const r=t*t,a=n*n;return 18*e*t*n*o+r*a-e*e*27*(o*o)-4*(e*a*n+r*t*o)},r.computeRealRoots=function(e,t,n,r){if("number"!=typeof e)throw new i.A("a is a required number.");if("number"!=typeof t)throw new i.A("b is a required number.");if("number"!=typeof n)throw new i.A("c is a required number.");if("number"!=typeof r)throw new i.A("d is a required number.");let s,c;if(0===e)return o.A.computeRealRoots(t,n,r);if(0===t){if(0===n){if(0===r)return[0,0,0];c=-r/e;const t=c<0?-Math.pow(-c,1/3):Math.pow(c,1/3);return[t,t,t]}return 0===r?(s=o.A.computeRealRoots(e,0,n),0===s.Length?[0]:[s[0],0,s[1]]):a(e,0,n,r)}return 0===n?0===r?(c=-t/e,c<0?[c,0,0]:[0,0,c]):a(e,t,0,r):0===r?(s=o.A.computeRealRoots(e,t,n),0===s.length?[0]:s[1]<=0?[s[0],s[1],0]:s[0]>=0?[0,s[0],s[1]]:[s[0],0,s[1]]):a(e,t,n,r)};const s=r},400793:(e,t,n)=>{"use strict";n.d(t,{A:()=>m});var i=n(267980),o=n(626809),r=n(491446),a=n(605971),s=n(647326),c=n(257941);function l(e){this.planes=e??[]}const h=[new i.A,new i.A,new i.A];i.A.clone(i.A.UNIT_X,h[0]),i.A.clone(i.A.UNIT_Y,h[1]),i.A.clone(i.A.UNIT_Z,h[2]);const u=new i.A,d=new i.A,p=new c.A(new i.A(1,0,0),0);l.fromBoundingSphere=function(e,t){if(!(0,r.A)(e))throw new a.A("boundingSphere is required.");(0,r.A)(t)||(t=new l);const n=h.length,s=t.planes;s.length=2*n;const c=e.center,p=e.radius;let m=0;for(let e=0;e<n;++e){const t=h[e];let n=s[m],a=s[m+1];(0,r.A)(n)||(n=s[m]=new o.A),(0,r.A)(a)||(a=s[m+1]=new o.A),i.A.multiplyByScalar(t,-p,u),i.A.add(c,u,u),n.x=t.x,n.y=t.y,n.z=t.z,n.w=-i.A.dot(t,u),i.A.multiplyByScalar(t,p,u),i.A.add(c,u,u),a.x=-t.x,a.y=-t.y,a.z=-t.z,a.w=-i.A.dot(i.A.negate(t,d),u),m+=2}return t},l.prototype.computeVisibility=function(e){if(!(0,r.A)(e))throw new a.A("boundingVolume is required.");const t=this.planes;let n=!1;for(let i=0,o=t.length;i<o;++i){const o=e.intersectPlane(c.A.fromCartesian4(t[i],p));if(o===s.A.OUTSIDE)return s.A.OUTSIDE;o===s.A.INTERSECTING&&(n=!0)}return n?s.A.INTERSECTING:s.A.INSIDE},l.prototype.computeVisibilityWithPlaneMask=function(e,t){if(!(0,r.A)(e))throw new a.A("boundingVolume is required.");if(!(0,r.A)(t))throw new a.A("parentPlaneMask is required.");if(t===l.MASK_OUTSIDE||t===l.MASK_INSIDE)return t;let n=l.MASK_INSIDE;const i=this.planes;for(let o=0,r=i.length;o<r;++o){const r=o<31?1<<o:0;if(o<31&&0===(t&r))continue;const a=e.intersectPlane(c.A.fromCartesian4(i[o],p));if(a===s.A.OUTSIDE)return l.MASK_OUTSIDE;a===s.A.INTERSECTING&&(n|=r)}return n},l.MASK_OUTSIDE=4294967295,l.MASK_INSIDE=0,l.MASK_INDETERMINATE=2147483647;const m=l},853331:(e,t,n)=>{"use strict";n.d(t,{A:()=>a});var i=n(491446),o=n(605971);function r(e,t){e=e??0,this._near=e,t=t??Number.MAX_VALUE,this._far=t}Object.defineProperties(r.prototype,{near:{get:function(){return this._near},set:function(e){this._near=e}},far:{get:function(){return this._far},set:function(e){this._far=e}}}),r.packedLength=2,r.pack=function(e,t,n){if(!(0,i.A)(e))throw new o.A("value is required");if(!(0,i.A)(t))throw new o.A("array is required");return n=n??0,t[n++]=e.near,t[n]=e.far,t},r.unpack=function(e,t,n){if(!(0,i.A)(e))throw new o.A("array is required");return t=t??0,(0,i.A)(n)||(n=new r),n.near=e[t++],n.far=e[t],n},r.equals=function(e,t){return e===t||(0,i.A)(e)&&(0,i.A)(t)&&e.near===t.near&&e.far===t.far},r.clone=function(e,t){if((0,i.A)(e))return(0,i.A)(t)||(t=new r),t.near=e.near,t.far=e.far,t},r.prototype.clone=function(e){return r.clone(this,e)},r.prototype.equals=function(e){return r.equals(this,e)};const a=r},602289:(e,t,n)=>{"use strict";n.d(t,{A:()=>m});var i=n(267980),o=n(336946),r=n(369031),a=n(491446),s=n(610750),c=n(367817);function l(e,t,n,i,o,r,a){const s=function(e,t){return e*t*(4+e*(4-3*t))/16}(e,n);return(1-s)*e*t*(i+s*o*(a+s*r*(2*a*a-1)))}const h=new i.A,u=new i.A;function d(e,t,n,a){const s=i.A.normalize(a.cartographicToCartesian(t,u),h),d=i.A.normalize(a.cartographicToCartesian(n,u),u);r.A.typeOf.number.greaterThanOrEquals("value",Math.abs(Math.abs(i.A.angleBetween(s,d))-Math.PI),.0125),function(e,t,n,i,o,r,a){const s=(t-n)/t,h=r-i,u=Math.atan((1-s)*Math.tan(o)),d=Math.atan((1-s)*Math.tan(a)),p=Math.cos(u),m=Math.sin(u),f=Math.cos(d),A=Math.sin(d),_=p*f,g=p*A,y=m*A,v=m*f;let b,w,T,x,C,E=h,S=c.A.TWO_PI,D=Math.cos(E),O=Math.sin(E);do{D=Math.cos(E),O=Math.sin(E);const e=g-v*D;let t;T=Math.sqrt(f*f*O*O+e*e),w=y+_*D,b=Math.atan2(T,w),0===T?(t=0,x=1):(t=_*O/T,x=1-t*t),S=E,C=w-2*y/x,isFinite(C)||(C=0),E=h+l(s,t,x,b,T,w,C)}while(Math.abs(E-S)>c.A.EPSILON12);const z=x*(t*t-n*n)/(n*n),I=z*(256+z*(z*(74-47*z)-128))/1024,P=C*C,R=n*(1+z*(4096+z*(z*(320-175*z)-768))/16384)*(b-I*T*(C+I*(w*(2*P-1)-I*C*(4*T*T-3)*(4*P-3)/6)/4)),N=Math.atan2(f*O,g-v*D),L=Math.atan2(p*O,g*D-v);e._distance=R,e._startHeading=N,e._endHeading=L,e._uSquared=z}(e,a.maximumRadius,a.minimumRadius,t.longitude,t.latitude,n.longitude,n.latitude),e._start=o.A.clone(t,e._start),e._end=o.A.clone(n,e._end),e._start.height=0,e._end.height=0,function(e){const t=e._uSquared,n=e._ellipsoid.maximumRadius,i=e._ellipsoid.minimumRadius,o=(n-i)/n,r=Math.cos(e._startHeading),a=Math.sin(e._startHeading),s=(1-o)*Math.tan(e._start.latitude),c=1/Math.sqrt(1+s*s),l=c*s,h=Math.atan2(s,r),u=c*a,d=u*u,p=1-d,m=Math.sqrt(p),f=t/4,A=f*f,_=A*f,g=A*A,y=1+f-3*A/4+5*_/4-175*g/64,v=1-f+15*A/8-35*_/8,b=1-3*f+35*A/4,w=1-5*f,T=y*h-v*Math.sin(2*h)*f/2-b*Math.sin(4*h)*A/16-w*Math.sin(6*h)*_/48-5*Math.sin(8*h)*g/512,x=e._constants;x.a=n,x.b=i,x.f=o,x.cosineHeading=r,x.sineHeading=a,x.tanU=s,x.cosineU=c,x.sineU=l,x.sigma=h,x.sineAlpha=u,x.sineSquaredAlpha=d,x.cosineSquaredAlpha=p,x.cosineAlpha=m,x.u2Over4=f,x.u4Over16=A,x.u6Over64=_,x.u8Over256=g,x.a0=y,x.a1=v,x.a2=b,x.a3=w,x.distanceRatio=T}(e)}function p(e,t,n){const i=n??s.A.default;this._ellipsoid=i,this._start=new o.A,this._end=new o.A,this._constants={},this._startHeading=void 0,this._endHeading=void 0,this._distance=void 0,this._uSquared=void 0,(0,a.A)(e)&&(0,a.A)(t)&&d(this,e,t,i)}Object.defineProperties(p.prototype,{ellipsoid:{get:function(){return this._ellipsoid}},surfaceDistance:{get:function(){return r.A.defined("distance",this._distance),this._distance}},start:{get:function(){return this._start}},end:{get:function(){return this._end}},startHeading:{get:function(){return r.A.defined("distance",this._distance),this._startHeading}},endHeading:{get:function(){return r.A.defined("distance",this._distance),this._endHeading}}}),p.prototype.setEndPoints=function(e,t){r.A.defined("start",e),r.A.defined("end",t),d(this,e,t,this._ellipsoid)},p.prototype.interpolateUsingFraction=function(e,t){return this.interpolateUsingSurfaceDistance(this._distance*e,t)},p.prototype.interpolateUsingSurfaceDistance=function(e,t){r.A.defined("distance",this._distance);const n=this._constants,i=n.distanceRatio+e/n.b,s=Math.cos(2*i),c=Math.cos(4*i),h=Math.cos(6*i),u=Math.sin(2*i),d=Math.sin(4*i),p=Math.sin(6*i),m=Math.sin(8*i),f=i*i,A=i*f,_=n.u8Over256,g=n.u2Over4,y=n.u6Over64,v=n.u4Over16;let b=2*A*_*s/3+i*(1-g+7*v/4-15*y/4+579*_/64-(v-15*y/4+187*_/16)*s-(5*y/4-115*_/16)*c-29*_*h/16)+(g/2-v+71*y/32-85*_/16)*u+(5*v/16-5*y/4+383*_/96)*d-f*((y-11*_/2)*u+5*_*d/2)+(29*y/96-29*_/16)*p+539*_*m/1536;const w=Math.asin(Math.sin(b)*n.cosineAlpha),T=Math.atan(n.a/n.b*Math.tan(w));b-=n.sigma;const x=Math.cos(2*n.sigma+b),C=Math.sin(b),E=Math.cos(b),S=n.cosineU*E,D=n.sineU*C,O=Math.atan2(C*n.sineHeading,S-D*n.cosineHeading)-l(n.f,n.sineAlpha,n.cosineSquaredAlpha,b,C,E,x);return(0,a.A)(t)?(t.longitude=this._start.longitude+O,t.latitude=T,t.height=0,t):new o.A(this._start.longitude+O,T,0)};const m=p},551824:(e,t,n)=>{"use strict";n.d(t,{A:()=>_});var i=n(267980),o=n(336946),r=n(369031),a=n(491446),s=n(605971),c=n(610750),l=n(367817);function h(e,t,n){if(0===e)return t*n;const i=e*e,o=i*i,r=o*i,a=r*i,s=a*i,c=s*i,l=n;return t*((1-i/4-3*o/64-5*r/256-175*a/16384-441*s/65536-4851*c/1048576)*l-(3*i/8+3*o/32+45*r/1024+105*a/4096+2205*s/131072+6237*c/524288)*Math.sin(2*l)+(15*o/256+45*r/1024+525*a/16384+1575*s/65536+155925*c/8388608)*Math.sin(4*l)-(35*r/3072+175*a/12288+3675*s/262144+13475*c/1048576)*Math.sin(6*l)+(315*a/131072+2205*s/524288+43659*c/8388608)*Math.sin(8*l)-(693*s/1310720+6237*c/5242880)*Math.sin(10*l)+1001*c/8388608*Math.sin(12*l))}function u(e,t){if(0===e)return Math.log(Math.tan(.5*(l.A.PI_OVER_TWO+t)));const n=e*Math.sin(t);return Math.log(Math.tan(.5*(l.A.PI_OVER_TWO+t)))-e/2*Math.log((1+n)/(1-n))}const d=new i.A,p=new i.A;function m(e,t,n,a){const s=i.A.normalize(a.cartographicToCartesian(t,p),d),c=i.A.normalize(a.cartographicToCartesian(n,p),p);r.A.typeOf.number.greaterThanOrEquals("value",Math.abs(Math.abs(i.A.angleBetween(s,c))-Math.PI),.0125);const m=a.maximumRadius,f=a.minimumRadius,A=m*m,_=f*f;e._ellipticitySquared=(A-_)/A,e._ellipticity=Math.sqrt(e._ellipticitySquared),e._start=o.A.clone(t,e._start),e._start.height=0,e._end=o.A.clone(n,e._end),e._end.height=0,e._heading=function(e,t,n,i,o){const r=u(e._ellipticity,n),a=u(e._ellipticity,o);return Math.atan2(l.A.negativePiToPi(i-t),a-r)}(e,t.longitude,t.latitude,n.longitude,n.latitude),e._distance=function(e,t,n,i,o,r,a){const s=e._heading,c=r-i;let u=0;if(l.A.equalsEpsilon(Math.abs(s),l.A.PI_OVER_TWO,l.A.EPSILON8))if(t===n)u=t*Math.cos(o)*l.A.negativePiToPi(c);else{const n=Math.sin(o);u=t*Math.cos(o)*l.A.negativePiToPi(c)/Math.sqrt(1-e._ellipticitySquared*n*n)}else{const n=h(e._ellipticity,t,o);u=(h(e._ellipticity,t,a)-n)/Math.cos(s)}return Math.abs(u)}(e,a.maximumRadius,a.minimumRadius,t.longitude,t.latitude,n.longitude,n.latitude)}function f(e,t,n,i,r,s){if(0===n)return o.A.clone(e,s);const c=r*r;let d,p,m;if(Math.abs(l.A.PI_OVER_TWO-Math.abs(t))>l.A.EPSILON8)if(p=function(e,t,n){const i=e/n;if(0===t)return i;const o=i*i,r=o*i,a=r*i,s=t*t,c=s*s,l=c*s,h=l*s,u=h*s,d=u*s,p=Math.sin(2*i),m=Math.cos(2*i),f=Math.sin(4*i),A=Math.cos(4*i),_=Math.sin(6*i),g=Math.cos(6*i),y=Math.sin(8*i),v=Math.cos(8*i),b=Math.sin(10*i);return i+i*s/4+7*i*c/64+15*i*l/256+579*i*h/16384+1515*i*u/65536+16837*i*d/1048576+(3*i*c/16+45*i*l/256-i*(32*o-561)*h/4096-i*(232*o-1677)*u/16384+i*(399985-90560*o+512*a)*d/5242880)*m+(21*i*l/256+483*i*h/4096-i*(224*o-1969)*u/16384-i*(33152*o-112599)*d/1048576)*A+(151*i*h/4096+4681*i*u/65536+1479*i*d/16384-453*r*d/32768)*g+(1097*i*u/65536+42783*i*d/1048576)*v+8011*i*d/1048576*Math.cos(10*i)+(3*s/8+3*c/16+213*l/2048-3*o*l/64+255*h/4096-33*o*h/512+20861*u/524288-33*o*u/512+a*u/1024+28273*d/1048576-471*o*d/8192+9*a*d/4096)*p+(21*c/256+21*l/256+533*h/8192-21*o*h/512+197*u/4096-315*o*u/4096+584039*d/16777216-12517*o*d/131072+7*a*d/2048)*f+(151*l/6144+151*h/4096+5019*u/131072-453*o*u/16384+26965*d/786432-8607*o*d/131072)*_+(1097*h/131072+1097*u/65536+225797*d/10485760-1097*o*d/65536)*y+(8011*u/2621440+8011*d/1048576)*b+293393*d/251658240*Math.sin(12*i)}(h(r,i,e.latitude)+n*Math.cos(t),r,i),Math.abs(t)<l.A.EPSILON10)d=l.A.negativePiToPi(e.longitude);else{const n=u(r,e.latitude),i=u(r,p);m=Math.tan(t)*(i-n),d=l.A.negativePiToPi(e.longitude+m)}else{let o;if(p=e.latitude,0===r)o=i*Math.cos(e.latitude);else{const t=Math.sin(e.latitude);o=i*Math.cos(e.latitude)/Math.sqrt(1-c*t*t)}m=n/o,d=t>0?l.A.negativePiToPi(e.longitude+m):l.A.negativePiToPi(e.longitude-m)}return(0,a.A)(s)?(s.longitude=d,s.latitude=p,s.height=0,s):new o.A(d,p,0)}function A(e,t,n){const i=n??c.A.default;this._ellipsoid=i,this._start=new o.A,this._end=new o.A,this._heading=void 0,this._distance=void 0,this._ellipticity=void 0,this._ellipticitySquared=void 0,(0,a.A)(e)&&(0,a.A)(t)&&m(this,e,t,i)}Object.defineProperties(A.prototype,{ellipsoid:{get:function(){return this._ellipsoid}},surfaceDistance:{get:function(){return r.A.defined("distance",this._distance),this._distance}},start:{get:function(){return this._start}},end:{get:function(){return this._end}},heading:{get:function(){return r.A.defined("distance",this._distance),this._heading}}}),A.fromStartHeadingDistance=function(e,t,n,i,o){r.A.defined("start",e),r.A.defined("heading",t),r.A.defined("distance",n),r.A.typeOf.number.greaterThan("distance",n,0);const s=i??c.A.default,h=s.maximumRadius,u=s.minimumRadius,d=h*h,p=u*u,m=Math.sqrt((d-p)/d),_=f(e,t=l.A.negativePiToPi(t),n,s.maximumRadius,m);return!(0,a.A)(o)||(0,a.A)(i)&&!i.equals(o.ellipsoid)?new A(e,_,s):(o.setEndPoints(e,_),o)},A.prototype.setEndPoints=function(e,t){r.A.defined("start",e),r.A.defined("end",t),m(this,e,t,this._ellipsoid)},A.prototype.interpolateUsingFraction=function(e,t){return this.interpolateUsingSurfaceDistance(e*this._distance,t)},A.prototype.interpolateUsingSurfaceDistance=function(e,t){if(r.A.typeOf.number("distance",e),!(0,a.A)(this._distance)||0===this._distance)throw new s.A("EllipsoidRhumbLine must have distinct start and end set.");return f(this._start,this._heading,e,this._ellipsoid.maximumRadius,this._ellipticity,t)},A.prototype.findIntersectionWithLongitude=function(e,t){if(r.A.typeOf.number("intersectionLongitude",e),!(0,a.A)(this._distance)||0===this._distance)throw new s.A("EllipsoidRhumbLine must have distinct start and end set.");const n=this._ellipticity,i=this._heading,c=Math.abs(i),h=this._start;if(e=l.A.negativePiToPi(e),l.A.equalsEpsilon(Math.abs(e),Math.PI,l.A.EPSILON14)&&(e=l.A.sign(h.longitude)*Math.PI),(0,a.A)(t)||(t=new o.A),Math.abs(l.A.PI_OVER_TWO-c)<=l.A.EPSILON8)return t.longitude=e,t.latitude=h.latitude,t.height=0,t;if(l.A.equalsEpsilon(Math.abs(l.A.PI_OVER_TWO-c),l.A.PI_OVER_TWO,l.A.EPSILON8)){if(l.A.equalsEpsilon(e,h.longitude,l.A.EPSILON12))return;return t.longitude=e,t.latitude=l.A.PI_OVER_TWO*l.A.sign(l.A.PI_OVER_TWO-i),t.height=0,t}const u=h.latitude,d=n*Math.sin(u),p=Math.tan(.5*(l.A.PI_OVER_TWO+u))*Math.exp((e-h.longitude)/Math.tan(i)),m=(1+d)/(1-d);let f,A=h.latitude;do{f=A;const e=n*Math.sin(f),t=(1+e)/(1-e);A=2*Math.atan(p*Math.pow(t/m,n/2))-l.A.PI_OVER_TWO}while(!l.A.equalsEpsilon(A,f,l.A.EPSILON12));return t.longitude=e,t.latitude=A,t.height=0,t},A.prototype.findIntersectionWithLatitude=function(e,t){if(r.A.typeOf.number("intersectionLatitude",e),!(0,a.A)(this._distance)||0===this._distance)throw new s.A("EllipsoidRhumbLine must have distinct start and end set.");const n=this._ellipticity,i=this._heading,c=this._start;if(l.A.equalsEpsilon(Math.abs(i),l.A.PI_OVER_TWO,l.A.EPSILON8))return;const h=u(n,c.latitude),d=u(n,e),p=Math.tan(i)*(d-h),m=l.A.negativePiToPi(c.longitude+p);return(0,a.A)(t)?(t.longitude=m,t.latitude=e,t.height=0,t):new o.A(m,e,0)};const _=A},658091:(e,t,n)=>{"use strict";n.d(t,{A:()=>w});var i=n(807135),o=n(434067),r=n(267980),a=n(626809),s=n(369031),c=n(491446),l=n(605971),h=n(610750),u=n(150429),d=n(584164),p=n(257941),m=n(766067),f=n(543622);const A=new a.A;function _(e,t){if(s.A.defined("origin",e),e=(t=t??h.A.default).scaleToGeodeticSurface(e),!(0,c.A)(e))throw new l.A("origin must not be at the center of the ellipsoid.");const n=f.A.eastNorthUpToFixedFrame(e,t);this._ellipsoid=t,this._origin=e,this._xAxis=r.A.fromCartesian4(d.A.getColumn(n,0,A)),this._yAxis=r.A.fromCartesian4(d.A.getColumn(n,1,A));const i=r.A.fromCartesian4(d.A.getColumn(n,2,A));this._plane=p.A.fromPointNormal(e,i)}Object.defineProperties(_.prototype,{ellipsoid:{get:function(){return this._ellipsoid}},origin:{get:function(){return this._origin}},plane:{get:function(){return this._plane}},xAxis:{get:function(){return this._xAxis}},yAxis:{get:function(){return this._yAxis}},zAxis:{get:function(){return this._plane.normal}}});const g=new i.A;_.fromPoints=function(e,t){return s.A.defined("cartesians",e),new _(i.A.fromPoints(e,g).center,t)};const y=new m.A,v=new r.A;_.prototype.projectPointOntoPlane=function(e,t){s.A.defined("cartesian",e);const n=y;n.origin=e,r.A.normalize(e,n.direction);let i=u.A.rayPlane(n,this._plane,v);if((0,c.A)(i)||(r.A.negate(n.direction,n.direction),i=u.A.rayPlane(n,this._plane,v)),(0,c.A)(i)){const e=r.A.subtract(i,this._origin,i),n=r.A.dot(this._xAxis,e),a=r.A.dot(this._yAxis,e);return(0,c.A)(t)?(t.x=n,t.y=a,t):new o.A(n,a)}},_.prototype.projectPointsOntoPlane=function(e,t){s.A.defined("cartesians",e),(0,c.A)(t)||(t=[]);let n=0;const i=e.length;for(let o=0;o<i;o++){const i=this.projectPointOntoPlane(e[o],t[n]);(0,c.A)(i)&&(t[n]=i,n++)}return t.length=n,t},_.prototype.projectPointToNearestOnPlane=function(e,t){s.A.defined("cartesian",e),(0,c.A)(t)||(t=new o.A);const n=y;n.origin=e,r.A.clone(this._plane.normal,n.direction);let i=u.A.rayPlane(n,this._plane,v);(0,c.A)(i)||(r.A.negate(n.direction,n.direction),i=u.A.rayPlane(n,this._plane,v));const a=r.A.subtract(i,this._origin,i),l=r.A.dot(this._xAxis,a),h=r.A.dot(this._yAxis,a);return t.x=l,t.y=h,t},_.prototype.projectPointsToNearestOnPlane=function(e,t){s.A.defined("cartesians",e),(0,c.A)(t)||(t=[]);const n=e.length;t.length=n;for(let i=0;i<n;i++)t[i]=this.projectPointToNearestOnPlane(e[i],t[i]);return t};const b=new r.A;_.prototype.projectPointOntoEllipsoid=function(e,t){s.A.defined("cartesian",e),(0,c.A)(t)||(t=new r.A);const n=this._ellipsoid,i=this._origin,o=this._xAxis,a=this._yAxis,l=b;return r.A.multiplyByScalar(o,e.x,l),t=r.A.add(i,l,t),r.A.multiplyByScalar(a,e.y,l),r.A.add(t,l,t),n.scaleToGeocentricSurface(t,t),t},_.prototype.projectPointsOntoEllipsoid=function(e,t){s.A.defined("cartesians",e);const n=e.length;(0,c.A)(t)?t.length=n:t=new Array(n);for(let i=0;i<n;++i)t[i]=this.projectPointOntoEllipsoid(e[i],t[i]);return t};const w=_},199528:(e,t,n)=>{"use strict";n.d(t,{A:()=>E});var i=n(660662),o=n(267980),r=n(369031),a=n(491446),s=n(610750),c=n(697422);function l(e,t){r.A.typeOf.object("ellipsoid",e),this._ellipsoid=e,this._cameraPosition=new o.A,this._cameraPositionInScaledSpace=new o.A,this._distanceToLimbInScaledSpaceSquared=0,(0,a.A)(t)&&(this.cameraPosition=t)}Object.defineProperties(l.prototype,{ellipsoid:{get:function(){return this._ellipsoid}},cameraPosition:{get:function(){return this._cameraPosition},set:function(e){const t=this._ellipsoid.transformPositionToScaledSpace(e,this._cameraPositionInScaledSpace),n=o.A.magnitudeSquared(t)-1;o.A.clone(e,this._cameraPosition),this._cameraPositionInScaledSpace=t,this._distanceToLimbInScaledSpaceSquared=n}}});const h=new o.A;l.prototype.isPointVisible=function(e){return y(this._ellipsoid.transformPositionToScaledSpace(e,h),this._cameraPositionInScaledSpace,this._distanceToLimbInScaledSpaceSquared)},l.prototype.isScaledSpacePointVisible=function(e){return y(e,this._cameraPositionInScaledSpace,this._distanceToLimbInScaledSpaceSquared)};const u=new o.A;l.prototype.isScaledSpacePointVisiblePossiblyUnderEllipsoid=function(e,t){const n=this._ellipsoid;let i,o;return(0,a.A)(t)&&t<0&&n.minimumRadius>-t?(o=u,o.x=this._cameraPosition.x/(n.radii.x+t),o.y=this._cameraPosition.y/(n.radii.y+t),o.z=this._cameraPosition.z/(n.radii.z+t),i=o.x*o.x+o.y*o.y+o.z*o.z-1):(o=this._cameraPositionInScaledSpace,i=this._distanceToLimbInScaledSpaceSquared),y(e,o,i)},l.prototype.computeHorizonCullingPoint=function(e,t,n){return A(this._ellipsoid,e,t,n)};const d=s.A.clone(s.A.UNIT_SPHERE);l.prototype.computeHorizonCullingPointPossiblyUnderEllipsoid=function(e,t,n,i){return A(f(this._ellipsoid,n,d),e,t,i)},l.prototype.computeHorizonCullingPointFromVertices=function(e,t,n,i,o){return g(this._ellipsoid,e,t,n,i,o)},l.prototype.computeHorizonCullingPointFromVerticesPossiblyUnderEllipsoid=function(e,t,n,i,o,r){return g(f(this._ellipsoid,o,d),e,t,n,i,r)};const p=[];l.prototype.computeHorizonCullingPointFromRectangle=function(e,t,n){r.A.typeOf.object("rectangle",e);const a=c.A.subsample(e,t,0,p),s=i.A.fromPoints(a);if(!(o.A.magnitude(s.center)<.1*t.minimumRadius))return this.computeHorizonCullingPoint(s.center,a,n)};const m=new o.A;function f(e,t,n){if((0,a.A)(t)&&t<0&&e.minimumRadius>-t){const i=o.A.fromElements(e.radii.x+t,e.radii.y+t,e.radii.z+t,m);e=s.A.fromCartesian3(i,n)}return e}function A(e,t,n,i){r.A.typeOf.object("directionToPoint",t),r.A.defined("positions",n),(0,a.A)(i)||(i=new o.A);const s=C(e,t);let c=0;for(let t=0,i=n.length;t<i;++t){const i=w(e,n[t],s);if(i<0)return;c=Math.max(c,i)}return T(s,c,i)}const _=new o.A;function g(e,t,n,i,s,c){r.A.typeOf.object("directionToPoint",t),r.A.defined("vertices",n),r.A.typeOf.number("stride",i),(0,a.A)(c)||(c=new o.A),i=i??3,s=s??o.A.ZERO;const l=C(e,t);let h=0;for(let t=0,o=n.length;t<o;t+=i){_.x=n[t]+s.x,_.y=n[t+1]+s.y,_.z=n[t+2]+s.z;const i=w(e,_,l);if(i<0)return;h=Math.max(h,i)}return T(l,h,c)}function y(e,t,n){const i=t,r=n,a=o.A.subtract(e,i,h),s=-o.A.dot(a,i);return!(r<0?s>0:s>r&&s*s/o.A.magnitudeSquared(a)>r)}const v=new o.A,b=new o.A;function w(e,t,n){const i=e.transformPositionToScaledSpace(t,v);let r=o.A.magnitudeSquared(i),a=Math.sqrt(r);const s=o.A.divideByScalar(i,a,b);r=Math.max(1,r),a=Math.max(1,a);const c=1/a;return 1/(o.A.dot(s,n)*c-o.A.magnitude(o.A.cross(s,n,s))*(Math.sqrt(r-1)*c))}function T(e,t,n){if(!(t<=0||t===1/0||t!=t))return o.A.multiplyByScalar(e,t,n)}const x=new o.A;function C(e,t){return o.A.equals(t,o.A.ZERO)?t:(e.transformPositionToScaledSpace(t,x),o.A.normalize(x,x))}const E=l},816422:(e,t,n)=>{"use strict";n.d(t,{A:()=>l});var i=n(267980),o=n(369031),r=n(491446);function a(){this.high=i.A.clone(i.A.ZERO),this.low=i.A.clone(i.A.ZERO)}a.encode=function(e,t){let n;return o.A.typeOf.number("value",e),(0,r.A)(t)||(t={high:0,low:0}),e>=0?(n=65536*Math.floor(e/65536),t.high=n,t.low=e-n):(n=65536*Math.floor(-e/65536),t.high=-n,t.low=e+n),t};const s={high:0,low:0};a.fromCartesian=function(e,t){o.A.typeOf.object("cartesian",e),(0,r.A)(t)||(t=new a);const n=t.high,i=t.low;return a.encode(e.x,s),n.x=s.high,i.x=s.low,a.encode(e.y,s),n.y=s.high,i.y=s.low,a.encode(e.z,s),n.z=s.high,i.z=s.low,t};const c=new a;a.writeElements=function(e,t,n){o.A.defined("cartesianArray",t),o.A.typeOf.number("index",n),o.A.typeOf.number.greaterThanOrEquals("index",n,0),a.fromCartesian(e,c);const i=c.high,r=c.low;t[n]=i.x,t[n+1]=i.y,t[n+2]=i.z,t[n+3]=r.x,t[n+4]=r.y,t[n+5]=r.z};const l=a},653577:(e,t,n)=>{"use strict";n.d(t,{A:()=>l});var i=n(267980),o=n(336946),r=n(491446),a=n(605971),s=n(610750);function c(e){this._ellipsoid=e??s.A.default,this._semimajorAxis=this._ellipsoid.maximumRadius,this._oneOverSemimajorAxis=1/this._semimajorAxis}Object.defineProperties(c.prototype,{ellipsoid:{get:function(){return this._ellipsoid}}}),c.prototype.project=function(e,t){const n=this._semimajorAxis,o=e.longitude*n,a=e.latitude*n,s=e.height;return(0,r.A)(t)?(t.x=o,t.y=a,t.z=s,t):new i.A(o,a,s)},c.prototype.unproject=function(e,t){if(!(0,r.A)(e))throw new a.A("cartesian is required");const n=this._oneOverSemimajorAxis,i=e.x*n,s=e.y*n,c=e.z;return(0,r.A)(t)?(t.longitude=i,t.latitude=s,t.height=c,t):new o.A(i,s,c)};const l=c},182348:(e,t,n)=>{"use strict";n.d(t,{A:()=>d});var i=n(434067),o=n(369031),r=n(915325),a=n(491446),s=n(610750),c=n(653577),l=n(367817),h=n(697422);function u(e){e=e??r.A.EMPTY_OBJECT,this._ellipsoid=e.ellipsoid??s.A.default,this._rectangle=e.rectangle??h.A.MAX_VALUE,this._projection=new c.A(this._ellipsoid),this._numberOfLevelZeroTilesX=e.numberOfLevelZeroTilesX??2,this._numberOfLevelZeroTilesY=e.numberOfLevelZeroTilesY??1}Object.defineProperties(u.prototype,{ellipsoid:{get:function(){return this._ellipsoid}},rectangle:{get:function(){return this._rectangle}},projection:{get:function(){return this._projection}}}),u.prototype.getNumberOfXTilesAtLevel=function(e){return this._numberOfLevelZeroTilesX<<e},u.prototype.getNumberOfYTilesAtLevel=function(e){return this._numberOfLevelZeroTilesY<<e},u.prototype.rectangleToNativeRectangle=function(e,t){o.A.defined("rectangle",e);const n=l.A.toDegrees(e.west),i=l.A.toDegrees(e.south),r=l.A.toDegrees(e.east),s=l.A.toDegrees(e.north);return(0,a.A)(t)?(t.west=n,t.south=i,t.east=r,t.north=s,t):new h.A(n,i,r,s)},u.prototype.tileXYToNativeRectangle=function(e,t,n,i){const o=this.tileXYToRectangle(e,t,n,i);return o.west=l.A.toDegrees(o.west),o.south=l.A.toDegrees(o.south),o.east=l.A.toDegrees(o.east),o.north=l.A.toDegrees(o.north),o},u.prototype.tileXYToRectangle=function(e,t,n,i){const o=this._rectangle,r=this.getNumberOfXTilesAtLevel(n),s=this.getNumberOfYTilesAtLevel(n),c=o.width/r,l=e*c+o.west,u=(e+1)*c+o.west,d=o.height/s,p=o.north-t*d,m=o.north-(t+1)*d;return(0,a.A)(i)||(i=new h.A(l,m,u,p)),i.west=l,i.south=m,i.east=u,i.north=p,i},u.prototype.positionToTileXY=function(e,t,n){const o=this._rectangle;if(!h.A.contains(o,e))return;const r=this.getNumberOfXTilesAtLevel(t),s=this.getNumberOfYTilesAtLevel(t),c=o.width/r,u=o.height/s;let d=e.longitude;o.east<o.west&&(d+=l.A.TWO_PI);let p=(d-o.west)/c|0;p>=r&&(p=r-1);let m=(o.north-e.latitude)/u|0;return m>=s&&(m=s-1),(0,a.A)(n)?(n.x=p,n.y=m,n):new i.A(p,m)};const d=u},944479:(e,t,n)=>{"use strict";n.d(t,{A:()=>O});var i=n(434067),o=n(267980),r=n(336946),a=n(369031),s=n(915325),c=n(491446),l=n(605971),h=n(597751),u=n(463298),d=n(331185),p=n(584164),m=n(402330),f=n(99479),A=n(697422),_=n(543622);function g(e){e=e??s.A.EMPTY_OBJECT,a.A.typeOf.object("options.attributes",e.attributes),this.attributes=e.attributes,this.indices=e.indices,this.primitiveType=e.primitiveType??m.A.TRIANGLES,this.boundingSphere=e.boundingSphere,this.geometryType=e.geometryType??h.A.NONE,this.boundingSphereCV=e.boundingSphereCV,this.offsetAttribute=e.offsetAttribute}g.computeNumberOfVertices=function(e){a.A.typeOf.object("geometry",e);let t=-1;for(const n in e.attributes)if(e.attributes.hasOwnProperty(n)&&(0,c.A)(e.attributes[n])&&(0,c.A)(e.attributes[n].values)){const i=e.attributes[n],o=i.values.length/i.componentsPerAttribute;if(t!==o&&-1!==t)throw new l.A("All attribute lists must have the same number of attributes.");t=o}return t};const y=new r.A,v=new o.A,b=new p.A,w=[new r.A,new r.A,new r.A],T=[new i.A,new i.A,new i.A],x=[new i.A,new i.A,new i.A],C=new o.A,E=new f.A,S=new p.A,D=new u.A;g._textureCoordinateRotationPoints=function(e,t,n,a){let s;const c=A.A.center(a,y),l=r.A.toCartesian(c,n,v),h=_.A.eastNorthUpToFixedFrame(l,n,b),m=p.A.inverse(h,b),g=T,O=w;O[0].longitude=a.west,O[0].latitude=a.south,O[1].longitude=a.west,O[1].latitude=a.north,O[2].longitude=a.east,O[2].latitude=a.south;let z=C;for(s=0;s<3;s++)r.A.toCartesian(O[s],n,z),z=p.A.multiplyByPointAsVector(m,z,z),g[s].x=z.x,g[s].y=z.y;const I=f.A.fromAxisAngle(o.A.UNIT_Z,-t,E),P=d.A.fromQuaternion(I,S),R=e.length;let N=Number.POSITIVE_INFINITY,L=Number.POSITIVE_INFINITY,M=Number.NEGATIVE_INFINITY,F=Number.NEGATIVE_INFINITY;for(s=0;s<R;s++)z=p.A.multiplyByPointAsVector(m,e[s],z),z=d.A.multiplyByVector(P,z,z),N=Math.min(N,z.x),L=Math.min(L,z.y),M=Math.max(M,z.x),F=Math.max(F,z.y);const B=u.A.fromRotation(t,D),k=x;k[0].x=N,k[0].y=L,k[1].x=N,k[1].y=F,k[2].x=M,k[2].y=L;const V=g[0],G=g[2].x-V.x,H=g[1].y-V.y;for(s=0;s<3;s++){const e=k[s];u.A.multiplyByVector(B,e,e),e.x=(e.x-V.x)/G,e.y=(e.y-V.y)/H}const U=k[0],W=k[1],q=k[2],j=new Array(6);return i.A.pack(U,j),i.A.pack(W,j,2),i.A.pack(q,j,4),j};const O=g},305439:(e,t,n)=>{"use strict";n.d(t,{A:()=>a});var i=n(915325),o=n(491446),r=n(605971);const a=function(e){if(e=e??i.A.EMPTY_OBJECT,!(0,o.A)(e.componentDatatype))throw new r.A("options.componentDatatype is required.");if(!(0,o.A)(e.componentsPerAttribute))throw new r.A("options.componentsPerAttribute is required.");if(e.componentsPerAttribute<1||e.componentsPerAttribute>4)throw new r.A("options.componentsPerAttribute must be between 1 and 4.");if(!(0,o.A)(e.values))throw new r.A("options.values is required.");this.componentDatatype=e.componentDatatype,this.componentsPerAttribute=e.componentsPerAttribute,this.normalize=e.normalize??!1,this.values=e.values}},46362:(e,t,n)=>{"use strict";n.d(t,{A:()=>o});var i=n(915325);const o=function(e){e=e??i.A.EMPTY_OBJECT,this.position=e.position,this.normal=e.normal,this.st=e.st,this.bitangent=e.bitangent,this.tangent=e.tangent,this.color=e.color}},75200:(e,t,n)=>{"use strict";n.d(t,{A:()=>s});var i=n(915325),o=n(491446),r=n(605971),a=n(584164);const s=function(e){if(e=e??i.A.EMPTY_OBJECT,!(0,o.A)(e.geometry))throw new r.A("options.geometry is required.");this.geometry=e.geometry,this.modelMatrix=a.A.clone(e.modelMatrix??a.A.IDENTITY),this.id=e.id,this.pickPrimitive=e.pickPrimitive,this.attributes=e.attributes??{},this.westHemisphereGeometry=void 0,this.eastHemisphereGeometry=void 0}},494938:(e,t,n)=>{"use strict";n.d(t,{A:()=>a});var i=n(915325),o=n(491446),r=n(605971);const a=function(e){if(e=e??i.A.EMPTY_OBJECT,!(0,o.A)(e.componentDatatype))throw new r.A("options.componentDatatype is required.");if(!(0,o.A)(e.componentsPerAttribute))throw new r.A("options.componentsPerAttribute is required.");if(e.componentsPerAttribute<1||e.componentsPerAttribute>4)throw new r.A("options.componentsPerAttribute must be between 1 and 4.");if(!(0,o.A)(e.value))throw new r.A("options.value is required.");this.componentDatatype=e.componentDatatype,this.componentsPerAttribute=e.componentsPerAttribute,this.normalize=e.normalize??!1,this.value=e.value}},794554:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i=Object.freeze({NONE:0,TOP:1,ALL:2})},34233:(e,t,n)=>{"use strict";n.d(t,{A:()=>Ge});var i=n(961645),o=n(744436),r=n(660662),a=n(434067),s=n(267980),c=n(626809),l=n(336946),h=n(571804),u=n(491446),d=n(605971),p=n(816422),m=n(653577),f=n(944479),A=n(305439),_=n(597751),g=n(874915),y=n(647326),v=n(150429),b=n(367817),w=n(331185),T=n(584164),x=n(257941),C=n(402330),E=n(343899);const S={};function D(e,t,n,i,o){e[t++]=n,e[t++]=i,e[t++]=i,e[t++]=o,e[t++]=o,e[t]=n}function O(e){const t={};for(const n in e)if(e.hasOwnProperty(n)&&(0,u.A)(e[n])&&(0,u.A)(e[n].values)){const i=e[n];t[n]=new A.A({componentDatatype:i.componentDatatype,componentsPerAttribute:i.componentsPerAttribute,normalize:i.normalize,values:[]})}return t}function z(e,t,n){for(const i in t)if(t.hasOwnProperty(i)&&(0,u.A)(t[i])&&(0,u.A)(t[i].values)){const o=t[i];for(let t=0;t<o.componentsPerAttribute;++t)e[i].values.push(o.values[n*o.componentsPerAttribute+t])}}S.toWireframe=function(e){if(!(0,u.A)(e))throw new d.A("geometry is required.");const t=e.indices;if((0,u.A)(t)){switch(e.primitiveType){case C.A.TRIANGLES:e.indices=function(e){const t=e.length,n=t/3*6,i=g.A.createTypedArray(t,n);let o=0;for(let n=0;n<t;n+=3,o+=6)D(i,o,e[n],e[n+1],e[n+2]);return i}(t);break;case C.A.TRIANGLE_STRIP:e.indices=function(e){const t=e.length;if(t>=3){const n=6*(t-2),i=g.A.createTypedArray(t,n);D(i,0,e[0],e[1],e[2]);let o=6;for(let n=3;n<t;++n,o+=6)D(i,o,e[n-1],e[n],e[n-2]);return i}return new Uint16Array}(t);break;case C.A.TRIANGLE_FAN:e.indices=function(e){if(e.length>0){const t=e.length-1,n=6*(t-1),i=g.A.createTypedArray(t,n),o=e[0];let r=0;for(let n=1;n<t;++n,r+=6)D(i,r,o,e[n],e[n+1]);return i}return new Uint16Array}(t);break;default:throw new d.A("geometry.primitiveType must be TRIANGLES, TRIANGLE_STRIP, or TRIANGLE_FAN.")}e.primitiveType=C.A.LINES}return e},S.createLineSegmentsForVectors=function(e,t,n){if(t=t??"normal",!(0,u.A)(e))throw new d.A("geometry is required.");if(!(0,u.A)(e.attributes.position))throw new d.A("geometry.attributes.position is required.");if(!(0,u.A)(e.attributes[t]))throw new d.A(`geometry.attributes must have an attribute with the same name as the attributeName parameter, ${t}.`);n=n??1e4;const i=e.attributes.position.values,o=e.attributes[t].values,a=i.length,s=new Float64Array(2*a);let c,l=0;for(let e=0;e<a;e+=3)s[l++]=i[e],s[l++]=i[e+1],s[l++]=i[e+2],s[l++]=i[e]+o[e]*n,s[l++]=i[e+1]+o[e+1]*n,s[l++]=i[e+2]+o[e+2]*n;const p=e.boundingSphere;return(0,u.A)(p)&&(c=new r.A(p.center,p.radius+n)),new f.A({attributes:{position:new A.A({componentDatatype:h.A.DOUBLE,componentsPerAttribute:3,values:s})},primitiveType:C.A.LINES,boundingSphere:c})},S.createAttributeLocations=function(e){if(!(0,u.A)(e))throw new d.A("geometry is required.");const t=["position","positionHigh","positionLow","position3DHigh","position3DLow","position2DHigh","position2DLow","pickColor","normal","st","tangent","bitangent","extrudeDirection","compressedAttributes"],n=e.attributes,i={};let o,r=0;const a=t.length;for(o=0;o<a;++o){const e=t[o];(0,u.A)(n[e])&&(i[e]=r++)}for(const e in n)n.hasOwnProperty(e)&&!(0,u.A)(i[e])&&(i[e]=r++);return i},S.reorderForPreVertexCache=function(e){if(!(0,u.A)(e))throw new d.A("geometry is required.");const t=f.A.computeNumberOfVertices(e),n=e.indices;if((0,u.A)(n)){const i=new Int32Array(t);for(let e=0;e<t;e++)i[e]=-1;const o=n,r=o.length,a=g.A.createTypedArray(t,r);let s,c=0,l=0,d=0;for(;c<r;)s=i[o[c]],-1!==s?a[l]=s:(s=o[c],i[s]=d,a[l]=d,++d),++c,++l;e.indices=a;const p=e.attributes;for(const e in p)if(p.hasOwnProperty(e)&&(0,u.A)(p[e])&&(0,u.A)(p[e].values)){const n=p[e],o=n.values;let r=0;const a=n.componentsPerAttribute,s=h.A.createTypedArray(n.componentDatatype,d*a);for(;r<t;){const e=i[r];if(-1!==e)for(let t=0;t<a;t++)s[a*e+t]=o[a*r+t];++r}n.values=s}}return e},S.reorderForPostVertexCache=function(e,t){if(!(0,u.A)(e))throw new d.A("geometry is required.");const n=e.indices;if(e.primitiveType===C.A.TRIANGLES&&(0,u.A)(n)){const i=n.length;let o=0;for(let e=0;e<i;e++)n[e]>o&&(o=n[e]);e.indices=E.A.tipsify({indices:n,maximumIndex:o,cacheSize:t})}return e},S.fitToUnsignedShortIndices=function(e){if(!(0,u.A)(e))throw new d.A("geometry is required.");if((0,u.A)(e.indices)&&e.primitiveType!==C.A.TRIANGLES&&e.primitiveType!==C.A.LINES&&e.primitiveType!==C.A.POINTS)throw new d.A("geometry.primitiveType must equal to PrimitiveType.TRIANGLES, PrimitiveType.LINES, or PrimitiveType.POINTS.");const t=[],n=f.A.computeNumberOfVertices(e);if((0,u.A)(e.indices)&&n>=b.A.SIXTY_FOUR_KILOBYTES){let n=[],i=[],o=0,r=O(e.attributes);const a=e.indices,s=a.length;let c;e.primitiveType===C.A.TRIANGLES?c=3:e.primitiveType===C.A.LINES?c=2:e.primitiveType===C.A.POINTS&&(c=1);for(let l=0;l<s;l+=c){for(let t=0;t<c;++t){const s=a[l+t];let c=n[s];(0,u.A)(c)||(c=o++,n[s]=c,z(r,e.attributes,s)),i.push(c)}o+c>=b.A.SIXTY_FOUR_KILOBYTES&&(t.push(new f.A({attributes:r,indices:i,primitiveType:e.primitiveType,boundingSphere:e.boundingSphere,boundingSphereCV:e.boundingSphereCV})),n=[],i=[],o=0,r=O(e.attributes))}0!==i.length&&t.push(new f.A({attributes:r,indices:i,primitiveType:e.primitiveType,boundingSphere:e.boundingSphere,boundingSphereCV:e.boundingSphereCV}))}else t.push(e);return t};const I=new s.A,P=new l.A;S.projectTo2D=function(e,t,n,i,o){if(!(0,u.A)(e))throw new d.A("geometry is required.");if(!(0,u.A)(t))throw new d.A("attributeName is required.");if(!(0,u.A)(n))throw new d.A("attributeName3D is required.");if(!(0,u.A)(i))throw new d.A("attributeName2D is required.");if(!(0,u.A)(e.attributes[t]))throw new d.A(`geometry must have attribute matching the attributeName argument: ${t}.`);if(e.attributes[t].componentDatatype!==h.A.DOUBLE)throw new d.A("The attribute componentDatatype must be ComponentDatatype.DOUBLE.");const r=e.attributes[t],a=(o=(0,u.A)(o)?o:new m.A).ellipsoid,c=r.values,l=new Float64Array(c.length);let p=0;for(let e=0;e<c.length;e+=3){const t=s.A.fromArray(c,e,I),n=a.cartesianToCartographic(t,P);if(!(0,u.A)(n))throw new d.A(`Could not project point (${t.x}, ${t.y}, ${t.z}) to 2D.`);const i=o.project(n,I);l[p++]=i.x,l[p++]=i.y,l[p++]=i.z}return e.attributes[n]=r,e.attributes[i]=new A.A({componentDatatype:h.A.DOUBLE,componentsPerAttribute:3,values:l}),delete e.attributes[t],e};const R={high:0,low:0};S.encodeAttribute=function(e,t,n,i){if(!(0,u.A)(e))throw new d.A("geometry is required.");if(!(0,u.A)(t))throw new d.A("attributeName is required.");if(!(0,u.A)(n))throw new d.A("attributeHighName is required.");if(!(0,u.A)(i))throw new d.A("attributeLowName is required.");if(!(0,u.A)(e.attributes[t]))throw new d.A(`geometry must have attribute matching the attributeName argument: ${t}.`);if(e.attributes[t].componentDatatype!==h.A.DOUBLE)throw new d.A("The attribute componentDatatype must be ComponentDatatype.DOUBLE.");const o=e.attributes[t],r=o.values,a=r.length,s=new Float32Array(a),c=new Float32Array(a);for(let e=0;e<a;++e)p.A.encode(r[e],R),s[e]=R.high,c[e]=R.low;const l=o.componentsPerAttribute;return e.attributes[n]=new A.A({componentDatatype:h.A.FLOAT,componentsPerAttribute:l,values:s}),e.attributes[i]=new A.A({componentDatatype:h.A.FLOAT,componentsPerAttribute:l,values:c}),delete e.attributes[t],e};let N=new s.A;function L(e,t){if((0,u.A)(t)){const n=t.values,i=n.length;for(let t=0;t<i;t+=3)s.A.unpack(n,t,N),T.A.multiplyByPoint(e,N,N),s.A.pack(N,n,t)}}function M(e,t){if((0,u.A)(t)){const n=t.values,i=n.length;for(let t=0;t<i;t+=3)s.A.unpack(n,t,N),w.A.multiplyByVector(e,N,N),N=s.A.normalize(N,N),s.A.pack(N,n,t)}}const F=new T.A,B=new w.A;S.transformToWorldCoordinates=function(e){if(!(0,u.A)(e))throw new d.A("instance is required.");const t=e.modelMatrix;if(T.A.equals(t,T.A.IDENTITY))return e;const n=e.geometry.attributes;L(t,n.position),L(t,n.prevPosition),L(t,n.nextPosition),((0,u.A)(n.normal)||(0,u.A)(n.tangent)||(0,u.A)(n.bitangent))&&(T.A.inverse(t,F),T.A.transpose(F,F),T.A.getMatrix3(F,B),M(B,n.normal),M(B,n.tangent),M(B,n.bitangent));const i=e.geometry.boundingSphere;return(0,u.A)(i)&&(e.geometry.boundingSphere=r.A.transform(i,t,i)),e.modelMatrix=T.A.clone(T.A.IDENTITY),e};const k=new s.A;function V(e,t){const n=e.length;let i,o,a,c;const l=e[0].modelMatrix,p=(0,u.A)(e[0][t].indices),m=e[0][t].primitiveType;for(o=1;o<n;++o){if(!T.A.equals(e[o].modelMatrix,l))throw new d.A("All instances must have the same modelMatrix.");if((0,u.A)(e[o][t].indices)!==p)throw new d.A("All instance geometries must have an indices or not have one.");if(e[o][t].primitiveType!==m)throw new d.A("All instance geometries must have the same primitiveType.")}const _=function(e,t){const n=e.length,i={},o=e[0][t].attributes;let r;for(r in o)if(o.hasOwnProperty(r)&&(0,u.A)(o[r])&&(0,u.A)(o[r].values)){const a=o[r];let s=a.values.length,c=!0;for(let i=1;i<n;++i){const n=e[i][t].attributes[r];if(!(0,u.A)(n)||a.componentDatatype!==n.componentDatatype||a.componentsPerAttribute!==n.componentsPerAttribute||a.normalize!==n.normalize){c=!1;break}s+=n.values.length}c&&(i[r]=new A.A({componentDatatype:a.componentDatatype,componentsPerAttribute:a.componentsPerAttribute,normalize:a.normalize,values:h.A.createTypedArray(a.componentDatatype,s)}))}return i}(e,t);let y,v,b,w;for(i in _)if(_.hasOwnProperty(i))for(y=_[i].values,c=0,o=0;o<n;++o)for(v=e[o][t].attributes[i].values,b=v.length,a=0;a<b;++a)y[c++]=v[a];if(p){let i=0;for(o=0;o<n;++o)i+=e[o][t].indices.length;const r=f.A.computeNumberOfVertices(new f.A({attributes:_,primitiveType:C.A.POINTS})),a=g.A.createTypedArray(r,i);let s=0,l=0;for(o=0;o<n;++o){const n=e[o][t].indices,i=n.length;for(c=0;c<i;++c)a[s++]=l+n[c];l+=f.A.computeNumberOfVertices(e[o][t])}w=a}let x,E=new s.A,S=0;for(o=0;o<n;++o){if(x=e[o][t].boundingSphere,!(0,u.A)(x)){E=void 0;break}s.A.add(x.center,E,E)}if((0,u.A)(E))for(s.A.divideByScalar(E,n,E),o=0;o<n;++o){x=e[o][t].boundingSphere;const n=s.A.magnitude(s.A.subtract(x.center,E,k))+x.radius;n>S&&(S=n)}return new f.A({attributes:_,indices:w,primitiveType:m,boundingSphere:(0,u.A)(E)?new r.A(E,S):void 0})}S.combineInstances=function(e){if(!(0,u.A)(e)||e.length<1)throw new d.A("instances is required and must have length greater than zero.");const t=[],n=[],i=e.length;for(let o=0;o<i;++o){const i=e[o];(0,u.A)(i.geometry)?t.push(i):(0,u.A)(i.westHemisphereGeometry)&&(0,u.A)(i.eastHemisphereGeometry)&&n.push(i)}const o=[];return t.length>0&&o.push(V(t,"geometry")),n.length>0&&(o.push(V(n,"westHemisphereGeometry")),o.push(V(n,"eastHemisphereGeometry"))),o};const G=new s.A,H=new s.A,U=new s.A,W=new s.A;S.computeNormal=function(e){if(!(0,u.A)(e))throw new d.A("geometry is required.");if(!(0,u.A)(e.attributes.position)||!(0,u.A)(e.attributes.position.values))throw new d.A("geometry.attributes.position.values is required.");if(!(0,u.A)(e.indices))throw new d.A("geometry.indices is required.");if(e.indices.length<2||e.indices.length%3!=0)throw new d.A("geometry.indices length must be greater than 0 and be a multiple of 3.");if(e.primitiveType!==C.A.TRIANGLES)throw new d.A("geometry.primitiveType must be PrimitiveType.TRIANGLES.");const t=e.indices,n=e.attributes,i=n.position.values,o=n.position.values.length/3,r=t.length,a=new Array(o),c=new Array(r/3),l=new Array(r);let p;for(p=0;p<o;p++)a[p]={indexOffset:0,count:0,currentCount:0};let m=0;for(p=0;p<r;p+=3){const e=t[p],n=t[p+1],o=t[p+2],r=3*e,l=3*n,h=3*o;H.x=i[r],H.y=i[r+1],H.z=i[r+2],U.x=i[l],U.y=i[l+1],U.z=i[l+2],W.x=i[h],W.y=i[h+1],W.z=i[h+2],a[e].count++,a[n].count++,a[o].count++,s.A.subtract(U,H,U),s.A.subtract(W,H,W),c[m]=s.A.cross(U,W,new s.A),m++}let f,_=0;for(p=0;p<o;p++)a[p].indexOffset+=_,_+=a[p].count;for(m=0,p=0;p<r;p+=3){f=a[t[p]];let e=f.indexOffset+f.currentCount;l[e]=m,f.currentCount++,f=a[t[p+1]],e=f.indexOffset+f.currentCount,l[e]=m,f.currentCount++,f=a[t[p+2]],e=f.indexOffset+f.currentCount,l[e]=m,f.currentCount++,m++}const g=new Float32Array(3*o);for(p=0;p<o;p++){const e=3*p;if(f=a[p],s.A.clone(s.A.ZERO,G),f.count>0){for(m=0;m<f.count;m++)s.A.add(G,c[l[f.indexOffset+m]],G);s.A.equalsEpsilon(s.A.ZERO,G,b.A.EPSILON10)&&s.A.clone(c[l[f.indexOffset]],G)}s.A.equalsEpsilon(s.A.ZERO,G,b.A.EPSILON10)&&(G.z=1),s.A.normalize(G,G),g[e]=G.x,g[e+1]=G.y,g[e+2]=G.z}return e.attributes.normal=new A.A({componentDatatype:h.A.FLOAT,componentsPerAttribute:3,values:g}),e};const q=new s.A,j=new s.A,Y=new s.A;S.computeTangentAndBitangent=function(e){if(!(0,u.A)(e))throw new d.A("geometry is required.");const t=e.attributes,n=e.indices;if(!(0,u.A)(t.position)||!(0,u.A)(t.position.values))throw new d.A("geometry.attributes.position.values is required.");if(!(0,u.A)(t.normal)||!(0,u.A)(t.normal.values))throw new d.A("geometry.attributes.normal.values is required.");if(!(0,u.A)(t.st)||!(0,u.A)(t.st.values))throw new d.A("geometry.attributes.st.values is required.");if(!(0,u.A)(n))throw new d.A("geometry.indices is required.");if(n.length<2||n.length%3!=0)throw new d.A("geometry.indices length must be greater than 0 and be a multiple of 3.");if(e.primitiveType!==C.A.TRIANGLES)throw new d.A("geometry.primitiveType must be PrimitiveType.TRIANGLES.");const i=e.attributes.position.values,o=e.attributes.normal.values,r=e.attributes.st.values,a=e.attributes.position.values.length/3,c=n.length,l=new Array(3*a);let p,m,f,_;for(p=0;p<l.length;p++)l[p]=0;for(p=0;p<c;p+=3){const e=n[p],t=n[p+1],o=n[p+2];m=3*e,f=3*t,_=3*o;const a=2*e,s=2*t,c=2*o,h=i[m],u=i[m+1],d=i[m+2],A=r[a],g=r[a+1],y=r[s+1]-g,v=r[c+1]-g,b=1/((r[s]-A)*v-(r[c]-A)*y),w=(v*(i[f]-h)-y*(i[_]-h))*b,T=(v*(i[f+1]-u)-y*(i[_+1]-u))*b,x=(v*(i[f+2]-d)-y*(i[_+2]-d))*b;l[m]+=w,l[m+1]+=T,l[m+2]+=x,l[f]+=w,l[f+1]+=T,l[f+2]+=x,l[_]+=w,l[_+1]+=T,l[_+2]+=x}const g=new Float32Array(3*a),y=new Float32Array(3*a);for(p=0;p<a;p++){m=3*p,f=m+1,_=m+2;const e=s.A.fromArray(o,m,q),t=s.A.fromArray(l,m,Y),n=s.A.dot(e,t);s.A.multiplyByScalar(e,n,j),s.A.normalize(s.A.subtract(t,j,t),t),g[m]=t.x,g[f]=t.y,g[_]=t.z,s.A.normalize(s.A.cross(e,t,t),t),y[m]=t.x,y[f]=t.y,y[_]=t.z}return e.attributes.tangent=new A.A({componentDatatype:h.A.FLOAT,componentsPerAttribute:3,values:g}),e.attributes.bitangent=new A.A({componentDatatype:h.A.FLOAT,componentsPerAttribute:3,values:y}),e};const X=new a.A,$=new s.A,Z=new s.A,K=new s.A;let Q=new a.A;function J(e,t){Math.abs(e.y)<b.A.EPSILON6&&(e.y=t?-b.A.EPSILON6:b.A.EPSILON6)}S.compressVertices=function(e){if(!(0,u.A)(e))throw new d.A("geometry is required.");const t=e.attributes.extrudeDirection;let n,o;if((0,u.A)(t)){const r=t.values;o=r.length/3;const a=new Float32Array(2*o);let c=0;for(n=0;n<o;++n)s.A.fromArray(r,3*n,$),s.A.equals($,s.A.ZERO)?c+=2:(Q=i.A.octEncodeInRange($,65535,Q),a[c++]=Q.x,a[c++]=Q.y);return e.attributes.compressedAttributes=new A.A({componentDatatype:h.A.FLOAT,componentsPerAttribute:2,values:a}),delete e.attributes.extrudeDirection,e}const r=e.attributes.normal,c=e.attributes.st,l=(0,u.A)(r),p=(0,u.A)(c);if(!l&&!p)return e;const m=e.attributes.tangent,f=e.attributes.bitangent,_=(0,u.A)(m),g=(0,u.A)(f);let y,v,b,w;l&&(y=r.values),p&&(v=c.values),_&&(b=m.values),g&&(w=f.values),o=(l?y.length:v.length)/(l?3:2);let T=o,x=p&&l?2:1;x+=_||g?1:0,T*=x;const C=new Float32Array(T);let E=0;for(n=0;n<o;++n){p&&(a.A.fromArray(v,2*n,X),C[E++]=i.A.compressTextureCoordinates(X));const e=3*n;l&&(0,u.A)(b)&&(0,u.A)(w)?(s.A.fromArray(y,e,$),s.A.fromArray(b,e,Z),s.A.fromArray(w,e,K),i.A.octPack($,Z,K,X),C[E++]=X.x,C[E++]=X.y):(l&&(s.A.fromArray(y,e,$),C[E++]=i.A.octEncodeFloat($)),_&&(s.A.fromArray(b,e,$),C[E++]=i.A.octEncodeFloat($)),g&&(s.A.fromArray(w,e,$),C[E++]=i.A.octEncodeFloat($)))}return e.attributes.compressedAttributes=new A.A({componentDatatype:h.A.FLOAT,componentsPerAttribute:x,values:C}),l&&delete e.attributes.normal,p&&delete e.attributes.st,g&&delete e.attributes.bitangent,_&&delete e.attributes.tangent,e};const ee=new s.A;function te(e,t,n,i){s.A.add(e,s.A.multiplyByScalar(s.A.subtract(t,e,ee),e.y/(e.y-t.y),ee),n),s.A.clone(n,i),J(n,!0),J(i,!1)}const ne=new s.A,ie=new s.A,oe=new s.A,re=new s.A,ae={positions:new Array(7),indices:new Array(9)};function se(e,t,n){if(e.x>=0||t.x>=0||n.x>=0)return;!function(e,t,n){if(0!==e.y&&0!==t.y&&0!==n.y)return J(e,e.y<0),J(t,t.y<0),void J(n,n.y<0);const i=Math.abs(e.y),o=Math.abs(t.y),r=Math.abs(n.y);let a;a=i>o?i>r?b.A.sign(e.y):b.A.sign(n.y):o>r?b.A.sign(t.y):b.A.sign(n.y);const s=a<0;J(e,s),J(t,s),J(n,s)}(e,t,n);const i=e.y<0,o=t.y<0,r=n.y<0;let a=0;a+=i?1:0,a+=o?1:0,a+=r?1:0;const s=ae.indices;1===a?(s[1]=3,s[2]=4,s[5]=6,s[7]=6,s[8]=5,i?(te(e,t,ne,oe),te(e,n,ie,re),s[0]=0,s[3]=1,s[4]=2,s[6]=1):o?(te(t,n,ne,oe),te(t,e,ie,re),s[0]=1,s[3]=2,s[4]=0,s[6]=2):r&&(te(n,e,ne,oe),te(n,t,ie,re),s[0]=2,s[3]=0,s[4]=1,s[6]=0)):2===a&&(s[2]=4,s[4]=4,s[5]=3,s[7]=5,s[8]=6,i?o?r||(te(n,e,ne,oe),te(n,t,ie,re),s[0]=0,s[1]=1,s[3]=0,s[6]=2):(te(t,n,ne,oe),te(t,e,ie,re),s[0]=2,s[1]=0,s[3]=2,s[6]=1):(te(e,t,ne,oe),te(e,n,ie,re),s[0]=1,s[1]=2,s[3]=1,s[6]=0));const c=ae.positions;return c[0]=e,c[1]=t,c[2]=n,c.length=3,1!==a&&2!==a||(c[3]=ne,c[4]=ie,c[5]=oe,c[6]=re,c.length=7),ae}function ce(e,t){const n=e.attributes;if(0===n.position.values.length)return;for(const e in n)if(n.hasOwnProperty(e)&&(0,u.A)(n[e])&&(0,u.A)(n[e].values)){const t=n[e];t.values=h.A.createTypedArray(t.componentDatatype,t.values)}const i=f.A.computeNumberOfVertices(e);return e.indices=g.A.createTypedArray(i,e.indices),t&&(e.boundingSphere=r.A.fromVertices(n.position.values)),e}function le(e){const t=e.attributes,n={};for(const e in t)if(t.hasOwnProperty(e)&&(0,u.A)(t[e])&&(0,u.A)(t[e].values)){const i=t[e];n[e]=new A.A({componentDatatype:i.componentDatatype,componentsPerAttribute:i.componentsPerAttribute,normalize:i.normalize,values:[]})}return new f.A({attributes:n,indices:[],primitiveType:e.primitiveType})}function he(e,t,n){const i=(0,u.A)(e.geometry.boundingSphere);t=ce(t,i),n=ce(n,i),(0,u.A)(n)&&!(0,u.A)(t)?e.geometry=n:!(0,u.A)(n)&&(0,u.A)(t)?e.geometry=t:(e.westHemisphereGeometry=t,e.eastHemisphereGeometry=n,e.geometry=void 0)}function ue(e,t){const n=new e,i=new e,o=new e;return function(r,a,s,c,l,h,u,d){const p=e.fromArray(l,r*t,n),m=e.fromArray(l,a*t,i),f=e.fromArray(l,s*t,o);e.multiplyByScalar(p,c.x,p),e.multiplyByScalar(m,c.y,m),e.multiplyByScalar(f,c.z,f);const A=e.add(p,m,p);e.add(A,f,A),d&&e.normalize(A,A),e.pack(A,h,u*t)}}const de=ue(c.A,4),pe=ue(s.A,3),me=ue(a.A,2),fe=new s.A,Ae=new s.A,_e=new s.A,ge=new s.A;function ye(e,t,n,i,r,a,c,l,h,d,p,m,f,A,_,g){if(!((0,u.A)(a)||(0,u.A)(c)||(0,u.A)(l)||(0,u.A)(h)||(0,u.A)(d)||0!==A))return;const y=s.A.fromArray(r,3*e,fe),v=s.A.fromArray(r,3*t,Ae),w=s.A.fromArray(r,3*n,_e),T=(0,o.A)(i,y,v,w,ge);if((0,u.A)(T)){if((0,u.A)(a)&&pe(e,t,n,T,a,m.normal.values,g,!0),(0,u.A)(d)){const i=s.A.fromArray(d,3*e,fe),o=s.A.fromArray(d,3*t,Ae),r=s.A.fromArray(d,3*n,_e);let a;s.A.multiplyByScalar(i,T.x,i),s.A.multiplyByScalar(o,T.y,o),s.A.multiplyByScalar(r,T.z,r),s.A.equals(i,s.A.ZERO)&&s.A.equals(o,s.A.ZERO)&&s.A.equals(r,s.A.ZERO)?(a=fe,a.x=0,a.y=0,a.z=0):(a=s.A.add(i,o,i),s.A.add(a,r,a),s.A.normalize(a,a)),s.A.pack(a,m.extrudeDirection.values,3*g)}if((0,u.A)(p)&&function(e,t,n,i,o,r,a){const s=o[e]*i.x,c=o[t]*i.y,l=o[n]*i.z;r[a]=s+c+l>b.A.EPSILON6?1:0}(e,t,n,T,p,m.applyOffset.values,g),(0,u.A)(c)&&pe(e,t,n,T,c,m.tangent.values,g,!0),(0,u.A)(l)&&pe(e,t,n,T,l,m.bitangent.values,g,!0),(0,u.A)(h)&&me(e,t,n,T,h,m.st.values,g),A>0)for(let i=0;i<A;i++){const o=f[i];ve(e,t,n,T,g,_[o],m[o])}}}function ve(e,t,n,i,o,r,a){const s=r.componentsPerAttribute,c=r.values,l=a.values;switch(s){case 4:de(e,t,n,i,c,l,o,!1);break;case 3:pe(e,t,n,i,c,l,o,!1);break;case 2:me(e,t,n,i,c,l,o,!1);break;default:l[o]=c[e]*i.x+c[t]*i.y+c[n]*i.z}}function be(e,t,n,i,o,r){const a=e.position.values.length/3;if(-1!==o){const s=i[o],c=n[s];return-1===c?(n[s]=a,e.position.values.push(r.x,r.y,r.z),t.push(a),a):(t.push(c),c)}return e.position.values.push(r.x,r.y,r.z),t.push(a),a}const we={position:!0,normal:!0,bitangent:!0,tangent:!0,st:!0,extrudeDirection:!0,applyOffset:!0};function Te(e){const t=e.geometry,n=t.attributes,i=n.position.values,o=(0,u.A)(n.normal)?n.normal.values:void 0,r=(0,u.A)(n.bitangent)?n.bitangent.values:void 0,a=(0,u.A)(n.tangent)?n.tangent.values:void 0,c=(0,u.A)(n.st)?n.st.values:void 0,l=(0,u.A)(n.extrudeDirection)?n.extrudeDirection.values:void 0,h=(0,u.A)(n.applyOffset)?n.applyOffset.values:void 0,d=t.indices,p=[];for(const e in n)n.hasOwnProperty(e)&&!we[e]&&(0,u.A)(n[e])&&p.push(e);const m=p.length,f=le(t),A=le(t);let _,g,y,v,b;const w=[];w.length=i.length/3;const T=[];for(T.length=i.length/3,b=0;b<w.length;++b)w[b]=-1,T[b]=-1;const x=d.length;for(b=0;b<x;b+=3){const e=d[b],t=d[b+1],x=d[b+2];let C=s.A.fromArray(i,3*e),E=s.A.fromArray(i,3*t),S=s.A.fromArray(i,3*x);const D=se(C,E,S);if((0,u.A)(D)&&D.positions.length>3){const s=D.positions,u=D.indices,C=u.length;for(let E=0;E<C;++E){const C=u[E],S=s[C];S.y<0?(_=A.attributes,g=A.indices,y=w):(_=f.attributes,g=f.indices,y=T),v=be(_,g,y,d,C<3?b+C:-1,S),ye(e,t,x,S,i,o,a,r,c,l,h,_,p,m,n,v)}}else(0,u.A)(D)&&(C=D.positions[0],E=D.positions[1],S=D.positions[2]),C.y<0?(_=A.attributes,g=A.indices,y=w):(_=f.attributes,g=f.indices,y=T),v=be(_,g,y,d,b,C),ye(e,t,x,C,i,o,a,r,c,l,h,_,p,m,n,v),v=be(_,g,y,d,b+1,E),ye(e,t,x,E,i,o,a,r,c,l,h,_,p,m,n,v),v=be(_,g,y,d,b+2,S),ye(e,t,x,S,i,o,a,r,c,l,h,_,p,m,n,v)}he(e,A,f)}const xe=x.A.fromPointNormal(s.A.ZERO,s.A.UNIT_Y),Ce=new s.A,Ee=new s.A;function Se(e,t,n,i,o,r,a){if(!(0,u.A)(a))return;const c=s.A.fromArray(i,3*e,fe);s.A.equalsEpsilon(c,n,b.A.EPSILON10)?r.applyOffset.values[o]=a[e]:r.applyOffset.values[o]=a[t]}function De(e){const t=e.geometry,n=t.attributes,i=n.position.values,o=(0,u.A)(n.applyOffset)?n.applyOffset.values:void 0,r=t.indices,a=le(t),c=le(t);let l;const h=r.length,d=[];d.length=i.length/3;const p=[];for(p.length=i.length/3,l=0;l<d.length;++l)d[l]=-1,p[l]=-1;for(l=0;l<h;l+=2){const e=r[l],t=r[l+1],n=s.A.fromArray(i,3*e,fe),h=s.A.fromArray(i,3*t,Ae);let m;Math.abs(n.y)<b.A.EPSILON6&&(n.y<0?n.y=-b.A.EPSILON6:n.y=b.A.EPSILON6),Math.abs(h.y)<b.A.EPSILON6&&(h.y<0?h.y=-b.A.EPSILON6:h.y=b.A.EPSILON6);let f=a.attributes,A=a.indices,_=p,g=c.attributes,y=c.indices,w=d;const T=v.A.lineSegmentPlane(n,h,xe,_e);if((0,u.A)(T)){const u=s.A.multiplyByScalar(s.A.UNIT_Y,5*b.A.EPSILON9,Ce);n.y<0&&(s.A.negate(u,u),f=c.attributes,A=c.indices,_=d,g=a.attributes,y=a.indices,w=p);const v=s.A.add(T,u,Ee);m=be(f,A,_,r,l,n),Se(e,t,n,i,m,f,o),m=be(f,A,_,r,-1,v),Se(e,t,v,i,m,f,o),s.A.negate(u,u),s.A.add(T,u,v),m=be(g,y,w,r,-1,v),Se(e,t,v,i,m,g,o),m=be(g,y,w,r,l+1,h),Se(e,t,h,i,m,g,o)}else{let s,u,f;n.y<0?(s=c.attributes,u=c.indices,f=d):(s=a.attributes,u=a.indices,f=p),m=be(s,u,f,r,l,n),Se(e,t,n,i,m,s,o),m=be(s,u,f,r,l+1,h),Se(e,t,h,i,m,s,o)}}he(e,c,a)}const Oe=new a.A,ze=new a.A,Ie=new s.A,Pe=new s.A,Re=new s.A,Ne=new s.A,Le=new s.A,Me=new s.A,Fe=new c.A;function Be(e){const t=e.attributes,n=t.position.values,i=t.prevPosition.values,o=t.nextPosition.values,r=n.length;for(let e=0;e<r;e+=3){const t=s.A.unpack(n,e,Ie);if(t.x>0)continue;const a=s.A.unpack(i,e,Pe);(t.y<0&&a.y>0||t.y>0&&a.y<0)&&(e-3>0?(i[e]=n[e-3],i[e+1]=n[e-2],i[e+2]=n[e-1]):s.A.pack(t,i,e));const c=s.A.unpack(o,e,Re);(t.y<0&&c.y>0||t.y>0&&c.y<0)&&(e+3<r?(o[e]=n[e+3],o[e+1]=n[e+4],o[e+2]=n[e+5]):s.A.pack(t,o,e))}}const ke=5*b.A.EPSILON9,Ve=b.A.EPSILON6;S.splitLongitude=function(e){if(!(0,u.A)(e))throw new d.A("instance is required.");const t=e.geometry,n=t.boundingSphere;if((0,u.A)(n)&&(n.center.x-n.radius>0||r.A.intersectPlane(n,x.A.ORIGIN_ZX_PLANE)!==y.A.INTERSECTING))return e;if(t.geometryType!==_.A.NONE)switch(t.geometryType){case _.A.POLYLINES:!function(e){const t=e.geometry,n=t.attributes,i=n.position.values,o=n.prevPosition.values,r=n.nextPosition.values,l=n.expandAndWidth.values,h=(0,u.A)(n.st)?n.st.values:void 0,d=(0,u.A)(n.color)?n.color.values:void 0,p=le(t),m=le(t);let f,A,_,g=!1;const y=i.length/3;for(f=0;f<y;f+=4){const e=f,t=f+2,n=s.A.fromArray(i,3*e,Ie),y=s.A.fromArray(i,3*t,Pe);if(Math.abs(n.y)<Ve)for(n.y=Ve*(y.y<0?-1:1),i[3*f+1]=n.y,i[3*(f+1)+1]=n.y,A=3*e;A<3*e+12;A+=3)o[A]=i[3*f],o[A+1]=i[3*f+1],o[A+2]=i[3*f+2];if(Math.abs(y.y)<Ve)for(y.y=Ve*(n.y<0?-1:1),i[3*(f+2)+1]=y.y,i[3*(f+3)+1]=y.y,A=3*e;A<3*e+12;A+=3)r[A]=i[3*(f+2)],r[A+1]=i[3*(f+2)+1],r[A+2]=i[3*(f+2)+2];let w=p.attributes,T=p.indices,x=m.attributes,C=m.indices;const E=v.A.lineSegmentPlane(n,y,xe,Ne);if((0,u.A)(E)){g=!0;const i=s.A.multiplyByScalar(s.A.UNIT_Y,ke,Le);n.y<0&&(s.A.negate(i,i),w=m.attributes,T=m.indices,x=p.attributes,C=p.indices);const v=s.A.add(E,i,Me);w.position.values.push(n.x,n.y,n.z,n.x,n.y,n.z),w.position.values.push(v.x,v.y,v.z),w.position.values.push(v.x,v.y,v.z),w.prevPosition.values.push(o[3*e],o[3*e+1],o[3*e+2]),w.prevPosition.values.push(o[3*e+3],o[3*e+4],o[3*e+5]),w.prevPosition.values.push(n.x,n.y,n.z,n.x,n.y,n.z),w.nextPosition.values.push(v.x,v.y,v.z),w.nextPosition.values.push(v.x,v.y,v.z),w.nextPosition.values.push(v.x,v.y,v.z),w.nextPosition.values.push(v.x,v.y,v.z),s.A.negate(i,i),s.A.add(E,i,v),x.position.values.push(v.x,v.y,v.z),x.position.values.push(v.x,v.y,v.z),x.position.values.push(y.x,y.y,y.z,y.x,y.y,y.z),x.prevPosition.values.push(v.x,v.y,v.z),x.prevPosition.values.push(v.x,v.y,v.z),x.prevPosition.values.push(v.x,v.y,v.z),x.prevPosition.values.push(v.x,v.y,v.z),x.nextPosition.values.push(y.x,y.y,y.z,y.x,y.y,y.z),x.nextPosition.values.push(r[3*t],r[3*t+1],r[3*t+2]),x.nextPosition.values.push(r[3*t+3],r[3*t+4],r[3*t+5]);const S=a.A.fromArray(l,2*e,Oe),D=Math.abs(S.y);w.expandAndWidth.values.push(-1,D,1,D),w.expandAndWidth.values.push(-1,-D,1,-D),x.expandAndWidth.values.push(-1,D,1,D),x.expandAndWidth.values.push(-1,-D,1,-D);let O=s.A.magnitudeSquared(s.A.subtract(E,n,Re));if(O/=s.A.magnitudeSquared(s.A.subtract(y,n,Re)),(0,u.A)(d)){const n=c.A.fromArray(d,4*e,Fe),i=c.A.fromArray(d,4*t,Fe),o=b.A.lerp(n.x,i.x,O),r=b.A.lerp(n.y,i.y,O),a=b.A.lerp(n.z,i.z,O),s=b.A.lerp(n.w,i.w,O);for(A=4*e;A<4*e+8;++A)w.color.values.push(d[A]);for(w.color.values.push(o,r,a,s),w.color.values.push(o,r,a,s),x.color.values.push(o,r,a,s),x.color.values.push(o,r,a,s),A=4*t;A<4*t+8;++A)x.color.values.push(d[A])}if((0,u.A)(h)){const n=a.A.fromArray(h,2*e,Oe),i=a.A.fromArray(h,2*(f+3),ze),o=b.A.lerp(n.x,i.x,O);for(A=2*e;A<2*e+4;++A)w.st.values.push(h[A]);for(w.st.values.push(o,n.y),w.st.values.push(o,i.y),x.st.values.push(o,n.y),x.st.values.push(o,i.y),A=2*t;A<2*t+4;++A)x.st.values.push(h[A])}_=w.position.values.length/3-4,T.push(_,_+2,_+1),T.push(_+1,_+2,_+3),_=x.position.values.length/3-4,C.push(_,_+2,_+1),C.push(_+1,_+2,_+3)}else{let e,t;for(n.y<0?(e=m.attributes,t=m.indices):(e=p.attributes,t=p.indices),e.position.values.push(n.x,n.y,n.z),e.position.values.push(n.x,n.y,n.z),e.position.values.push(y.x,y.y,y.z),e.position.values.push(y.x,y.y,y.z),A=3*f;A<3*f+12;++A)e.prevPosition.values.push(o[A]),e.nextPosition.values.push(r[A]);for(A=2*f;A<2*f+8;++A)e.expandAndWidth.values.push(l[A]),(0,u.A)(h)&&e.st.values.push(h[A]);if((0,u.A)(d))for(A=4*f;A<4*f+16;++A)e.color.values.push(d[A]);_=e.position.values.length/3-4,t.push(_,_+2,_+1),t.push(_+1,_+2,_+3)}}g&&(Be(m),Be(p)),he(e,m,p)}(e);break;case _.A.TRIANGLES:Te(e);break;case _.A.LINES:De(e)}else(function(e){switch(e.primitiveType){case C.A.TRIANGLE_FAN:return function(e){const t=f.A.computeNumberOfVertices(e);if(t<3)throw new d.A("The number of vertices must be at least three.");const n=g.A.createTypedArray(t,3*(t-2));n[0]=1,n[1]=0,n[2]=2;let i=3;for(let e=3;e<t;++e)n[i++]=e-1,n[i++]=0,n[i++]=e;return e.indices=n,e.primitiveType=C.A.TRIANGLES,e}(e);case C.A.TRIANGLE_STRIP:return function(e){const t=f.A.computeNumberOfVertices(e);if(t<3)throw new d.A("The number of vertices must be at least 3.");const n=g.A.createTypedArray(t,3*(t-2));n[0]=0,n[1]=1,n[2]=2,t>3&&(n[3]=0,n[4]=2,n[5]=3);let i=6;for(let e=3;e<t-1;e+=2)n[i++]=e,n[i++]=e-1,n[i++]=e+1,e+2<t&&(n[i++]=e,n[i++]=e+1,n[i++]=e+2);return e.indices=n,e.primitiveType=C.A.TRIANGLES,e}(e);case C.A.TRIANGLES:return function(e){if((0,u.A)(e.indices))return e;const t=f.A.computeNumberOfVertices(e);if(t<3)throw new d.A("The number of vertices must be at least three.");if(t%3!=0)throw new d.A("The number of vertices must be a multiple of three.");const n=g.A.createTypedArray(t,t);for(let e=0;e<t;++e)n[e]=e;return e.indices=n,e}(e);case C.A.LINE_STRIP:return function(e){const t=f.A.computeNumberOfVertices(e);if(t<2)throw new d.A("The number of vertices must be at least two.");const n=g.A.createTypedArray(t,2*(t-1));n[0]=0,n[1]=1;let i=2;for(let e=2;e<t;++e)n[i++]=e-1,n[i++]=e;return e.indices=n,e.primitiveType=C.A.LINES,e}(e);case C.A.LINE_LOOP:return function(e){const t=f.A.computeNumberOfVertices(e);if(t<2)throw new d.A("The number of vertices must be at least two.");const n=g.A.createTypedArray(t,2*t);n[0]=0,n[1]=1;let i=2;for(let e=2;e<t;++e)n[i++]=e-1,n[i++]=e;return n[i++]=t-1,n[i]=0,e.indices=n,e.primitiveType=C.A.LINES,e}(e);case C.A.LINES:return function(e){if((0,u.A)(e.indices))return e;const t=f.A.computeNumberOfVertices(e);if(t<2)throw new d.A("The number of vertices must be at least two.");if(t%2!=0)throw new d.A("The number of vertices must be a multiple of 2.");const n=g.A.createTypedArray(t,t);for(let e=0;e<t;++e)n[e]=e;return e.indices=n,e}(e)}})(t),t.primitiveType===C.A.TRIANGLES?Te(e):t.primitiveType===C.A.LINES&&De(e);return e};const Ge=S},597751:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i=Object.freeze({NONE:0,TRIANGLES:1,LINES:2,POLYLINES:3})},974904:(e,t,n)=>{"use strict";n.d(t,{A:()=>et});var i=n(564886),o=n(215327),r=n(263604),a=n(660662),s=n(267980),c=n(336946),l=n(369031),h=n(571804),u=n(915325),d=n(491446),p=n(605971),m=n(610750),f=n(602289),A=n(551824),_=n(816422),g=n(653577),y=n(944479),v=n(305439),b=n(150429),w=n(367817),T=n(331185),x=n(257941),C=n(99479),E=n(697422),S=n(414305);const D=[g.A,S.A],O=D.length,z=Math.cos(w.A.toRadians(30)),I=Math.cos(w.A.toRadians(150));function P(e){const t=(e=e??u.A.EMPTY_OBJECT).positions;if(!(0,d.A)(t)||t.length<2)throw new p.A("At least two positions are required.");if((0,d.A)(e.arcType)&&e.arcType!==o.A.GEODESIC&&e.arcType!==o.A.RHUMB)throw new p.A("Valid options for arcType are ArcType.GEODESIC and ArcType.RHUMB.");this.width=e.width??1,this._positions=t,this.granularity=e.granularity??9999,this.loop=e.loop??!1,this.arcType=e.arcType??o.A.GEODESIC,this._ellipsoid=m.A.default,this._projectionIndex=0,this._workerName="createGroundPolylineGeometry",this._scene3DOnly=!1}Object.defineProperties(P.prototype,{packedLength:{get:function(){return 1+3*this._positions.length+1+1+1+m.A.packedLength+1+1}}}),P.setProjectionAndEllipsoid=function(e,t){let n=0;for(let e=0;e<O;e++)if(t instanceof D[e]){n=e;break}e._projectionIndex=n,e._ellipsoid=t.ellipsoid};const R=new s.A,N=new s.A,L=new s.A;function M(e,t,n,i,o){const r=U(i,e,0,R),a=U(i,e,n,N),c=U(i,t,0,L),l=W(a,r,N),h=W(c,r,L);return s.A.cross(h,l,o),s.A.normalize(o,o)}const F=new c.A,B=new s.A,k=new s.A,V=new s.A;function G(e,t,n,i,r,a,c,l,h,u,d){if(0===r)return;let p;a===o.A.GEODESIC?p=new f.A(e,t,c):a===o.A.RHUMB&&(p=new A.A(e,t,c));const m=p.surfaceDistance;if(m<r)return;const _=M(e,t,i,c,V),g=Math.ceil(m/r),y=m/g;let v=y;const b=g-1;let w=l.length;for(let e=0;e<b;e++){const e=p.interpolateUsingSurfaceDistance(v,F),t=U(c,e,n,B),o=U(c,e,i,k);s.A.pack(_,l,w),s.A.pack(t,h,w),s.A.pack(o,u,w),d.push(e.latitude),d.push(e.longitude),w+=3,v+=y}}const H=new c.A;function U(e,t,n,i){return c.A.clone(t,H),H.height=n,c.A.toCartesian(H,e,i)}function W(e,t,n){return s.A.subtract(e,t,n),s.A.normalize(n,n),n}function q(e,t,n,i){return i=W(e,t,i),i=s.A.cross(i,n,i),i=s.A.normalize(i,i),s.A.cross(n,i,i)}P.pack=function(e,t,n){l.A.typeOf.object("value",e),l.A.defined("array",t);let i=n??0;const o=e._positions,r=o.length;t[i++]=r;for(let e=0;e<r;++e){const n=o[e];s.A.pack(n,t,i),i+=3}return t[i++]=e.granularity,t[i++]=e.loop?1:0,t[i++]=e.arcType,m.A.pack(e._ellipsoid,t,i),i+=m.A.packedLength,t[i++]=e._projectionIndex,t[i++]=e._scene3DOnly?1:0,t},P.unpack=function(e,t,n){l.A.defined("array",e);let i=t??0;const o=e[i++],r=new Array(o);for(let t=0;t<o;t++)r[t]=s.A.unpack(e,i),i+=3;const a=e[i++],c=1===e[i++],h=e[i++],u=m.A.unpack(e,i);i+=m.A.packedLength;const p=e[i++],f=1===e[i++];return(0,d.A)(n)||(n=new P({positions:r})),n._positions=r,n.granularity=a,n.loop=c,n.arcType=h,n._ellipsoid=u,n._projectionIndex=p,n._scene3DOnly=f,n};const j=new s.A,Y=new s.A,X=new s.A,$=new s.A;function Z(e,t,n,i,o){const r=W(n,t,$),a=q(e,t,r,j),c=q(i,t,r,Y);if(w.A.equalsEpsilon(s.A.dot(a,c),-1,w.A.EPSILON5))return o=s.A.cross(r,a,o),s.A.normalize(o,o);o=s.A.add(c,a,o),o=s.A.normalize(o,o);const l=s.A.cross(r,o,X);return s.A.dot(c,l)<0&&(o=s.A.negate(o,o)),o}const K=x.A.fromPointNormal(s.A.ZERO,s.A.UNIT_Y),Q=new s.A,J=new s.A,ee=new s.A,te=new s.A,ne=new s.A,ie=new s.A,oe=new c.A,re=new c.A,ae=new c.A;P.createGeometry=function(e){const t=!e._scene3DOnly;let n=e.loop;const l=e._ellipsoid,u=e.granularity,p=e.arcType,m=new D[e._projectionIndex](l),f=1e3;let g,T;const x=e._positions,C=x.length;let S,O,I,P;2===C&&(n=!1);const R=new A.A(void 0,void 0,l);let N,L,F;const B=[x[0]];for(T=0;T<C-1;T++)S=x[T],O=x[T+1],N=b.A.lineSegmentPlane(S,O,K,ie),!(0,d.A)(N)||s.A.equalsEpsilon(N,S,w.A.EPSILON7)||s.A.equalsEpsilon(N,O,w.A.EPSILON7)||(e.arcType===o.A.GEODESIC?B.push(s.A.clone(N)):e.arcType===o.A.RHUMB&&(F=l.cartesianToCartographic(N,oe).longitude,I=l.cartesianToCartographic(S,oe),P=l.cartesianToCartographic(O,re),R.setEndPoints(I,P),L=R.findIntersectionWithLongitude(F,ae),N=l.cartographicToCartesian(L,ie),!(0,d.A)(N)||s.A.equalsEpsilon(N,S,w.A.EPSILON7)||s.A.equalsEpsilon(N,O,w.A.EPSILON7)||B.push(s.A.clone(N)))),B.push(O);n&&(S=x[C-1],O=x[0],N=b.A.lineSegmentPlane(S,O,K,ie),!(0,d.A)(N)||s.A.equalsEpsilon(N,S,w.A.EPSILON7)||s.A.equalsEpsilon(N,O,w.A.EPSILON7)||(e.arcType===o.A.GEODESIC?B.push(s.A.clone(N)):e.arcType===o.A.RHUMB&&(F=l.cartesianToCartographic(N,oe).longitude,I=l.cartesianToCartographic(S,oe),P=l.cartesianToCartographic(O,re),R.setEndPoints(I,P),L=R.findIntersectionWithLongitude(F,ae),N=l.cartographicToCartesian(L,ie),!(0,d.A)(N)||s.A.equalsEpsilon(N,S,w.A.EPSILON7)||s.A.equalsEpsilon(N,O,w.A.EPSILON7)||B.push(s.A.clone(N)))));let k=B.length,V=new Array(k);for(T=0;T<k;T++){const e=c.A.fromCartesian(B[T],l);e.height=0,V[T]=e}if(V=(0,r.A)(V,c.A.equalsEpsilon),k=V.length,k<2)return;const H=[],q=[],j=[],Y=[];let X=Q,$=J,se=ee,ce=te,le=ne;const ue=V[0],de=V[1];for(X=U(l,V[k-1],0,X),ce=U(l,de,0,ce),$=U(l,ue,0,$),se=U(l,ue,f,se),le=n?Z(X,$,se,ce,le):M(ue,de,f,l,le),s.A.pack(le,q,0),s.A.pack($,j,0),s.A.pack(se,Y,0),H.push(ue.latitude),H.push(ue.longitude),G(ue,de,0,f,u,p,l,q,j,Y,H),T=1;T<k-1;++T){X=s.A.clone($,X),$=s.A.clone(ce,$);const e=V[T];U(l,e,f,se),U(l,V[T+1],0,ce),Z(X,$,se,ce,le),g=q.length,s.A.pack(le,q,g),s.A.pack($,j,g),s.A.pack(se,Y,g),H.push(e.latitude),H.push(e.longitude),G(V[T],V[T+1],0,f,u,p,l,q,j,Y,H)}const pe=V[k-1],fe=V[k-2];if($=U(l,pe,0,$),se=U(l,pe,f,se),n){const e=V[0];X=U(l,fe,0,X),ce=U(l,e,0,ce),le=Z(X,$,se,ce,le)}else le=M(fe,pe,f,l,le);if(g=q.length,s.A.pack(le,q,g),s.A.pack($,j,g),s.A.pack(se,Y,g),H.push(pe.latitude),H.push(pe.longitude),n){for(G(pe,ue,0,f,u,p,l,q,j,Y,H),g=q.length,T=0;T<3;++T)q[g+T]=q[T],j[g+T]=j[T],Y[g+T]=Y[T];H.push(ue.latitude),H.push(ue.longitude)}return function(e,t,n,o,r,c,l){let u,d;const p=t._ellipsoid,m=n.length/3-1,f=8*m,A=4*f,g=36*m,b=f>65535?new Uint32Array(g):new Uint16Array(g),T=new Float64Array(3*f),x=new Float32Array(A),C=new Float32Array(A),S=new Float32Array(A),D=new Float32Array(A),O=new Float32Array(A);let I,P,R,N;l&&(I=new Float32Array(A),P=new Float32Array(A),R=new Float32Array(A),N=new Float32Array(2*f));const L=c.length/2;let M=0;const F=be;F.height=0;const B=we;B.height=0;let k=Te,V=xe;if(l)for(d=0,u=1;u<L;u++)F.latitude=c[d],F.longitude=c[d+1],B.latitude=c[d+2],B.longitude=c[d+3],k=t.project(F,k),V=t.project(B,V),M+=s.A.distance(k,V),d+=2;const G=o.length/3;V=s.A.unpack(o,0,V);let H,U=0;for(d=3,u=1;u<G;u++)k=s.A.clone(V,k),V=s.A.unpack(o,d,V),U+=s.A.distance(k,V),d+=3;d=3;let q=0,j=0,Y=0,X=0,$=!1,Z=s.A.unpack(n,0,Ee),K=s.A.unpack(o,0,xe),Q=s.A.unpack(r,0,De);e&&he(Q,s.A.unpack(n,n.length-6,Ce),Z,K)&&(Q=s.A.negate(Q,Q));let J=0,ee=0,te=0;for(u=0;u<m;u++){const e=s.A.clone(Z,Ce),a=s.A.clone(K,Te);let h,u,m,f,A=s.A.clone(Q,Se);if($&&(A=s.A.negate(A,A)),Z=s.A.unpack(n,d,Ee),K=s.A.unpack(o,d,xe),Q=s.A.unpack(r,d,De),$=he(Q,e,Z,K),F.latitude=c[q],F.longitude=c[q+1],B.latitude=c[q+2],B.longitude=c[q+3],l){const e=ve(F,B);h=t.project(F,Le),u=t.project(B,Me);const n=W(u,h,Ye);n.y=Math.abs(n.y),m=Fe,f=Be,0===e||s.A.dot(n,s.A.UNIT_Y)>z?(m=me(t,F,A,h,Fe),f=me(t,B,Q,u,Be)):1===e?(f=me(t,B,Q,u,Be),m.x=0,m.y=w.A.sign(F.longitude-Math.abs(B.longitude)),m.z=0):(m=me(t,F,A,h,Fe),f.x=0,f.y=w.A.sign(F.longitude-B.longitude),f.z=0)}const g=s.A.distance(a,K),y=_.A.fromCartesian(e,qe),v=s.A.subtract(Z,e,ke),b=s.A.normalize(v,He);let L=s.A.subtract(a,e,Ve);L=s.A.normalize(L,L);let k=s.A.cross(b,L,He);k=s.A.normalize(k,k);let V=s.A.cross(L,A,Ue);V=s.A.normalize(V,V);let G=s.A.subtract(K,Z,Ge);G=s.A.normalize(G,G);let ne=s.A.cross(Q,G,We);ne=s.A.normalize(ne,ne);const ie=g/U,oe=J/U;let re,ae,se,ce=0,le=0,ue=0;if(l){ce=s.A.distance(h,u),re=_.A.fromCartesian(h,je),ae=s.A.subtract(u,h,Ye),se=s.A.normalize(ae,Xe);const e=se.x;se.x=se.y,se.y=-e,le=ce/M,ue=ee/M}for(H=0;H<8;H++){const e=X+4*H,t=j+2*H,n=e+3,i=H<4?1:-1,o=2===H||3===H||6===H||7===H?1:-1;s.A.pack(y.high,x,e),x[n]=v.x,s.A.pack(y.low,C,e),C[n]=v.y,s.A.pack(V,S,e),S[n]=v.z,s.A.pack(ne,D,e),D[n]=ie*i,s.A.pack(k,O,e);let r=oe*o;0===r&&o<0&&(r=9),O[n]=r,l&&(I[e]=re.high.x,I[e+1]=re.high.y,I[e+2]=re.low.x,I[e+3]=re.low.y,R[e]=-m.y,R[e+1]=m.x,R[e+2]=f.y,R[e+3]=-f.x,P[e]=ae.x,P[e+1]=ae.y,P[e+2]=se.x,P[e+3]=se.y,N[t]=le*i,r=ue*o,0===r&&o<0&&(r=9),N[t+1]=r)}const de=Re,pe=Ne,fe=Ie,Ae=Pe,ge=E.A.fromCartographicArray(Oe,ze),be=i.A.getMinimumMaximumHeights(ge,p),we=be.minimumTerrainHeight,Ze=be.maximumTerrainHeight;te+=Math.abs(we),te+=Math.abs(Ze),_e(e,a,we,Ze,de,fe),_e(Z,K,we,Ze,pe,Ae);let Ke=s.A.multiplyByScalar(k,w.A.EPSILON5,$e);s.A.add(de,Ke,de),s.A.add(pe,Ke,pe),s.A.add(fe,Ke,fe),s.A.add(Ae,Ke,Ae),ye(de,pe),ye(fe,Ae),s.A.pack(de,T,Y),s.A.pack(pe,T,Y+3),s.A.pack(Ae,T,Y+6),s.A.pack(fe,T,Y+9),Ke=s.A.multiplyByScalar(k,-2*w.A.EPSILON5,$e),s.A.add(de,Ke,de),s.A.add(pe,Ke,pe),s.A.add(fe,Ke,fe),s.A.add(Ae,Ke,Ae),ye(de,pe),ye(fe,Ae),s.A.pack(de,T,Y+12),s.A.pack(pe,T,Y+15),s.A.pack(Ae,T,Y+18),s.A.pack(fe,T,Y+21),q+=2,d+=3,j+=16,Y+=24,X+=32,J+=g,ee+=ce}d=0;let ne=0;for(u=0;u<m;u++){for(H=0;H<Qe;H++)b[d+H]=Ke[H]+ne;ne+=8,d+=Qe}const ie=Ze;a.A.fromVertices(n,s.A.ZERO,3,ie[0]),a.A.fromVertices(o,s.A.ZERO,3,ie[1]);const oe=a.A.fromBoundingSpheres(ie);oe.radius+=te/(2*m);const re={position:new v.A({componentDatatype:h.A.DOUBLE,componentsPerAttribute:3,normalize:!1,values:T}),startHiAndForwardOffsetX:Je(x),startLoAndForwardOffsetY:Je(C),startNormalAndForwardOffsetZ:Je(S),endNormalAndTextureCoordinateNormalizationX:Je(D),rightNormalAndTextureCoordinateNormalizationY:Je(O)};return l&&(re.startHiLo2D=Je(I),re.offsetAndRight2D=Je(P),re.startEndNormals2D=Je(R),re.texcoordNormalization2D=new v.A({componentDatatype:h.A.FLOAT,componentsPerAttribute:2,normalize:!1,values:N})),new y.A({attributes:re,indices:b,boundingSphere:oe})}(n,m,j,Y,q,H,t)};const se=new s.A,ce=new T.A,le=new C.A;function he(e,t,n,i){const o=W(n,t,se),r=s.A.dot(o,e);if(r>z||r<I){const t=W(i,n,$),o=r<I?w.A.PI_OVER_TWO:-w.A.PI_OVER_TWO,a=C.A.fromAxisAngle(t,o,le),s=T.A.fromQuaternion(a,ce);return T.A.multiplyByVector(s,e,e),!0}return!1}const ue=new c.A,de=new s.A,pe=new s.A;function me(e,t,n,i,o){const r=c.A.toCartesian(t,e._ellipsoid,de);let a=s.A.add(r,n,pe),l=!1;const h=e._ellipsoid;let u=h.cartesianToCartographic(a,ue);Math.abs(t.longitude-u.longitude)>w.A.PI_OVER_TWO&&(l=!0,a=s.A.subtract(r,n,pe),u=h.cartesianToCartographic(a,ue)),u.height=0;const d=e.project(u,o);return(o=s.A.subtract(d,i,o)).z=0,o=s.A.normalize(o,o),l&&s.A.negate(o,o),o}const fe=new s.A,Ae=new s.A;function _e(e,t,n,i,o,r){const a=s.A.subtract(t,e,fe);s.A.normalize(a,a);const c=n-0;let l=s.A.multiplyByScalar(a,c,Ae);s.A.add(e,l,o);const h=i-1e3;l=s.A.multiplyByScalar(a,h,Ae),s.A.add(t,l,r)}const ge=new s.A;function ye(e,t){const n=x.A.getPointDistance(K,e),i=x.A.getPointDistance(K,t);let o=ge;w.A.equalsEpsilon(n,0,w.A.EPSILON2)?(o=W(t,e,o),s.A.multiplyByScalar(o,w.A.EPSILON2,o),s.A.add(e,o,e)):w.A.equalsEpsilon(i,0,w.A.EPSILON2)&&(o=W(e,t,o),s.A.multiplyByScalar(o,w.A.EPSILON2,o),s.A.add(t,o,t))}function ve(e,t){const n=Math.abs(e.longitude),i=Math.abs(t.longitude);if(w.A.equalsEpsilon(n,w.A.PI,w.A.EPSILON11)){const i=w.A.sign(t.longitude);return e.longitude=i*(n-w.A.EPSILON11),1}if(w.A.equalsEpsilon(i,w.A.PI,w.A.EPSILON11)){const n=w.A.sign(e.longitude);return t.longitude=n*(i-w.A.EPSILON11),2}return 0}const be=new c.A,we=new c.A,Te=new s.A,xe=new s.A,Ce=new s.A,Ee=new s.A,Se=new s.A,De=new s.A,Oe=[be,we],ze=new E.A,Ie=new s.A,Pe=new s.A,Re=new s.A,Ne=new s.A,Le=new s.A,Me=new s.A,Fe=new s.A,Be=new s.A,ke=new s.A,Ve=new s.A,Ge=new s.A,He=new s.A,Ue=new s.A,We=new s.A,qe=new _.A,je=new _.A,Ye=new s.A,Xe=new s.A,$e=new s.A,Ze=[new a.A,new a.A],Ke=[0,2,1,0,3,2,0,7,3,0,4,7,0,5,4,0,1,5,5,7,4,5,6,7,5,2,6,5,1,2,3,6,2,3,7,6],Qe=Ke.length;function Je(e){return new v.A({componentDatatype:h.A.FLOAT,componentsPerAttribute:4,normalize:!1,values:e})}P._projectNormal=me;const et=P},874915:(e,t,n)=>{"use strict";n.d(t,{A:()=>c});var i=n(491446),o=n(605971),r=n(367817),a=n(352581);const s={UNSIGNED_BYTE:a.A.UNSIGNED_BYTE,UNSIGNED_SHORT:a.A.UNSIGNED_SHORT,UNSIGNED_INT:a.A.UNSIGNED_INT,getSizeInBytes:function(e){switch(e){case s.UNSIGNED_BYTE:return Uint8Array.BYTES_PER_ELEMENT;case s.UNSIGNED_SHORT:return Uint16Array.BYTES_PER_ELEMENT;case s.UNSIGNED_INT:return Uint32Array.BYTES_PER_ELEMENT}throw new o.A("indexDatatype is required and must be a valid IndexDatatype constant.")},fromSizeInBytes:function(e){switch(e){case 2:return s.UNSIGNED_SHORT;case 4:return s.UNSIGNED_INT;case 1:return s.UNSIGNED_BYTE;default:throw new o.A("Size in bytes cannot be mapped to an IndexDatatype")}},validate:function(e){return(0,i.A)(e)&&(e===s.UNSIGNED_BYTE||e===s.UNSIGNED_SHORT||e===s.UNSIGNED_INT)},createTypedArray:function(e,t){if(!(0,i.A)(e))throw new o.A("numberOfVertices is required.");return e>=r.A.SIXTY_FOUR_KILOBYTES?new Uint32Array(t):new Uint16Array(t)},createTypedArrayFromArrayBuffer:function(e,t,n,a){if(!(0,i.A)(e))throw new o.A("numberOfVertices is required.");if(!(0,i.A)(t))throw new o.A("sourceArray is required.");if(!(0,i.A)(n))throw new o.A("byteOffset is required.");return e>=r.A.SIXTY_FOUR_KILOBYTES?new Uint32Array(t,n,a):new Uint16Array(t,n,a)},fromTypedArray:function(e){if(e instanceof Uint8Array)return s.UNSIGNED_BYTE;if(e instanceof Uint16Array)return s.UNSIGNED_SHORT;if(e instanceof Uint32Array)return s.UNSIGNED_INT;throw new o.A("array must be a Uint8Array, Uint16Array, or Uint32Array.")}},c=Object.freeze(s)},647326:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i=Object.freeze({OUTSIDE:-1,INTERSECTING:0,INSIDE:1})},150429:(e,t,n)=>{"use strict";n.d(t,{A:()=>H});var i=n(267980),o=n(336946),r=n(491446),a=n(605971),s=n(33914),c=n(367817),l=n(331185),h=n(118135),u=n(173866),d=n(766067);const p={rayPlane:function(e,t,n){if(!(0,r.A)(e))throw new a.A("ray is required.");if(!(0,r.A)(t))throw new a.A("plane is required.");(0,r.A)(n)||(n=new i.A);const o=e.origin,s=e.direction,l=t.normal,h=i.A.dot(l,s);if(Math.abs(h)<c.A.EPSILON15)return;const u=(-t.distance-i.A.dot(l,o))/h;return u<0?void 0:(n=i.A.multiplyByScalar(s,u,n),i.A.add(o,n,n))}},m=new i.A,f=new i.A,A=new i.A,_=new i.A,g=new i.A;p.rayTriangleParametric=function(e,t,n,o,s){if(!(0,r.A)(e))throw new a.A("ray is required.");if(!(0,r.A)(t))throw new a.A("p0 is required.");if(!(0,r.A)(n))throw new a.A("p1 is required.");if(!(0,r.A)(o))throw new a.A("p2 is required.");s=s??!1;const l=e.origin,h=e.direction,u=i.A.subtract(n,t,m),d=i.A.subtract(o,t,f),p=i.A.cross(h,d,A),y=i.A.dot(u,p);let v,b,w,T,x;if(s){if(y<c.A.EPSILON6)return;if(v=i.A.subtract(l,t,_),w=i.A.dot(v,p),w<0||w>y)return;if(b=i.A.cross(v,u,g),T=i.A.dot(h,b),T<0||w+T>y)return;x=i.A.dot(d,b)/y}else{if(Math.abs(y)<c.A.EPSILON6)return;const e=1/y;if(v=i.A.subtract(l,t,_),w=i.A.dot(v,p)*e,w<0||w>1)return;if(b=i.A.cross(v,u,g),T=i.A.dot(h,b)*e,T<0||w+T>1)return;x=i.A.dot(d,b)*e}return x},p.rayTriangle=function(e,t,n,o,a,s){const c=p.rayTriangleParametric(e,t,n,o,a);if((0,r.A)(c)&&!(c<0))return(0,r.A)(s)||(s=new i.A),i.A.multiplyByScalar(e.direction,c,s),i.A.add(e.origin,s,s)};const y=new d.A;p.lineSegmentTriangle=function(e,t,n,o,s,c,l){if(!(0,r.A)(e))throw new a.A("v0 is required.");if(!(0,r.A)(t))throw new a.A("v1 is required.");if(!(0,r.A)(n))throw new a.A("p0 is required.");if(!(0,r.A)(o))throw new a.A("p1 is required.");if(!(0,r.A)(s))throw new a.A("p2 is required.");const h=y;i.A.clone(e,h.origin),i.A.subtract(t,e,h.direction),i.A.normalize(h.direction,h.direction);const u=p.rayTriangleParametric(h,n,o,s,c);if(!(!(0,r.A)(u)||u<0||u>i.A.distance(e,t)))return(0,r.A)(l)||(l=new i.A),i.A.multiplyByScalar(h.direction,u,l),i.A.add(h.origin,l,l)};const v={root0:0,root1:0};function b(e,t,n){(0,r.A)(n)||(n=new s.A);const o=e.origin,a=e.direction,c=t.center,l=t.radius*t.radius,h=i.A.subtract(o,c,A),u=function(e,t,n,i){const o=t*t-4*e*n;if(o<0)return;if(o>0){const n=1/(2*e),r=Math.sqrt(o),a=(-t+r)*n,s=(-t-r)*n;return a<s?(i.root0=a,i.root1=s):(i.root0=s,i.root1=a),i}const r=-t/(2*e);return 0!==r?(i.root0=i.root1=r,i):void 0}(i.A.dot(a,a),2*i.A.dot(a,h),i.A.magnitudeSquared(h)-l,v);if((0,r.A)(u))return n.start=u.root0,n.stop=u.root1,n}p.raySphere=function(e,t,n){if(!(0,r.A)(e))throw new a.A("ray is required.");if(!(0,r.A)(t))throw new a.A("sphere is required.");if(n=b(e,t,n),(0,r.A)(n)&&!(n.stop<0))return n.start=Math.max(n.start,0),n};const w=new d.A;p.lineSegmentSphere=function(e,t,n,o){if(!(0,r.A)(e))throw new a.A("p0 is required.");if(!(0,r.A)(t))throw new a.A("p1 is required.");if(!(0,r.A)(n))throw new a.A("sphere is required.");const s=w;i.A.clone(e,s.origin);const c=i.A.subtract(t,e,s.direction),l=i.A.magnitude(c);if(i.A.normalize(c,c),o=b(s,n,o),!(!(0,r.A)(o)||o.stop<0||o.start>l))return o.start=Math.max(o.start,0),o.stop=Math.min(o.stop,l),o};const T=new i.A,x=new i.A;function C(e,t,n){const i=e+t;return c.A.sign(e)!==c.A.sign(t)&&Math.abs(i/Math.max(Math.abs(e),Math.abs(t)))<n?0:i}p.rayEllipsoid=function(e,t){if(!(0,r.A)(e))throw new a.A("ray is required.");if(!(0,r.A)(t))throw new a.A("ellipsoid is required.");const n=t.oneOverRadii,o=i.A.multiplyComponents(n,e.origin,T),c=i.A.multiplyComponents(n,e.direction,x),l=i.A.magnitudeSquared(o),h=i.A.dot(o,c);let u,d,p,m,f;if(l>1){if(h>=0)return;const e=h*h;if(u=l-1,d=i.A.magnitudeSquared(c),p=d*u,e<p)return;if(e>p){m=h*h-p,f=-h+Math.sqrt(m);const e=f/d,t=u/f;return e<t?new s.A(e,t):{start:t,stop:e}}const t=Math.sqrt(u/d);return new s.A(t,t)}return l<1?(u=l-1,d=i.A.magnitudeSquared(c),p=d*u,m=h*h-p,f=-h+Math.sqrt(m),new s.A(0,f/d)):h<0?(d=i.A.magnitudeSquared(c),new s.A(0,-h/d)):void 0},p.quadraticVectorExpression=function(e,t,n,o,r){const a=o*o,s=r*r,d=(e[l.A.COLUMN1ROW1]-e[l.A.COLUMN2ROW2])*s,p=r*(o*C(e[l.A.COLUMN1ROW0],e[l.A.COLUMN0ROW1],c.A.EPSILON15)+t.y),m=e[l.A.COLUMN0ROW0]*a+e[l.A.COLUMN2ROW2]*s+o*t.x+n,f=s*C(e[l.A.COLUMN2ROW1],e[l.A.COLUMN1ROW2],c.A.EPSILON15),A=r*(o*C(e[l.A.COLUMN2ROW0],e[l.A.COLUMN0ROW2])+t.z);let _;const g=[];if(0===A&&0===f){if(_=h.A.computeRealRoots(d,p,m),0===_.length)return g;const e=_[0],t=Math.sqrt(Math.max(1-e*e,0));if(g.push(new i.A(o,r*e,r*-t)),g.push(new i.A(o,r*e,r*t)),2===_.length){const e=_[1],t=Math.sqrt(Math.max(1-e*e,0));g.push(new i.A(o,r*e,r*-t)),g.push(new i.A(o,r*e,r*t))}return g}const y=A*A,v=f*f,b=A*f,w=d*d+v,T=2*(p*d+b),x=2*m*d+p*p-v+y,E=2*(m*p-b),S=m*m-y;if(0===w&&0===T&&0===x&&0===E)return g;_=u.A.computeRealRoots(w,T,x,E,S);const D=_.length;if(0===D)return g;for(let e=0;e<D;++e){const t=_[e],n=t*t,a=Math.max(1-n,0),s=Math.sqrt(a);let l;l=c.A.sign(d)===c.A.sign(m)?C(d*n+m,p*t,c.A.EPSILON12):c.A.sign(m)===c.A.sign(p*t)?C(d*n,p*t+m,c.A.EPSILON12):C(d*n+p*t,m,c.A.EPSILON12);const h=l*C(f*t,A,c.A.EPSILON15);h<0?g.push(new i.A(o,r*t,r*s)):h>0?g.push(new i.A(o,r*t,r*-s)):0!==s?(g.push(new i.A(o,r*t,r*-s)),g.push(new i.A(o,r*t,r*s)),++e):g.push(new i.A(o,r*t,r*s))}return g};const E=new i.A,S=new i.A,D=new i.A,O=new i.A,z=new i.A,I=new l.A,P=new l.A,R=new l.A,N=new l.A,L=new l.A,M=new l.A,F=new l.A,B=new i.A,k=new i.A,V=new o.A;p.grazingAltitudeLocation=function(e,t){if(!(0,r.A)(e))throw new a.A("ray is required.");if(!(0,r.A)(t))throw new a.A("ellipsoid is required.");const n=e.origin,o=e.direction;if(!i.A.equals(n,i.A.ZERO)){const e=t.geodeticSurfaceNormal(n,E);if(i.A.dot(o,e)>=0)return n}const s=(0,r.A)(this.rayEllipsoid(e,t)),h=t.transformPositionToScaledSpace(o,E),u=i.A.normalize(h,h),d=i.A.mostOrthogonalAxis(h,O),m=i.A.normalize(i.A.cross(d,u,S),S),f=i.A.normalize(i.A.cross(u,m,D),D),A=I;A[0]=u.x,A[1]=u.y,A[2]=u.z,A[3]=m.x,A[4]=m.y,A[5]=m.z,A[6]=f.x,A[7]=f.y,A[8]=f.z;const _=l.A.transpose(A,P),g=l.A.fromScale(t.radii,R),y=l.A.fromScale(t.oneOverRadii,N),v=L;v[0]=0,v[1]=-o.z,v[2]=o.y,v[3]=o.z,v[4]=0,v[5]=-o.x,v[6]=-o.y,v[7]=o.x,v[8]=0;const b=l.A.multiply(l.A.multiply(_,y,M),v,M),w=l.A.multiply(l.A.multiply(b,g,F),A,F),T=l.A.multiplyByVector(b,n,z),x=p.quadraticVectorExpression(w,i.A.negate(T,E),0,0,1);let C,G;const H=x.length;if(H>0){let e=i.A.clone(i.A.ZERO,k),r=Number.NEGATIVE_INFINITY;for(let t=0;t<H;++t){C=l.A.multiplyByVector(g,l.A.multiplyByVector(A,x[t],B),B);const a=i.A.normalize(i.A.subtract(C,n,O),O),s=i.A.dot(a,o);s>r&&(r=s,e=i.A.clone(C,e))}const a=t.cartesianToCartographic(e,V);return r=c.A.clamp(r,0,1),G=i.A.magnitude(i.A.subtract(e,n,O))*Math.sqrt(1-r*r),G=s?-G:G,a.height=G,t.cartographicToCartesian(a,new i.A)}};const G=new i.A;p.lineSegmentPlane=function(e,t,n,o){if(!(0,r.A)(e))throw new a.A("endPoint0 is required.");if(!(0,r.A)(t))throw new a.A("endPoint1 is required.");if(!(0,r.A)(n))throw new a.A("plane is required.");(0,r.A)(o)||(o=new i.A);const s=i.A.subtract(t,e,G),l=n.normal,h=i.A.dot(l,s);if(Math.abs(h)<c.A.EPSILON6)return;const u=i.A.dot(l,e),d=-(n.distance+u)/h;return d<0||d>1?void 0:(i.A.multiplyByScalar(s,d,o),i.A.add(e,o,o),o)},p.trianglePlaneIntersection=function(e,t,n,o){if(!((0,r.A)(e)&&(0,r.A)(t)&&(0,r.A)(n)&&(0,r.A)(o)))throw new a.A("p0, p1, p2, and plane are required.");const s=o.normal,c=o.distance,l=i.A.dot(s,e)+c<0,h=i.A.dot(s,t)+c<0,u=i.A.dot(s,n)+c<0;let d,m,f=0;if(f+=l?1:0,f+=h?1:0,f+=u?1:0,1!==f&&2!==f||(d=new i.A,m=new i.A),1===f){if(l)return p.lineSegmentPlane(e,t,o,d),p.lineSegmentPlane(e,n,o,m),{positions:[e,t,n,d,m],indices:[0,3,4,1,2,4,1,4,3]};if(h)return p.lineSegmentPlane(t,n,o,d),p.lineSegmentPlane(t,e,o,m),{positions:[e,t,n,d,m],indices:[1,3,4,2,0,4,2,4,3]};if(u)return p.lineSegmentPlane(n,e,o,d),p.lineSegmentPlane(n,t,o,m),{positions:[e,t,n,d,m],indices:[2,3,4,0,1,4,0,4,3]}}else if(2===f){if(!l)return p.lineSegmentPlane(t,e,o,d),p.lineSegmentPlane(n,e,o,m),{positions:[e,t,n,d,m],indices:[1,2,4,1,4,3,0,3,4]};if(!h)return p.lineSegmentPlane(n,t,o,d),p.lineSegmentPlane(e,t,o,m),{positions:[e,t,n,d,m],indices:[2,0,4,2,4,3,1,3,4]};if(!u)return p.lineSegmentPlane(e,n,o,d),p.lineSegmentPlane(t,n,o,m),{positions:[e,t,n,d,m],indices:[0,1,4,0,4,3,2,3,4]}}};const H=p},33914:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i=function(e,t){this.start=e??0,this.stop=t??0}},32655:(e,t,n)=>{"use strict";n.d(t,{A:()=>s});var i=n(591978),o=n(93467);const r=Object.freeze(i.A.fromIso8601("0000-01-01T00:00:00Z")),a=Object.freeze(i.A.fromIso8601("9999-12-31T24:00:00Z")),s={MINIMUM_VALUE:r,MAXIMUM_VALUE:a,MAXIMUM_INTERVAL:Object.freeze(new o.A({start:r,stop:a}))}},708025:(e,t,n)=>{"use strict";n.d(t,{A:()=>l});var i=n(369031),o=n(56233),r=n(491446),a=n(123245),s=n(971724);function c(){}c._transcodeTaskProcessor=new s.A("transcodeKTX2",Number.POSITIVE_INFINITY),c._readyPromise=void 0,c.transcode=function(e,t){return i.A.defined("supportedTargetFormats",t),(0,r.A)(c._readyPromise)||function(){const e=c._transcodeTaskProcessor.initWebAssemblyModule({wasmBinaryFile:"ThirdParty/basis_transcoder.wasm"}).then(function(e){if(e)return c._transcodeTaskProcessor;throw new a.A("KTX2 transcoder could not be initialized.")});c._readyPromise=e}(),c._readyPromise.then(function(n){let i=e;e instanceof ArrayBuffer&&(i=new Uint8Array(e));const o={supportedTargetFormats:t,ktx2Buffer:i};return n.scheduleTask(o,[i.buffer])}).then(function(e){const t=e.length,n=Object.keys(e[0]);for(let i=0;i<t;i++){const t=e[i];for(let e=0;e<n.length;e++){const i=t[n[e]];t[n[e]]=new o.A(i.internalFormat,i.datatype,i.width,i.height,i.levelBuffer)}}if(1===n.length){for(let i=0;i<t;++i)e[i]=e[i][n[0]];1===t&&(e=e[0])}return e}).catch(function(e){throw e})};const l=c},463298:(e,t,n)=>{"use strict";n.d(t,{A:()=>m});var i=n(434067),o=n(369031),r=n(491446),a=n(605971);function s(e,t,n,i){this[0]=e??0,this[1]=n??0,this[2]=t??0,this[3]=i??0}s.packedLength=4,s.pack=function(e,t,n){return o.A.typeOf.object("value",e),o.A.defined("array",t),n=n??0,t[n++]=e[0],t[n++]=e[1],t[n++]=e[2],t[n++]=e[3],t},s.unpack=function(e,t,n){return o.A.defined("array",e),t=t??0,(0,r.A)(n)||(n=new s),n[0]=e[t++],n[1]=e[t++],n[2]=e[t++],n[3]=e[t++],n},s.packArray=function(e,t){o.A.defined("array",e);const n=e.length,i=4*n;if((0,r.A)(t)){if(!Array.isArray(t)&&t.length!==i)throw new a.A("If result is a typed array, it must have exactly array.length * 4 elements");t.length!==i&&(t.length=i)}else t=new Array(i);for(let i=0;i<n;++i)s.pack(e[i],t,4*i);return t},s.unpackArray=function(e,t){if(o.A.defined("array",e),o.A.typeOf.number.greaterThanOrEquals("array.length",e.length,4),e.length%4!=0)throw new a.A("array length must be a multiple of 4.");const n=e.length;(0,r.A)(t)?t.length=n/4:t=new Array(n/4);for(let i=0;i<n;i+=4){const n=i/4;t[n]=s.unpack(e,i,t[n])}return t},s.clone=function(e,t){if((0,r.A)(e))return(0,r.A)(t)?(t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t):new s(e[0],e[2],e[1],e[3])},s.fromArray=s.unpack,s.fromColumnMajorArray=function(e,t){return o.A.defined("values",e),s.clone(e,t)},s.fromRowMajorArray=function(e,t){return o.A.defined("values",e),(0,r.A)(t)?(t[0]=e[0],t[1]=e[2],t[2]=e[1],t[3]=e[3],t):new s(e[0],e[1],e[2],e[3])},s.fromScale=function(e,t){return o.A.typeOf.object("scale",e),(0,r.A)(t)?(t[0]=e.x,t[1]=0,t[2]=0,t[3]=e.y,t):new s(e.x,0,0,e.y)},s.fromUniformScale=function(e,t){return o.A.typeOf.number("scale",e),(0,r.A)(t)?(t[0]=e,t[1]=0,t[2]=0,t[3]=e,t):new s(e,0,0,e)},s.fromRotation=function(e,t){o.A.typeOf.number("angle",e);const n=Math.cos(e),i=Math.sin(e);return(0,r.A)(t)?(t[0]=n,t[1]=i,t[2]=-i,t[3]=n,t):new s(n,-i,i,n)},s.toArray=function(e,t){return o.A.typeOf.object("matrix",e),(0,r.A)(t)?(t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t):[e[0],e[1],e[2],e[3]]},s.getElementIndex=function(e,t){return o.A.typeOf.number.greaterThanOrEquals("row",t,0),o.A.typeOf.number.lessThanOrEquals("row",t,1),o.A.typeOf.number.greaterThanOrEquals("column",e,0),o.A.typeOf.number.lessThanOrEquals("column",e,1),2*e+t},s.getColumn=function(e,t,n){o.A.typeOf.object("matrix",e),o.A.typeOf.number.greaterThanOrEquals("index",t,0),o.A.typeOf.number.lessThanOrEquals("index",t,1),o.A.typeOf.object("result",n);const i=2*t,r=e[i],a=e[i+1];return n.x=r,n.y=a,n},s.setColumn=function(e,t,n,i){o.A.typeOf.object("matrix",e),o.A.typeOf.number.greaterThanOrEquals("index",t,0),o.A.typeOf.number.lessThanOrEquals("index",t,1),o.A.typeOf.object("cartesian",n),o.A.typeOf.object("result",i);const r=2*t;return(i=s.clone(e,i))[r]=n.x,i[r+1]=n.y,i},s.getRow=function(e,t,n){o.A.typeOf.object("matrix",e),o.A.typeOf.number.greaterThanOrEquals("index",t,0),o.A.typeOf.number.lessThanOrEquals("index",t,1),o.A.typeOf.object("result",n);const i=e[t],r=e[t+2];return n.x=i,n.y=r,n},s.setRow=function(e,t,n,i){return o.A.typeOf.object("matrix",e),o.A.typeOf.number.greaterThanOrEquals("index",t,0),o.A.typeOf.number.lessThanOrEquals("index",t,1),o.A.typeOf.object("cartesian",n),o.A.typeOf.object("result",i),(i=s.clone(e,i))[t]=n.x,i[t+2]=n.y,i};const c=new i.A;s.setScale=function(e,t,n){o.A.typeOf.object("matrix",e),o.A.typeOf.object("scale",t),o.A.typeOf.object("result",n);const i=s.getScale(e,c),r=t.x/i.x,a=t.y/i.y;return n[0]=e[0]*r,n[1]=e[1]*r,n[2]=e[2]*a,n[3]=e[3]*a,n};const l=new i.A;s.setUniformScale=function(e,t,n){o.A.typeOf.object("matrix",e),o.A.typeOf.number("scale",t),o.A.typeOf.object("result",n);const i=s.getScale(e,l),r=t/i.x,a=t/i.y;return n[0]=e[0]*r,n[1]=e[1]*r,n[2]=e[2]*a,n[3]=e[3]*a,n};const h=new i.A;s.getScale=function(e,t){return o.A.typeOf.object("matrix",e),o.A.typeOf.object("result",t),t.x=i.A.magnitude(i.A.fromElements(e[0],e[1],h)),t.y=i.A.magnitude(i.A.fromElements(e[2],e[3],h)),t};const u=new i.A;s.getMaximumScale=function(e){return s.getScale(e,u),i.A.maximumComponent(u)};const d=new i.A;s.setRotation=function(e,t,n){o.A.typeOf.object("matrix",e),o.A.typeOf.object("result",n);const i=s.getScale(e,d);return n[0]=t[0]*i.x,n[1]=t[1]*i.x,n[2]=t[2]*i.y,n[3]=t[3]*i.y,n};const p=new i.A;s.getRotation=function(e,t){o.A.typeOf.object("matrix",e),o.A.typeOf.object("result",t);const n=s.getScale(e,p);return t[0]=e[0]/n.x,t[1]=e[1]/n.x,t[2]=e[2]/n.y,t[3]=e[3]/n.y,t},s.multiply=function(e,t,n){o.A.typeOf.object("left",e),o.A.typeOf.object("right",t),o.A.typeOf.object("result",n);const i=e[0]*t[0]+e[2]*t[1],r=e[0]*t[2]+e[2]*t[3],a=e[1]*t[0]+e[3]*t[1],s=e[1]*t[2]+e[3]*t[3];return n[0]=i,n[1]=a,n[2]=r,n[3]=s,n},s.add=function(e,t,n){return o.A.typeOf.object("left",e),o.A.typeOf.object("right",t),o.A.typeOf.object("result",n),n[0]=e[0]+t[0],n[1]=e[1]+t[1],n[2]=e[2]+t[2],n[3]=e[3]+t[3],n},s.subtract=function(e,t,n){return o.A.typeOf.object("left",e),o.A.typeOf.object("right",t),o.A.typeOf.object("result",n),n[0]=e[0]-t[0],n[1]=e[1]-t[1],n[2]=e[2]-t[2],n[3]=e[3]-t[3],n},s.multiplyByVector=function(e,t,n){o.A.typeOf.object("matrix",e),o.A.typeOf.object("cartesian",t),o.A.typeOf.object("result",n);const i=e[0]*t.x+e[2]*t.y,r=e[1]*t.x+e[3]*t.y;return n.x=i,n.y=r,n},s.multiplyByScalar=function(e,t,n){return o.A.typeOf.object("matrix",e),o.A.typeOf.number("scalar",t),o.A.typeOf.object("result",n),n[0]=e[0]*t,n[1]=e[1]*t,n[2]=e[2]*t,n[3]=e[3]*t,n},s.multiplyByScale=function(e,t,n){return o.A.typeOf.object("matrix",e),o.A.typeOf.object("scale",t),o.A.typeOf.object("result",n),n[0]=e[0]*t.x,n[1]=e[1]*t.x,n[2]=e[2]*t.y,n[3]=e[3]*t.y,n},s.multiplyByUniformScale=function(e,t,n){return o.A.typeOf.object("matrix",e),o.A.typeOf.number("scale",t),o.A.typeOf.object("result",n),n[0]=e[0]*t,n[1]=e[1]*t,n[2]=e[2]*t,n[3]=e[3]*t,n},s.negate=function(e,t){return o.A.typeOf.object("matrix",e),o.A.typeOf.object("result",t),t[0]=-e[0],t[1]=-e[1],t[2]=-e[2],t[3]=-e[3],t},s.transpose=function(e,t){o.A.typeOf.object("matrix",e),o.A.typeOf.object("result",t);const n=e[0],i=e[2],r=e[1],a=e[3];return t[0]=n,t[1]=i,t[2]=r,t[3]=a,t},s.abs=function(e,t){return o.A.typeOf.object("matrix",e),o.A.typeOf.object("result",t),t[0]=Math.abs(e[0]),t[1]=Math.abs(e[1]),t[2]=Math.abs(e[2]),t[3]=Math.abs(e[3]),t},s.equals=function(e,t){return e===t||(0,r.A)(e)&&(0,r.A)(t)&&e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]},s.equalsArray=function(e,t,n){return e[0]===t[n]&&e[1]===t[n+1]&&e[2]===t[n+2]&&e[3]===t[n+3]},s.equalsEpsilon=function(e,t,n){return n=n??0,e===t||(0,r.A)(e)&&(0,r.A)(t)&&Math.abs(e[0]-t[0])<=n&&Math.abs(e[1]-t[1])<=n&&Math.abs(e[2]-t[2])<=n&&Math.abs(e[3]-t[3])<=n},s.IDENTITY=Object.freeze(new s(1,0,0,1)),s.ZERO=Object.freeze(new s(0,0,0,0)),s.COLUMN0ROW0=0,s.COLUMN0ROW1=1,s.COLUMN1ROW0=2,s.COLUMN1ROW1=3,Object.defineProperties(s.prototype,{length:{get:function(){return s.packedLength}}}),s.prototype.clone=function(e){return s.clone(this,e)},s.prototype.equals=function(e){return s.equals(this,e)},s.prototype.equalsEpsilon=function(e,t){return s.equalsEpsilon(this,e,t)},s.prototype.toString=function(){return`(${this[0]}, ${this[2]})\n(${this[1]}, ${this[3]})`};const m=s},290176:(e,t,n)=>{"use strict";n.d(t,{A:()=>a});var i=n(491446),o=n(605971);function r(e,t,n,i){this.near=e??0,this.nearValue=t??0,this.far=n??1,this.farValue=i??0}r.clone=function(e,t){if((0,i.A)(e))return(0,i.A)(t)?(t.near=e.near,t.nearValue=e.nearValue,t.far=e.far,t.farValue=e.farValue,t):new r(e.near,e.nearValue,e.far,e.farValue)},r.packedLength=4,r.pack=function(e,t,n){if(!(0,i.A)(e))throw new o.A("value is required");if(!(0,i.A)(t))throw new o.A("array is required");return n=n??0,t[n++]=e.near,t[n++]=e.nearValue,t[n++]=e.far,t[n]=e.farValue,t},r.unpack=function(e,t,n){if(!(0,i.A)(e))throw new o.A("array is required");return t=t??0,(0,i.A)(n)||(n=new r),n.near=e[t++],n.nearValue=e[t++],n.far=e[t++],n.farValue=e[t],n},r.equals=function(e,t){return e===t||(0,i.A)(e)&&(0,i.A)(t)&&e.near===t.near&&e.nearValue===t.nearValue&&e.far===t.far&&e.farValue===t.farValue},r.prototype.clone=function(e){return r.clone(this,e)},r.prototype.equals=function(e){return r.equals(this,e)};const a=r},852575:(e,t,n)=>{"use strict";n.d(t,{A:()=>s});var i=n(369031),o=n(571804),r=n(491446);function a(e,t,n){e=e??0,t=t??0,n=n??0,this.value=new Float32Array([e,t,n])}Object.defineProperties(a.prototype,{componentDatatype:{get:function(){return o.A.FLOAT}},componentsPerAttribute:{get:function(){return 3}},normalize:{get:function(){return!1}}}),a.fromCartesian3=function(e){return i.A.defined("offset",e),new a(e.x,e.y,e.z)},a.toValue=function(e,t){return i.A.defined("offset",e),(0,r.A)(t)||(t=new Float32Array([e.x,e.y,e.z])),t[0]=e.x,t[1]=e.y,t[2]=e.z,t};const s=a},832698:(e,t,n)=>{"use strict";n.d(t,{A:()=>Ae});var i=n(660662),o=n(434067),r=n(267980),a=n(336946),s=n(369031),c=n(491446),l=n(605971),h=n(610750),u=n(658091),d=n(647326),p=n(33914),m=n(367817),f=n(331185),A=n(584164),_=n(257941),g=n(697422);function y(e,t){this.center=r.A.clone(e??r.A.ZERO),this.halfAxes=f.A.clone(t??f.A.ZERO)}y.packedLength=r.A.packedLength+f.A.packedLength,y.pack=function(e,t,n){return s.A.typeOf.object("value",e),s.A.defined("array",t),n=n??0,r.A.pack(e.center,t,n),f.A.pack(e.halfAxes,t,n+r.A.packedLength),t},y.unpack=function(e,t,n){return s.A.defined("array",e),t=t??0,(0,c.A)(n)||(n=new y),r.A.unpack(e,t,n.center),f.A.unpack(e,t+r.A.packedLength,n.halfAxes),n};const v=new r.A,b=new r.A,w=new r.A,T=new r.A,x=new r.A,C=new r.A,E=new f.A,S={unitary:new f.A,diagonal:new f.A};y.fromPoints=function(e,t){if((0,c.A)(t)||(t=new y),!(0,c.A)(e)||0===e.length)return t.halfAxes=f.A.ZERO,t.center=r.A.ZERO,t;let n;const i=e.length,o=r.A.clone(e[0],v);for(n=1;n<i;n++)r.A.add(o,e[n],o);const a=1/i;r.A.multiplyByScalar(o,a,o);let s,l=0,h=0,u=0,d=0,p=0,m=0;for(n=0;n<i;n++)s=r.A.subtract(e[n],o,b),l+=s.x*s.x,h+=s.x*s.y,u+=s.x*s.z,d+=s.y*s.y,p+=s.y*s.z,m+=s.z*s.z;l*=a,h*=a,u*=a,d*=a,p*=a,m*=a;const A=E;A[0]=l,A[1]=h,A[2]=u,A[3]=h,A[4]=d,A[5]=p,A[6]=u,A[7]=p,A[8]=m;const _=f.A.computeEigenDecomposition(A,S),g=f.A.clone(_.unitary,t.halfAxes);let D=f.A.getColumn(g,0,T),O=f.A.getColumn(g,1,x),z=f.A.getColumn(g,2,C),I=-Number.MAX_VALUE,P=-Number.MAX_VALUE,R=-Number.MAX_VALUE,N=Number.MAX_VALUE,L=Number.MAX_VALUE,M=Number.MAX_VALUE;for(n=0;n<i;n++)s=e[n],I=Math.max(r.A.dot(D,s),I),P=Math.max(r.A.dot(O,s),P),R=Math.max(r.A.dot(z,s),R),N=Math.min(r.A.dot(D,s),N),L=Math.min(r.A.dot(O,s),L),M=Math.min(r.A.dot(z,s),M);D=r.A.multiplyByScalar(D,.5*(N+I),D),O=r.A.multiplyByScalar(O,.5*(L+P),O),z=r.A.multiplyByScalar(z,.5*(M+R),z);const F=r.A.add(D,O,t.center);r.A.add(F,z,F);const B=w;return B.x=I-N,B.y=P-L,B.z=R-M,r.A.multiplyByScalar(B,.5,B),f.A.multiplyByScale(t.halfAxes,B,t.halfAxes),t};const D=new r.A,O=new r.A;function z(e,t,n,i,o,a,s,h,u,d,p){if(!((0,c.A)(o)&&(0,c.A)(a)&&(0,c.A)(s)&&(0,c.A)(h)&&(0,c.A)(u)&&(0,c.A)(d)))throw new l.A("all extents (minimum/maximum X/Y/Z) are required.");(0,c.A)(p)||(p=new y);const m=p.halfAxes;f.A.setColumn(m,0,t,m),f.A.setColumn(m,1,n,m),f.A.setColumn(m,2,i,m);let A=D;A.x=(o+a)/2,A.y=(s+h)/2,A.z=(u+d)/2;const _=O;_.x=(a-o)/2,_.y=(h-s)/2,_.z=(d-u)/2;const g=p.center;return A=f.A.multiplyByVector(m,A,A),r.A.add(e,A,g),f.A.multiplyByScale(m,_,m),p}const I=new a.A,P=new r.A,R=new a.A,N=new a.A,L=new a.A,M=new a.A,F=new a.A,B=new r.A,k=new r.A,V=new r.A,G=new r.A,H=new r.A,U=new o.A,W=new o.A,q=new o.A,j=new o.A,Y=new o.A,X=new r.A,$=new r.A,Z=new r.A,K=new r.A,Q=new o.A,J=new r.A,ee=new r.A,te=new r.A,ne=new _.A(r.A.UNIT_X,0);y.fromRectangle=function(e,t,n,i,o){if(!(0,c.A)(e))throw new l.A("rectangle is required");if(e.width<0||e.width>m.A.TWO_PI)throw new l.A("Rectangle width must be between 0 and 2 * pi");if(e.height<0||e.height>m.A.PI)throw new l.A("Rectangle height must be between 0 and pi");if((0,c.A)(i)&&!m.A.equalsEpsilon(i.radii.x,i.radii.y,m.A.EPSILON15))throw new l.A("Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)");let s,d,p,f,A,y,v;if(t=t??0,n=n??0,i=i??h.A.default,e.width<=m.A.PI){const r=g.A.center(e,I),c=i.cartographicToCartesian(r,P),l=new u.A(c,i);v=l.plane;const h=r.longitude,m=e.south<0&&e.north>0?0:r.latitude,b=a.A.fromRadians(h,e.north,n,R),w=a.A.fromRadians(e.west,e.north,n,N),T=a.A.fromRadians(e.west,m,n,L),x=a.A.fromRadians(e.west,e.south,n,M),C=a.A.fromRadians(h,e.south,n,F),E=i.cartographicToCartesian(b,B);let S=i.cartographicToCartesian(w,k);const D=i.cartographicToCartesian(T,V);let O=i.cartographicToCartesian(x,G);const X=i.cartographicToCartesian(C,H),$=l.projectPointToNearestOnPlane(E,U),Z=l.projectPointToNearestOnPlane(S,W),K=l.projectPointToNearestOnPlane(D,q),Q=l.projectPointToNearestOnPlane(O,j),J=l.projectPointToNearestOnPlane(X,Y);return s=Math.min(Z.x,K.x,Q.x),d=-s,f=Math.max(Z.y,$.y),p=Math.min(Q.y,J.y),w.height=x.height=t,S=i.cartographicToCartesian(w,k),O=i.cartographicToCartesian(x,G),A=Math.min(_.A.getPointDistance(v,S),_.A.getPointDistance(v,O)),y=n,z(l.origin,l.xAxis,l.yAxis,l.zAxis,s,d,p,f,A,y,o)}const b=e.south>0,w=e.north<0,T=b?e.south:w?e.north:0,x=g.A.center(e,I).longitude,C=r.A.fromRadians(x,T,n,i,X);C.z=0;const E=Math.abs(C.x)<m.A.EPSILON10&&Math.abs(C.y)<m.A.EPSILON10?r.A.UNIT_X:r.A.normalize(C,$),S=r.A.UNIT_Z,D=r.A.cross(E,S,Z);v=_.A.fromPointNormal(C,E,ne);const O=r.A.fromRadians(x+m.A.PI_OVER_TWO,T,n,i,K);d=r.A.dot(_.A.projectPointOntoPlane(v,O,Q),D),s=-d,f=r.A.fromRadians(0,e.north,w?t:n,i,J).z,p=r.A.fromRadians(0,e.south,b?t:n,i,ee).z;const ie=r.A.fromRadians(e.east,T,n,i,te);return A=_.A.getPointDistance(v,ie),y=0,z(C,D,S,E,s,d,p,f,A,y,o)},y.fromTransformation=function(e,t){return s.A.typeOf.object("transformation",e),(0,c.A)(t)||(t=new y),t.center=A.A.getTranslation(e,t.center),t.halfAxes=A.A.getMatrix3(e,t.halfAxes),t.halfAxes=f.A.multiplyByScalar(t.halfAxes,.5,t.halfAxes),t},y.clone=function(e,t){if((0,c.A)(e))return(0,c.A)(t)?(r.A.clone(e.center,t.center),f.A.clone(e.halfAxes,t.halfAxes),t):new y(e.center,e.halfAxes)},y.intersectPlane=function(e,t){if(!(0,c.A)(e))throw new l.A("box is required.");if(!(0,c.A)(t))throw new l.A("plane is required.");const n=e.center,i=t.normal,o=e.halfAxes,a=i.x,s=i.y,h=i.z,u=Math.abs(a*o[f.A.COLUMN0ROW0]+s*o[f.A.COLUMN0ROW1]+h*o[f.A.COLUMN0ROW2])+Math.abs(a*o[f.A.COLUMN1ROW0]+s*o[f.A.COLUMN1ROW1]+h*o[f.A.COLUMN1ROW2])+Math.abs(a*o[f.A.COLUMN2ROW0]+s*o[f.A.COLUMN2ROW1]+h*o[f.A.COLUMN2ROW2]),p=r.A.dot(i,n)+t.distance;return p<=-u?d.A.OUTSIDE:p>=u?d.A.INSIDE:d.A.INTERSECTING};const ie=new r.A,oe=new r.A,re=new r.A,ae=new r.A,se=new r.A,ce=new r.A;y.distanceSquaredTo=function(e,t){if(!(0,c.A)(e))throw new l.A("box is required.");if(!(0,c.A)(t))throw new l.A("cartesian is required.");const n=r.A.subtract(t,e.center,D),i=e.halfAxes;let o=f.A.getColumn(i,0,ie),a=f.A.getColumn(i,1,oe),s=f.A.getColumn(i,2,re);const h=r.A.magnitude(o),u=r.A.magnitude(a),d=r.A.magnitude(s);let p=!0,A=!0,_=!0;h>0?r.A.divideByScalar(o,h,o):p=!1,u>0?r.A.divideByScalar(a,u,a):A=!1,d>0?r.A.divideByScalar(s,d,s):_=!1;const g=!p+!A+!_;let y,v,b;if(1===g){let e=o;y=a,v=s,A?_||(e=s,v=o):(e=a,y=o),b=r.A.cross(y,v,se),e===o?o=b:e===a?a=b:e===s&&(s=b)}else if(2===g){y=o,A?y=a:_&&(y=s);let e=r.A.UNIT_Y;e.equalsEpsilon(y,m.A.EPSILON3)&&(e=r.A.UNIT_X),v=r.A.cross(y,e,ae),r.A.normalize(v,v),b=r.A.cross(y,v,se),r.A.normalize(b,b),y===o?(a=v,s=b):y===a?(s=v,o=b):y===s&&(o=v,a=b)}else 3===g&&(o=r.A.UNIT_X,a=r.A.UNIT_Y,s=r.A.UNIT_Z);const w=ce;w.x=r.A.dot(n,o),w.y=r.A.dot(n,a),w.z=r.A.dot(n,s);let T,x=0;return w.x<-h?(T=w.x+h,x+=T*T):w.x>h&&(T=w.x-h,x+=T*T),w.y<-u?(T=w.y+u,x+=T*T):w.y>u&&(T=w.y-u,x+=T*T),w.z<-d?(T=w.z+d,x+=T*T):w.z>d&&(T=w.z-d,x+=T*T),x};const le=new r.A,he=new r.A;y.computePlaneDistances=function(e,t,n,i){if(!(0,c.A)(e))throw new l.A("box is required.");if(!(0,c.A)(t))throw new l.A("position is required.");if(!(0,c.A)(n))throw new l.A("direction is required.");(0,c.A)(i)||(i=new p.A);let o=Number.POSITIVE_INFINITY,a=Number.NEGATIVE_INFINITY;const s=e.center,h=e.halfAxes,u=f.A.getColumn(h,0,ie),d=f.A.getColumn(h,1,oe),m=f.A.getColumn(h,2,re),A=r.A.add(u,d,le);r.A.add(A,m,A),r.A.add(A,s,A);const _=r.A.subtract(A,t,he);let g=r.A.dot(n,_);return o=Math.min(g,o),a=Math.max(g,a),r.A.add(s,u,A),r.A.add(A,d,A),r.A.subtract(A,m,A),r.A.subtract(A,t,_),g=r.A.dot(n,_),o=Math.min(g,o),a=Math.max(g,a),r.A.add(s,u,A),r.A.subtract(A,d,A),r.A.add(A,m,A),r.A.subtract(A,t,_),g=r.A.dot(n,_),o=Math.min(g,o),a=Math.max(g,a),r.A.add(s,u,A),r.A.subtract(A,d,A),r.A.subtract(A,m,A),r.A.subtract(A,t,_),g=r.A.dot(n,_),o=Math.min(g,o),a=Math.max(g,a),r.A.subtract(s,u,A),r.A.add(A,d,A),r.A.add(A,m,A),r.A.subtract(A,t,_),g=r.A.dot(n,_),o=Math.min(g,o),a=Math.max(g,a),r.A.subtract(s,u,A),r.A.add(A,d,A),r.A.subtract(A,m,A),r.A.subtract(A,t,_),g=r.A.dot(n,_),o=Math.min(g,o),a=Math.max(g,a),r.A.subtract(s,u,A),r.A.subtract(A,d,A),r.A.add(A,m,A),r.A.subtract(A,t,_),g=r.A.dot(n,_),o=Math.min(g,o),a=Math.max(g,a),r.A.subtract(s,u,A),r.A.subtract(A,d,A),r.A.subtract(A,m,A),r.A.subtract(A,t,_),g=r.A.dot(n,_),o=Math.min(g,o),a=Math.max(g,a),i.start=o,i.stop=a,i};const ue=new r.A,de=new r.A,pe=new r.A;y.computeCorners=function(e,t){s.A.typeOf.object("box",e),(0,c.A)(t)||(t=[new r.A,new r.A,new r.A,new r.A,new r.A,new r.A,new r.A,new r.A]);const n=e.center,i=e.halfAxes,o=f.A.getColumn(i,0,ue),a=f.A.getColumn(i,1,de),l=f.A.getColumn(i,2,pe);return r.A.clone(n,t[0]),r.A.subtract(t[0],o,t[0]),r.A.subtract(t[0],a,t[0]),r.A.subtract(t[0],l,t[0]),r.A.clone(n,t[1]),r.A.subtract(t[1],o,t[1]),r.A.subtract(t[1],a,t[1]),r.A.add(t[1],l,t[1]),r.A.clone(n,t[2]),r.A.subtract(t[2],o,t[2]),r.A.add(t[2],a,t[2]),r.A.subtract(t[2],l,t[2]),r.A.clone(n,t[3]),r.A.subtract(t[3],o,t[3]),r.A.add(t[3],a,t[3]),r.A.add(t[3],l,t[3]),r.A.clone(n,t[4]),r.A.add(t[4],o,t[4]),r.A.subtract(t[4],a,t[4]),r.A.subtract(t[4],l,t[4]),r.A.clone(n,t[5]),r.A.add(t[5],o,t[5]),r.A.subtract(t[5],a,t[5]),r.A.add(t[5],l,t[5]),r.A.clone(n,t[6]),r.A.add(t[6],o,t[6]),r.A.add(t[6],a,t[6]),r.A.subtract(t[6],l,t[6]),r.A.clone(n,t[7]),r.A.add(t[7],o,t[7]),r.A.add(t[7],a,t[7]),r.A.add(t[7],l,t[7]),t};const me=new f.A;y.computeTransformation=function(e,t){s.A.typeOf.object("box",e),(0,c.A)(t)||(t=new A.A);const n=e.center,i=f.A.multiplyByUniformScale(e.halfAxes,2,me);return A.A.fromRotationTranslation(i,n,t)};const fe=new i.A;y.isOccluded=function(e,t){if(!(0,c.A)(e))throw new l.A("box is required.");if(!(0,c.A)(t))throw new l.A("occluder is required.");const n=i.A.fromOrientedBoundingBox(e,fe);return!t.isBoundingSphereVisible(n)},y.prototype.intersectPlane=function(e){return y.intersectPlane(this,e)},y.prototype.distanceSquaredTo=function(e){return y.distanceSquaredTo(this,e)},y.prototype.computePlaneDistances=function(e,t,n){return y.computePlaneDistances(this,e,t,n)},y.prototype.computeCorners=function(e){return y.computeCorners(this,e)},y.prototype.computeTransformation=function(e){return y.computeTransformation(this,e)},y.prototype.isOccluded=function(e){return y.isOccluded(this,e)},y.equals=function(e,t){return e===t||(0,c.A)(e)&&(0,c.A)(t)&&r.A.equals(e.center,t.center)&&f.A.equals(e.halfAxes,t.halfAxes)},y.prototype.clone=function(e){return y.clone(this,e)},y.prototype.equals=function(e){return y.equals(this,e)};const Ae=y},811203:(e,t,n)=>{"use strict";n.d(t,{A:()=>u});var i=n(369031),o=n(915325),r=n(491446),a=n(605971),s=n(367817),c=n(65891);function l(e){e=e??o.A.EMPTY_OBJECT,this._offCenterFrustum=new c.A,this.width=e.width,this._width=void 0,this.aspectRatio=e.aspectRatio,this._aspectRatio=void 0,this.near=e.near??1,this._near=this.near,this.far=e.far??5e8,this._far=this.far}function h(e){if(!((0,r.A)(e.width)&&(0,r.A)(e.aspectRatio)&&(0,r.A)(e.near)&&(0,r.A)(e.far)))throw new a.A("width, aspectRatio, near, or far parameters are not set.");const t=e._offCenterFrustum;if(e.width!==e._width||e.aspectRatio!==e._aspectRatio||e.near!==e._near||e.far!==e._far){if(e.aspectRatio<0)throw new a.A("aspectRatio must be positive.");if(e.near<0||e.near>e.far)throw new a.A("near must be greater than zero and less than far.");e._aspectRatio=e.aspectRatio,e._width=e.width,e._near=e.near,e._far=e.far;const n=1/e.aspectRatio;t.right=.5*e.width,t.left=-t.right,t.top=n*t.right,t.bottom=-t.top,t.near=e.near,t.far=e.far}}l.packedLength=4,l.pack=function(e,t,n){return i.A.typeOf.object("value",e),i.A.defined("array",t),n=n??0,t[n++]=e.width,t[n++]=e.aspectRatio,t[n++]=e.near,t[n]=e.far,t},l.unpack=function(e,t,n){return i.A.defined("array",e),t=t??0,(0,r.A)(n)||(n=new l),n.width=e[t++],n.aspectRatio=e[t++],n.near=e[t++],n.far=e[t],n},Object.defineProperties(l.prototype,{projectionMatrix:{get:function(){return h(this),this._offCenterFrustum.projectionMatrix}},offCenterFrustum:{get:function(){return h(this),this._offCenterFrustum}}}),l.prototype.computeCullingVolume=function(e,t,n){return h(this),this._offCenterFrustum.computeCullingVolume(e,t,n)},l.prototype.getPixelDimensions=function(e,t,n,i,o){return h(this),this._offCenterFrustum.getPixelDimensions(e,t,n,i,o)},l.prototype.clone=function(e){return(0,r.A)(e)||(e=new l),e.aspectRatio=this.aspectRatio,e.width=this.width,e.near=this.near,e.far=this.far,e._aspectRatio=void 0,e._width=void 0,e._near=void 0,e._far=void 0,this._offCenterFrustum.clone(e._offCenterFrustum),e},l.prototype.equals=function(e){return!!((0,r.A)(e)&&e instanceof l)&&(h(this),h(e),this.width===e.width&&this.aspectRatio===e.aspectRatio&&this._offCenterFrustum.equals(e._offCenterFrustum))},l.prototype.equalsEpsilon=function(e,t,n){return!!((0,r.A)(e)&&e instanceof l)&&(h(this),h(e),s.A.equalsEpsilon(this.width,e.width,t,n)&&s.A.equalsEpsilon(this.aspectRatio,e.aspectRatio,t,n)&&this._offCenterFrustum.equalsEpsilon(e._offCenterFrustum,t,n))};const u=l},65891:(e,t,n)=>{"use strict";n.d(t,{A:()=>_});var i=n(267980),o=n(626809),r=n(400793),a=n(915325),s=n(491446),c=n(605971),l=n(367817),h=n(584164);function u(e){e=e??a.A.EMPTY_OBJECT,this.left=e.left,this._left=void 0,this.right=e.right,this._right=void 0,this.top=e.top,this._top=void 0,this.bottom=e.bottom,this._bottom=void 0,this.near=e.near??1,this._near=this.near,this.far=e.far??5e8,this._far=this.far,this._cullingVolume=new r.A,this._orthographicMatrix=new h.A}function d(e){if(!((0,s.A)(e.right)&&(0,s.A)(e.left)&&(0,s.A)(e.top)&&(0,s.A)(e.bottom)&&(0,s.A)(e.near)&&(0,s.A)(e.far)))throw new c.A("right, left, top, bottom, near, or far parameters are not set.");if(e.top!==e._top||e.bottom!==e._bottom||e.left!==e._left||e.right!==e._right||e.near!==e._near||e.far!==e._far){if(e.left>e.right)throw new c.A("right must be greater than left.");if(e.bottom>e.top)throw new c.A("top must be greater than bottom.");if(e.near<=0||e.near>e.far)throw new c.A("near must be greater than zero and less than far.");e._left=e.left,e._right=e.right,e._top=e.top,e._bottom=e.bottom,e._near=e.near,e._far=e.far,e._orthographicMatrix=h.A.computeOrthographicOffCenter(e.left,e.right,e.bottom,e.top,e.near,e.far,e._orthographicMatrix)}}Object.defineProperties(u.prototype,{projectionMatrix:{get:function(){return d(this),this._orthographicMatrix}}});const p=new i.A,m=new i.A,f=new i.A,A=new i.A;u.prototype.computeCullingVolume=function(e,t,n){if(!(0,s.A)(e))throw new c.A("position is required.");if(!(0,s.A)(t))throw new c.A("direction is required.");if(!(0,s.A)(n))throw new c.A("up is required.");const r=this._cullingVolume.planes,a=this.top,l=this.bottom,h=this.right,u=this.left,d=this.near,_=this.far,g=i.A.cross(t,n,p);i.A.normalize(g,g);const y=m;i.A.multiplyByScalar(t,d,y),i.A.add(e,y,y);const v=f;i.A.multiplyByScalar(g,u,v),i.A.add(y,v,v);let b=r[0];return(0,s.A)(b)||(b=r[0]=new o.A),b.x=g.x,b.y=g.y,b.z=g.z,b.w=-i.A.dot(g,v),i.A.multiplyByScalar(g,h,v),i.A.add(y,v,v),b=r[1],(0,s.A)(b)||(b=r[1]=new o.A),b.x=-g.x,b.y=-g.y,b.z=-g.z,b.w=-i.A.dot(i.A.negate(g,A),v),i.A.multiplyByScalar(n,l,v),i.A.add(y,v,v),b=r[2],(0,s.A)(b)||(b=r[2]=new o.A),b.x=n.x,b.y=n.y,b.z=n.z,b.w=-i.A.dot(n,v),i.A.multiplyByScalar(n,a,v),i.A.add(y,v,v),b=r[3],(0,s.A)(b)||(b=r[3]=new o.A),b.x=-n.x,b.y=-n.y,b.z=-n.z,b.w=-i.A.dot(i.A.negate(n,A),v),b=r[4],(0,s.A)(b)||(b=r[4]=new o.A),b.x=t.x,b.y=t.y,b.z=t.z,b.w=-i.A.dot(t,y),i.A.multiplyByScalar(t,_,v),i.A.add(e,v,v),b=r[5],(0,s.A)(b)||(b=r[5]=new o.A),b.x=-t.x,b.y=-t.y,b.z=-t.z,b.w=-i.A.dot(i.A.negate(t,A),v),this._cullingVolume},u.prototype.getPixelDimensions=function(e,t,n,i,o){if(d(this),!(0,s.A)(e)||!(0,s.A)(t))throw new c.A("Both drawingBufferWidth and drawingBufferHeight are required.");if(e<=0)throw new c.A("drawingBufferWidth must be greater than zero.");if(t<=0)throw new c.A("drawingBufferHeight must be greater than zero.");if(!(0,s.A)(n))throw new c.A("distance is required.");if(!(0,s.A)(i))throw new c.A("pixelRatio is required.");if(i<=0)throw new c.A("pixelRatio must be greater than zero.");if(!(0,s.A)(o))throw new c.A("A result object is required.");const r=i*(this.right-this.left)/e,a=i*(this.top-this.bottom)/t;return o.x=r,o.y=a,o},u.prototype.clone=function(e){return(0,s.A)(e)||(e=new u),e.left=this.left,e.right=this.right,e.top=this.top,e.bottom=this.bottom,e.near=this.near,e.far=this.far,e._left=void 0,e._right=void 0,e._top=void 0,e._bottom=void 0,e._near=void 0,e._far=void 0,e},u.prototype.equals=function(e){return(0,s.A)(e)&&e instanceof u&&this.right===e.right&&this.left===e.left&&this.top===e.top&&this.bottom===e.bottom&&this.near===e.near&&this.far===e.far},u.prototype.equalsEpsilon=function(e,t,n){return e===this||(0,s.A)(e)&&e instanceof u&&l.A.equalsEpsilon(this.right,e.right,t,n)&&l.A.equalsEpsilon(this.left,e.left,t,n)&&l.A.equalsEpsilon(this.top,e.top,t,n)&&l.A.equalsEpsilon(this.bottom,e.bottom,t,n)&&l.A.equalsEpsilon(this.near,e.near,t,n)&&l.A.equalsEpsilon(this.far,e.far,t,n)};const _=u},276904:(e,t,n)=>{"use strict";n.d(t,{A:()=>a});var i=n(57775),o=n(352581);const r={DEPTH_COMPONENT:o.A.DEPTH_COMPONENT,DEPTH_STENCIL:o.A.DEPTH_STENCIL,ALPHA:o.A.ALPHA,RED:o.A.RED,RG:o.A.RG,RGB:o.A.RGB,RGBA:o.A.RGBA,RED_INTEGER:o.A.RED_INTEGER,RG_INTEGER:o.A.RG_INTEGER,RGB_INTEGER:o.A.RGB_INTEGER,RGBA_INTEGER:o.A.RGBA_INTEGER,LUMINANCE:o.A.LUMINANCE,LUMINANCE_ALPHA:o.A.LUMINANCE_ALPHA,RGB_DXT1:o.A.COMPRESSED_RGB_S3TC_DXT1_EXT,RGBA_DXT1:o.A.COMPRESSED_RGBA_S3TC_DXT1_EXT,RGBA_DXT3:o.A.COMPRESSED_RGBA_S3TC_DXT3_EXT,RGBA_DXT5:o.A.COMPRESSED_RGBA_S3TC_DXT5_EXT,RGB_PVRTC_4BPPV1:o.A.COMPRESSED_RGB_PVRTC_4BPPV1_IMG,RGB_PVRTC_2BPPV1:o.A.COMPRESSED_RGB_PVRTC_2BPPV1_IMG,RGBA_PVRTC_4BPPV1:o.A.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG,RGBA_PVRTC_2BPPV1:o.A.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG,RGBA_ASTC:o.A.COMPRESSED_RGBA_ASTC_4x4_WEBGL,RGB_ETC1:o.A.COMPRESSED_RGB_ETC1_WEBGL,RGB8_ETC2:o.A.COMPRESSED_RGB8_ETC2,RGBA8_ETC2_EAC:o.A.COMPRESSED_RGBA8_ETC2_EAC,RGBA_BC7:o.A.COMPRESSED_RGBA_BPTC_UNORM,componentsLength:function(e){switch(e){case r.RGB:case r.RGB_INTEGER:return 3;case r.RGBA:case r.RGBA_INTEGER:return 4;case r.LUMINANCE_ALPHA:case r.RG:case r.RG_INTEGER:return 2;case r.ALPHA:case r.RED:case r.RED_INTEGER:case r.LUMINANCE:default:return 1}},validate:function(e){return e===r.DEPTH_COMPONENT||e===r.DEPTH_STENCIL||e===r.ALPHA||e===r.RED||e===r.RG||e===r.RGB||e===r.RGBA||e===r.RED_INTEGER||e===r.RG_INTEGER||e===r.RGB_INTEGER||e===r.RGBA_INTEGER||e===r.LUMINANCE||e===r.LUMINANCE_ALPHA||e===r.RGB_DXT1||e===r.RGBA_DXT1||e===r.RGBA_DXT3||e===r.RGBA_DXT5||e===r.RGB_PVRTC_4BPPV1||e===r.RGB_PVRTC_2BPPV1||e===r.RGBA_PVRTC_4BPPV1||e===r.RGBA_PVRTC_2BPPV1||e===r.RGBA_ASTC||e===r.RGB_ETC1||e===r.RGB8_ETC2||e===r.RGBA8_ETC2_EAC||e===r.RGBA_BC7},isColorFormat:function(e){return e===r.RED||e===r.ALPHA||e===r.RGB||e===r.RGBA||e===r.LUMINANCE||e===r.LUMINANCE_ALPHA},isDepthFormat:function(e){return e===r.DEPTH_COMPONENT||e===r.DEPTH_STENCIL},isCompressedFormat:function(e){return e===r.RGB_DXT1||e===r.RGBA_DXT1||e===r.RGBA_DXT3||e===r.RGBA_DXT5||e===r.RGB_PVRTC_4BPPV1||e===r.RGB_PVRTC_2BPPV1||e===r.RGBA_PVRTC_4BPPV1||e===r.RGBA_PVRTC_2BPPV1||e===r.RGBA_ASTC||e===r.RGB_ETC1||e===r.RGB8_ETC2||e===r.RGBA8_ETC2_EAC||e===r.RGBA_BC7},isDXTFormat:function(e){return e===r.RGB_DXT1||e===r.RGBA_DXT1||e===r.RGBA_DXT3||e===r.RGBA_DXT5},isPVRTCFormat:function(e){return e===r.RGB_PVRTC_4BPPV1||e===r.RGB_PVRTC_2BPPV1||e===r.RGBA_PVRTC_4BPPV1||e===r.RGBA_PVRTC_2BPPV1},isASTCFormat:function(e){return e===r.RGBA_ASTC},isETC1Format:function(e){return e===r.RGB_ETC1},isETC2Format:function(e){return e===r.RGB8_ETC2||e===r.RGBA8_ETC2_EAC},isBC7Format:function(e){return e===r.RGBA_BC7},compressedTextureSizeInBytes:function(e,t,n){switch(e){case r.RGB_DXT1:case r.RGBA_DXT1:case r.RGB_ETC1:case r.RGB8_ETC2:return Math.floor((t+3)/4)*Math.floor((n+3)/4)*8;case r.RGBA_DXT3:case r.RGBA_DXT5:case r.RGBA_ASTC:case r.RGBA8_ETC2_EAC:return Math.floor((t+3)/4)*Math.floor((n+3)/4)*16;case r.RGB_PVRTC_4BPPV1:case r.RGBA_PVRTC_4BPPV1:return Math.floor((Math.max(t,8)*Math.max(n,8)*4+7)/8);case r.RGB_PVRTC_2BPPV1:case r.RGBA_PVRTC_2BPPV1:return Math.floor((Math.max(t,16)*Math.max(n,8)*2+7)/8);case r.RGBA_BC7:return Math.ceil(t/4)*Math.ceil(n/4)*16;default:return 0}},textureSizeInBytes:function(e,t,n,o){let a=r.componentsLength(e);return i.A.isPacked(t)&&(a=1),a*i.A.sizeInBytes(t)*n*o},texture3DSizeInBytes:function(e,t,n,o,a){let s=r.componentsLength(e);return i.A.isPacked(t)&&(s=1),s*i.A.sizeInBytes(t)*n*o*a},alignmentInBytes:function(e,t,n){const i=r.textureSizeInBytes(e,t,n,1)%4;return 0===i?4:2===i?2:1},createTypedArray:function(e,t,n,o){return new(i.A.getTypedArrayConstructor(t))(r.componentsLength(e)*n*o)},flipY:function(e,t,n,i,o){if(1===o)return e;const a=r.createTypedArray(t,n,i,o),s=r.componentsLength(t),c=i*s;for(let t=0;t<o;++t){const n=t*i*s,r=(o-t-1)*i*s;for(let t=0;t<c;++t)a[r+t]=e[n+t]}return a},toInternalFormat:function(e,t,n){if(!n.webgl2)return e;if(e===r.DEPTH_STENCIL)return o.A.DEPTH24_STENCIL8;if(e===r.DEPTH_COMPONENT){if(t===i.A.UNSIGNED_SHORT)return o.A.DEPTH_COMPONENT16;if(t===i.A.UNSIGNED_INT)return o.A.DEPTH_COMPONENT24}if(t===i.A.FLOAT)switch(e){case r.RGBA:return o.A.RGBA32F;case r.RGB:return o.A.RGB32F;case r.RG:return o.A.RG32F;case r.RED:return o.A.R32F}if(t===i.A.HALF_FLOAT)switch(e){case r.RGBA:return o.A.RGBA16F;case r.RGB:return o.A.RGB16F;case r.RG:return o.A.RG16F;case r.RED:return o.A.R16F}if(t===i.A.UNSIGNED_BYTE)switch(e){case r.RGBA:return o.A.RGBA8;case r.RGB:return o.A.RGB8;case r.RG:return o.A.RG8;case r.RED:return o.A.R8}if(t===i.A.INT)switch(e){case r.RGBA_INTEGER:return o.A.RGBA32I;case r.RGB_INTEGER:return o.A.RGB32I;case r.RG_INTEGER:return o.A.RG32I;case r.RED_INTEGER:return o.A.R32I}if(t===i.A.UNSIGNED_INT)switch(e){case r.RGBA_INTEGER:return o.A.RGBA32UI;case r.RGB_INTEGER:return o.A.RGB32UI;case r.RG_INTEGER:return o.A.RG32UI;case r.RED_INTEGER:return o.A.R32UI}return e}},a=Object.freeze(r)},257941:(e,t,n)=>{"use strict";n.d(t,{A:()=>A});var i=n(267980),o=n(626809),r=n(369031),a=n(491446),s=n(605971),c=n(367817),l=n(584164);function h(e,t){if(r.A.typeOf.object("normal",e),!c.A.equalsEpsilon(i.A.magnitude(e),1,c.A.EPSILON6))throw new s.A("normal must be normalized.");r.A.typeOf.number("distance",t),this.normal=i.A.clone(e),this.distance=t}h.fromPointNormal=function(e,t,n){if(r.A.typeOf.object("point",e),r.A.typeOf.object("normal",t),!c.A.equalsEpsilon(i.A.magnitude(t),1,c.A.EPSILON6))throw new s.A("normal must be normalized.");const o=-i.A.dot(t,e);return(0,a.A)(n)?(i.A.clone(t,n.normal),n.distance=o,n):new h(t,o)};const u=new i.A;h.fromCartesian4=function(e,t){r.A.typeOf.object("coefficients",e);const n=i.A.fromCartesian4(e,u),o=e.w;if(!c.A.equalsEpsilon(i.A.magnitude(n),1,c.A.EPSILON6))throw new s.A("normal must be normalized.");return(0,a.A)(t)?(i.A.clone(n,t.normal),t.distance=o,t):new h(n,o)},h.getPointDistance=function(e,t){return r.A.typeOf.object("plane",e),r.A.typeOf.object("point",t),i.A.dot(e.normal,t)+e.distance};const d=new i.A;h.projectPointOntoPlane=function(e,t,n){r.A.typeOf.object("plane",e),r.A.typeOf.object("point",t),(0,a.A)(n)||(n=new i.A);const o=h.getPointDistance(e,t),s=i.A.multiplyByScalar(e.normal,o,d);return i.A.subtract(t,s,n)};const p=new l.A,m=new o.A,f=new i.A;h.transform=function(e,t,n){r.A.typeOf.object("plane",e),r.A.typeOf.object("transform",t);const a=e.normal,s=e.distance,c=l.A.inverseTranspose(t,p);let u=o.A.fromElements(a.x,a.y,a.z,s,m);u=l.A.multiplyByVector(c,u,u);const d=i.A.fromCartesian4(u,f);return u=o.A.divideByScalar(u,i.A.magnitude(d),u),h.fromCartesian4(u,n)},h.clone=function(e,t){return r.A.typeOf.object("plane",e),(0,a.A)(t)?(i.A.clone(e.normal,t.normal),t.distance=e.distance,t):new h(e.normal,e.distance)},h.equals=function(e,t){return r.A.typeOf.object("left",e),r.A.typeOf.object("right",t),e.distance===t.distance&&i.A.equals(e.normal,t.normal)},h.ORIGIN_XY_PLANE=Object.freeze(new h(i.A.UNIT_Z,0)),h.ORIGIN_YZ_PLANE=Object.freeze(new h(i.A.UNIT_X,0)),h.ORIGIN_ZX_PLANE=Object.freeze(new h(i.A.UNIT_Y,0));const A=h},105330:(e,t,n)=>{"use strict";n.d(t,{A:()=>o});var i=n(491446);const o=function(e,t){this.positions=(0,i.A)(e)?e:[],this.holes=(0,i.A)(t)?t:[]}},402330:(e,t,n)=>{"use strict";n.d(t,{A:()=>r});var i=n(352581);const o={POINTS:i.A.POINTS,LINES:i.A.LINES,LINE_LOOP:i.A.LINE_LOOP,LINE_STRIP:i.A.LINE_STRIP,TRIANGLES:i.A.TRIANGLES,TRIANGLE_STRIP:i.A.TRIANGLE_STRIP,TRIANGLE_FAN:i.A.TRIANGLE_FAN,isLines:function(e){return e===o.LINES||e===o.LINE_LOOP||e===o.LINE_STRIP},isTriangles:function(e){return e===o.TRIANGLES||e===o.TRIANGLE_STRIP||e===o.TRIANGLE_FAN},validate:function(e){return e===o.POINTS||e===o.LINES||e===o.LINE_LOOP||e===o.LINE_STRIP||e===o.TRIANGLES||e===o.TRIANGLE_STRIP||e===o.TRIANGLE_FAN}},r=Object.freeze(o)},118135:(e,t,n)=>{"use strict";n.d(t,{A:()=>s});var i=n(605971),o=n(367817);const r={};function a(e,t,n){const i=e+t;return o.A.sign(e)!==o.A.sign(t)&&Math.abs(i/Math.max(Math.abs(e),Math.abs(t)))<n?0:i}r.computeDiscriminant=function(e,t,n){if("number"!=typeof e)throw new i.A("a is a required number.");if("number"!=typeof t)throw new i.A("b is a required number.");if("number"!=typeof n)throw new i.A("c is a required number.");return t*t-4*e*n},r.computeRealRoots=function(e,t,n){if("number"!=typeof e)throw new i.A("a is a required number.");if("number"!=typeof t)throw new i.A("b is a required number.");if("number"!=typeof n)throw new i.A("c is a required number.");let r;if(0===e)return 0===t?[]:[-n/t];if(0===t){if(0===n)return[0,0];const t=Math.abs(n),i=Math.abs(e);if(t<i&&t/i<o.A.EPSILON14)return[0,0];if(t>i&&i/t<o.A.EPSILON14)return[];if(r=-n/e,r<0)return[];const a=Math.sqrt(r);return[-a,a]}if(0===n)return r=-t/e,r<0?[r,0]:[0,r];const s=a(t*t,-4*e*n,o.A.EPSILON14);if(s<0)return[];const c=-.5*a(t,o.A.sign(t)*Math.sqrt(s),o.A.EPSILON14);return t>0?[c/e,n/c]:[n/c,c/e]};const s=r},173866:(e,t,n)=>{"use strict";n.d(t,{A:()=>c});var i=n(703983),o=n(605971),r=n(367817),a=n(118135);const s={};s.computeDiscriminant=function(e,t,n,i,r){if("number"!=typeof e)throw new o.A("a is a required number.");if("number"!=typeof t)throw new o.A("b is a required number.");if("number"!=typeof n)throw new o.A("c is a required number.");if("number"!=typeof i)throw new o.A("d is a required number.");if("number"!=typeof r)throw new o.A("e is a required number.");const a=e*e,s=t*t,c=s*t,l=n*n,h=l*n,u=i*i,d=u*i,p=r*r;return s*l*u-4*c*d-4*e*h*u+18*e*t*n*d-27*a*u*u+a*e*256*(p*r)+r*(18*c*n*i-4*s*h+16*e*l*l-80*e*t*l*i-6*e*s*u+144*a*n*u)+p*(144*e*s*n-27*s*s-128*a*l-192*a*t*i)},s.computeRealRoots=function(e,t,n,s,c){if("number"!=typeof e)throw new o.A("a is a required number.");if("number"!=typeof t)throw new o.A("b is a required number.");if("number"!=typeof n)throw new o.A("c is a required number.");if("number"!=typeof s)throw new o.A("d is a required number.");if("number"!=typeof c)throw new o.A("e is a required number.");if(Math.abs(e)<r.A.EPSILON15)return i.A.computeRealRoots(t,n,s,c);const l=t/e,h=n/e,u=s/e,d=c/e;let p=l<0?1:0;switch(p+=h<0?p+1:p,p+=u<0?p+1:p,p+=d<0?p+1:p,p){case 0:case 3:case 4:case 6:case 7:case 9:case 10:case 12:case 13:case 14:case 15:return function(e,t,n,o){const s=e*e,c=t-3*s/8,l=n-t*e/2+s*e/8,h=o-n*e/4+t*s/16-3*s*s/256,u=i.A.computeRealRoots(1,2*c,c*c-4*h,-l*l);if(u.length>0){const t=-e/4,n=u[u.length-1];if(Math.abs(n)<r.A.EPSILON14){const e=a.A.computeRealRoots(1,c,h);if(2===e.length){const n=e[0],i=e[1];let o;if(n>=0&&i>=0){const e=Math.sqrt(n),o=Math.sqrt(i);return[t-o,t-e,t+e,t+o]}if(n>=0&&i<0)return o=Math.sqrt(n),[t-o,t+o];if(n<0&&i>=0)return o=Math.sqrt(i),[t-o,t+o]}return[]}if(n>0){const e=Math.sqrt(n),i=(c+n-l/e)/2,o=(c+n+l/e)/2,r=a.A.computeRealRoots(1,e,i),s=a.A.computeRealRoots(1,-e,o);return 0!==r.length?(r[0]+=t,r[1]+=t,0!==s.length?(s[0]+=t,s[1]+=t,r[1]<=s[0]?[r[0],r[1],s[0],s[1]]:s[1]<=r[0]?[s[0],s[1],r[0],r[1]]:r[0]>=s[0]&&r[1]<=s[1]?[s[0],r[0],r[1],s[1]]:s[0]>=r[0]&&s[1]<=r[1]?[r[0],s[0],s[1],r[1]]:r[0]>s[0]&&r[0]<s[1]?[s[0],r[0],s[1],r[1]]:[r[0],s[0],r[1],s[1]]):r):0!==s.length?(s[0]+=t,s[1]+=t,s):[]}}return[]}(l,h,u,d);case 1:case 2:case 5:case 8:case 11:return function(e,t,n,o){const s=e*e,c=-2*t,l=n*e+t*t-4*o,h=s*o-n*t*e+n*n,u=i.A.computeRealRoots(1,c,l,h);if(u.length>0){const i=u[0],c=t-i,l=c*c,h=e/2,d=c/2,p=l-4*o,m=l+4*Math.abs(o),f=s-4*i,A=s+4*Math.abs(i);let _,g,y,v,b,w;if(i<0||p*A<f*m){const t=Math.sqrt(f);_=t/2,g=0===t?0:(e*d-n)/t}else{const t=Math.sqrt(p);_=0===t?0:(e*d-n)/t,g=t/2}0===h&&0===_?(y=0,v=0):r.A.sign(h)===r.A.sign(_)?(y=h+_,v=i/y):(v=h-_,y=i/v),0===d&&0===g?(b=0,w=0):r.A.sign(d)===r.A.sign(g)?(b=d+g,w=o/b):(w=d-g,b=o/w);const T=a.A.computeRealRoots(1,y,b),x=a.A.computeRealRoots(1,v,w);if(0!==T.length)return 0!==x.length?T[1]<=x[0]?[T[0],T[1],x[0],x[1]]:x[1]<=T[0]?[x[0],x[1],T[0],T[1]]:T[0]>=x[0]&&T[1]<=x[1]?[x[0],T[0],T[1],x[1]]:x[0]>=T[0]&&x[1]<=T[1]?[T[0],x[0],x[1],T[1]]:T[0]>x[0]&&T[0]<x[1]?[x[0],T[0],x[1],T[1]]:[T[0],x[0],T[1],x[1]]:T;if(0!==x.length)return x}return[]}(l,h,u,d);default:return}};const c=s},766067:(e,t,n)=>{"use strict";n.d(t,{A:()=>s});var i=n(267980),o=n(369031),r=n(491446);function a(e,t){t=i.A.clone(t??i.A.ZERO),i.A.equals(t,i.A.ZERO)||i.A.normalize(t,t),this.origin=i.A.clone(e??i.A.ZERO),this.direction=t}a.clone=function(e,t){if((0,r.A)(e))return(0,r.A)(t)?(t.origin=i.A.clone(e.origin),t.direction=i.A.clone(e.direction),t):new a(e.origin,e.direction)},a.getPoint=function(e,t,n){return o.A.typeOf.object("ray",e),o.A.typeOf.number("t",t),(0,r.A)(n)||(n=new i.A),n=i.A.multiplyByScalar(e.direction,t,n),i.A.add(e.origin,n,n)};const s=a},886033:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i=Object.freeze({FIXED:0,INERTIAL:1})},971724:(e,t,n)=>{"use strict";n.d(t,{A:()=>y});var i=n(484193),o=n(303578),r=n(491446),a=n(677354),s=n(605971),c=n(955943),l=n(520098),h=n(89104),u=n(744603),d=n(123245);function p(){if(!(0,r.A)(_._canTransferArrayBuffer)){const e=A("transferTypedArrayTest");e.postMessage=e.webkitPostMessage??e.postMessage;const t=99,n=new Int8Array([t]);try{e.postMessage({array:n},[n.buffer])}catch(e){return _._canTransferArrayBuffer=!1,_._canTransferArrayBuffer}_._canTransferArrayBuffer=new Promise(n=>{e.onmessage=function(i){const o=i.data.array,a=(0,r.A)(o)&&o[0]===t;n(a),e.terminate(),_._canTransferArrayBuffer=a}})}return _._canTransferArrayBuffer}const m=new c.A;function f(e){let t;try{t=new Blob([e],{type:"application/javascript"})}catch(n){const i=new(window.BlobBuilder||window.WebKitBlobBuilder||window.MozBlobBuilder||window.MSBlobBuilder);i.append(e),t=i.getBlob("application/javascript")}return(window.URL||window.webkitURL).createObjectURL(t)}function A(e){const t=new i(e),n=0!==t.scheme().length&&0===t.fragment().length,r=e.replace(/\.js$/,""),a={};let s,c;if((0,h.A)(e))c=e;else if(!n){const e=(0,o.A)(`${_._workerModulePrefix}/${r}.js`);(0,h.A)(e)&&(c=e)}if(c)return s=f(`import "${c}";`),a.type="module",new Worker(s,a);if(!n&&"undefined"!=typeof CESIUM_WORKERS){const e=`\n      importScripts("${f(CESIUM_WORKERS)}");\n      CesiumWorkers["${r}"]();\n    `;return s=f(e),new Worker(s,a)}if(s=e,n||(s=(0,o.A)(`${_._workerModulePrefix+r}.js`)),!l.A.supportsEsmWebWorkers())throw new d.A("This browser is not supported. Please update your browser to continue.");return a.type="module",new Worker(s,a)}function _(e,t){this._workerPath=e,this._maximumActiveTasks=t??Number.POSITIVE_INFINITY,this._activeTasks=0,this._nextID=0,this._webAssemblyPromise=void 0}const g=[];_.prototype.scheduleTask=function(e,t){if((0,r.A)(this._worker)||(this._worker=A(this._workerPath)),!(this._activeTasks>=this._maximumActiveTasks))return async function(e,t,n){++e._activeTasks;try{const i=await async function(e,t,n){const i=await Promise.resolve(p());(0,r.A)(n)?i||(n.length=0):n=g;const a=e._nextID++,c=new Promise((t,n)=>{e._worker.addEventListener("message",((e,t,n,i)=>{const o=({data:a})=>{if(a.id===t){if((0,r.A)(a.error)){let e=a.error;"RuntimeError"===e.name?(e=new d.A(a.error.message),e.stack=a.error.stack):"DeveloperError"===e.name?(e=new s.A(a.error.message),e.stack=a.error.stack):"Error"===e.name&&(e=new Error(a.error.message),e.stack=a.error.stack),m.raiseEvent(e),i(e)}else m.raiseEvent(),n(a.result);e.removeEventListener("message",o)}};return o})(e._worker,a,t,n))});return e._worker.postMessage({id:a,baseUrl:o.A.getCesiumBaseUrl().url,parameters:t,canTransferArrayBuffer:i},n),c}(e,t,n);return--e._activeTasks,i}catch(t){throw--e._activeTasks,t}}(this,e,t)},_.prototype.initWebAssemblyModule=async function(e){return(0,r.A)(this._webAssemblyPromise)||(this._webAssemblyPromise=(async()=>{const t=this._worker=A(this._workerPath),n=await async function(e,t){const n={modulePath:void 0,wasmBinaryFile:void 0,wasmBinary:void 0};if(!l.A.supportsWebAssembly()){if(!(0,r.A)(t.fallbackModulePath))throw new d.A(`This browser does not support Web Assembly, and no backup module was provided for ${e._workerPath}`);return n.modulePath=(0,o.A)(t.fallbackModulePath),n}n.wasmBinaryFile=(0,o.A)(t.wasmBinaryFile);const i=await u.A.fetchArrayBuffer({url:n.wasmBinaryFile});return n.wasmBinary=i,n}(this,e),i=await Promise.resolve(p());let a;const s=n.wasmBinary;(0,r.A)(s)&&i&&(a=[s]);const c=new Promise((e,n)=>{t.onmessage=function({data:t}){(0,r.A)(t)?e(t.result):n(new d.A("Could not configure wasm module"))}});return t.postMessage({canTransferArrayBuffer:i,parameters:{webAssemblyConfig:n}},a),c})()),this._webAssemblyPromise},_.prototype.isDestroyed=function(){return!1},_.prototype.destroy=function(){return(0,r.A)(this._worker)&&this._worker.terminate(),(0,a.A)(this)},_.taskCompletedEvent=m,_._defaultWorkerModulePrefix="Workers/",_._workerModulePrefix=_._defaultWorkerModulePrefix,_._canTransferArrayBuffer=void 0;const y=_},878626:(e,t,n)=>{"use strict";n.d(t,{A:()=>c});var i=n(647934),o=n(369031),r=n(491446);function a({x:e,y:t,width:n,height:o}){this.rectangle=new i.A(e,t,n,o),this.childNode1=void 0,this.childNode2=void 0,this.index=void 0}function s({width:e,height:t,borderPadding:n}){this._width=e,this._height=t,this._borderPadding=n,this._root=new a({x:n,y:n,width:e-2*n,height:t-2*n})}s.prototype.pack=function(e,{width:t,height:n}){o.A.typeOf.number.greaterThanOrEquals("index",e,0),o.A.typeOf.number.greaterThanOrEquals("image.width",t,1),o.A.typeOf.number.greaterThanOrEquals("image.height",n,1);const i=this._findNode(this._root,{width:t,height:n});if((0,r.A)(i))return i.index=e,i},s.prototype._findNode=function(e,{width:t,height:n}){if((0,r.A)(e)){if(!(0,r.A)(e.childNode1)&&!(0,r.A)(e.childNode2)){if((0,r.A)(e.index))return;const{rectangle:i}=e,o=i.width,s=i.height,c=o-t,l=s-n;if(c<0||l<0)return;return 0===c&&0===l?e:c>l?(e.childNode1=new a({x:i.x,y:i.y,width:t,height:s}),e.childNode2=new a({x:i.x+t,y:i.y,width:c,height:s}),this._findNode(e.childNode1,{width:t,height:n})):(e.childNode1=new a({x:i.x,y:i.y,width:o,height:n}),e.childNode2=new a({x:i.x,y:i.y+n,width:o,height:l}),this._findNode(e.childNode1,{width:t,height:n}))}return this._findNode(e.childNode1,{width:t,height:n})||this._findNode(e.childNode2,{width:t,height:n})}};const c=s},93467:(e,t,n)=>{"use strict";n.d(t,{A:()=>h});var i=n(369031),o=n(915325),r=n(491446),a=n(605971),s=n(591978);function c(e){e=e??o.A.EMPTY_OBJECT,this.start=(0,r.A)(e.start)?s.A.clone(e.start):new s.A,this.stop=(0,r.A)(e.stop)?s.A.clone(e.stop):new s.A,this.data=e.data,this.isStartIncluded=e.isStartIncluded??!0,this.isStopIncluded=e.isStopIncluded??!0}Object.defineProperties(c.prototype,{isEmpty:{get:function(){const e=s.A.compare(this.stop,this.start);return e<0||0===e&&(!this.isStartIncluded||!this.isStopIncluded)}}});const l={start:void 0,stop:void 0,isStartIncluded:void 0,isStopIncluded:void 0,data:void 0};c.fromIso8601=function(e,t){i.A.typeOf.object("options",e),i.A.typeOf.string("options.iso8601",e.iso8601);const n=e.iso8601.split("/");if(2!==n.length)throw new a.A("options.iso8601 is an invalid ISO 8601 interval.");const o=s.A.fromIso8601(n[0]),h=s.A.fromIso8601(n[1]),u=e.isStartIncluded??!0,d=e.isStopIncluded??!0,p=e.data;return(0,r.A)(t)?(t.start=o,t.stop=h,t.isStartIncluded=u,t.isStopIncluded=d,t.data=p,t):(l.start=o,l.stop=h,l.isStartIncluded=u,l.isStopIncluded=d,l.data=p,new c(l))},c.toIso8601=function(e,t){return i.A.typeOf.object("timeInterval",e),`${s.A.toIso8601(e.start,t)}/${s.A.toIso8601(e.stop,t)}`},c.clone=function(e,t){if((0,r.A)(e))return(0,r.A)(t)?(t.start=e.start,t.stop=e.stop,t.isStartIncluded=e.isStartIncluded,t.isStopIncluded=e.isStopIncluded,t.data=e.data,t):new c(e)},c.equals=function(e,t,n){return e===t||(0,r.A)(e)&&(0,r.A)(t)&&(e.isEmpty&&t.isEmpty||e.isStartIncluded===t.isStartIncluded&&e.isStopIncluded===t.isStopIncluded&&s.A.equals(e.start,t.start)&&s.A.equals(e.stop,t.stop)&&(e.data===t.data||(0,r.A)(n)&&n(e.data,t.data)))},c.equalsEpsilon=function(e,t,n,i){return n=n??0,e===t||(0,r.A)(e)&&(0,r.A)(t)&&(e.isEmpty&&t.isEmpty||e.isStartIncluded===t.isStartIncluded&&e.isStopIncluded===t.isStopIncluded&&s.A.equalsEpsilon(e.start,t.start,n)&&s.A.equalsEpsilon(e.stop,t.stop,n)&&(e.data===t.data||(0,r.A)(i)&&i(e.data,t.data)))},c.intersect=function(e,t,n,o){if(i.A.typeOf.object("left",e),!(0,r.A)(t))return c.clone(c.EMPTY,n);const a=e.start,l=e.stop,h=t.start,u=t.stop,d=s.A.greaterThanOrEquals(h,a)&&s.A.greaterThanOrEquals(l,h),p=!d&&s.A.lessThanOrEquals(h,a)&&s.A.lessThanOrEquals(a,u);if(!d&&!p)return c.clone(c.EMPTY,n);const m=e.isStartIncluded,f=e.isStopIncluded,A=t.isStartIncluded,_=t.isStopIncluded,g=s.A.lessThan(l,u);return(0,r.A)(n)||(n=new c),n.start=d?h:a,n.isStartIncluded=m&&A||!s.A.equals(h,a)&&(d&&A||p&&m),n.stop=g?l:u,n.isStopIncluded=g?f:f&&_||!s.A.equals(u,l)&&_,n.data=(0,r.A)(o)?o(e.data,t.data):e.data,n},c.contains=function(e,t){if(i.A.typeOf.object("timeInterval",e),i.A.typeOf.object("julianDate",t),e.isEmpty)return!1;const n=s.A.compare(e.start,t);if(0===n)return e.isStartIncluded;const o=s.A.compare(t,e.stop);return 0===o?e.isStopIncluded:n<0&&o<0},c.prototype.clone=function(e){return c.clone(this,e)},c.prototype.equals=function(e,t){return c.equals(this,e,t)},c.prototype.equalsEpsilon=function(e,t,n){return c.equalsEpsilon(this,e,t,n)},c.prototype.toString=function(){return c.toIso8601(this)},c.EMPTY=Object.freeze(new c({start:new s.A,stop:new s.A,isStartIncluded:!1,isStopIncluded:!1}));const h=c},343899:(e,t,n)=>{"use strict";n.d(t,{A:()=>s});var i=n(915325),o=n(491446),r=n(605971);const a={calculateACMR:function(e){const t=(e=e??i.A.EMPTY_OBJECT).indices;let n=e.maximumIndex;const a=e.cacheSize??24;if(!(0,o.A)(t))throw new r.A("indices is required.");const s=t.length;if(s<3||s%3!=0)throw new r.A("indices length must be a multiple of three.");if(n<=0)throw new r.A("maximumIndex must be greater than zero.");if(a<3)throw new r.A("cacheSize must be greater than two.");if(!(0,o.A)(n)){n=0;let e=0,i=t[e];for(;e<s;)i>n&&(n=i),++e,i=t[e]}const c=[];for(let e=0;e<n+1;e++)c[e]=0;let l=a+1;for(let e=0;e<s;++e)l-c[t[e]]>a&&(c[t[e]]=l,++l);return(l-a+1)/(s/3)},tipsify:function(e){const t=(e=e??i.A.EMPTY_OBJECT).indices,n=e.maximumIndex,a=e.cacheSize??24;let s;function c(e,t,n,i,o,r,a){let c,l=-1,h=-1,u=0;for(;u<n.length;){const e=n[u];i[e].numLiveTriangles&&(c=0,o-i[e].timeStamp+2*i[e].numLiveTriangles<=t&&(c=o-i[e].timeStamp),(c>h||-1===h)&&(h=c,l=e)),++u}return-1===l?function(e,t,n,i){for(;t.length>=1;){const n=t[t.length-1];if(t.splice(t.length-1,1),e[n].numLiveTriangles>0)return n}for(;s<i;){if(e[s].numLiveTriangles>0)return++s,s-1;++s}return-1}(i,r,0,a):l}if(!(0,o.A)(t))throw new r.A("indices is required.");const l=t.length;if(l<3||l%3!=0)throw new r.A("indices length must be a multiple of three.");if(n<=0)throw new r.A("maximumIndex must be greater than zero.");if(a<3)throw new r.A("cacheSize must be greater than two.");let h=0,u=0,d=t[u];const p=l;if((0,o.A)(n))h=n+1;else{for(;u<p;)d>h&&(h=d),++u,d=t[u];if(-1===h)return 0;++h}const m=[];let f;for(f=0;f<h;f++)m[f]={numLiveTriangles:0,timeStamp:0,vertexTriangles:[]};u=0;let A=0;for(;u<p;)m[t[u]].vertexTriangles.push(A),++m[t[u]].numLiveTriangles,m[t[u+1]].vertexTriangles.push(A),++m[t[u+1]].numLiveTriangles,m[t[u+2]].vertexTriangles.push(A),++m[t[u+2]].numLiveTriangles,++A,u+=3;let _=0,g=a+1;s=1;let y=[];const v=[];let b,w,T=0;const x=[],C=l/3,E=[];for(f=0;f<C;f++)E[f]=!1;let S,D;for(;-1!==_;){y=[],w=m[_],D=w.vertexTriangles.length;for(let e=0;e<D;++e)if(A=w.vertexTriangles[e],!E[A]){E[A]=!0,u=A+A+A;for(let e=0;e<3;++e)S=t[u],y.push(S),v.push(S),x[T]=S,++T,b=m[S],--b.numLiveTriangles,g-b.timeStamp>a&&(b.timeStamp=g,++g),++u}_=c(0,a,y,m,g,v,h)}return x}},s=a},73772:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i=Object.freeze({AUTODETECT:0,ENU:1,INERTIAL:2,VELOCITY:3})},884842:(e,t,n)=>{"use strict";n.d(t,{A:()=>h});var i=n(267980),o=n(491446),r=n(99479);const a=new i.A(1,1,1),s=i.A.ZERO,c=r.A.IDENTITY;function l(e,t,n){this.translation=i.A.clone(e??s),this.rotation=r.A.clone(t??c),this.scale=i.A.clone(n??a)}l.prototype.equals=function(e){return this===e||(0,o.A)(e)&&i.A.equals(this.translation,e.translation)&&r.A.equals(this.rotation,e.rotation)&&i.A.equals(this.scale,e.scale)};const h=l},769534:(e,t,n)=>{"use strict";n.d(t,{A:()=>s});var i=n(915325),o=n(491446),r=n(605971);function a(e){e=e??i.A.EMPTY_OBJECT,this.position=e.position??!1,this.normal=e.normal??!1,this.st=e.st??!1,this.bitangent=e.bitangent??!1,this.tangent=e.tangent??!1,this.color=e.color??!1}a.POSITION_ONLY=Object.freeze(new a({position:!0})),a.POSITION_AND_NORMAL=Object.freeze(new a({position:!0,normal:!0})),a.POSITION_NORMAL_AND_ST=Object.freeze(new a({position:!0,normal:!0,st:!0})),a.POSITION_AND_ST=Object.freeze(new a({position:!0,st:!0})),a.POSITION_AND_COLOR=Object.freeze(new a({position:!0,color:!0})),a.ALL=Object.freeze(new a({position:!0,normal:!0,st:!0,tangent:!0,bitangent:!0})),a.DEFAULT=a.POSITION_NORMAL_AND_ST,a.packedLength=6,a.pack=function(e,t,n){if(!(0,o.A)(e))throw new r.A("value is required");if(!(0,o.A)(t))throw new r.A("array is required");return n=n??0,t[n++]=e.position?1:0,t[n++]=e.normal?1:0,t[n++]=e.st?1:0,t[n++]=e.tangent?1:0,t[n++]=e.bitangent?1:0,t[n]=e.color?1:0,t},a.unpack=function(e,t,n){if(!(0,o.A)(e))throw new r.A("array is required");return t=t??0,(0,o.A)(n)||(n=new a),n.position=1===e[t++],n.normal=1===e[t++],n.st=1===e[t++],n.tangent=1===e[t++],n.bitangent=1===e[t++],n.color=1===e[t],n},a.clone=function(e,t){if((0,o.A)(e))return(0,o.A)(t)||(t=new a),t.position=e.position,t.normal=e.normal,t.st=e.st,t.tangent=e.tangent,t.bitangent=e.bitangent,t.color=e.color,t};const s=a},717339:(e,t,n)=>{"use strict";n.d(t,{A:()=>l});var i=n(267980),o=n(336946),r=n(605971),a=n(491446);const s={getHeight:function(e,t,n){if(!Number.isFinite(t))throw new r.A("scale must be a finite number.");if(!Number.isFinite(n))throw new r.A("relativeHeight must be a finite number.");return(e-n)*t+n}},c=new o.A;s.getPosition=function(e,t,n,o,r){const l=t.cartesianToCartographic(e,c);if(!(0,a.A)(l))return i.A.clone(e,r);const h=s.getHeight(l.height,n,o);return i.A.fromRadians(l.longitude,l.latitude,h,t,r)};const l=s},414305:(e,t,n)=>{"use strict";n.d(t,{A:()=>h});var i=n(267980),o=n(336946),r=n(491446),a=n(605971),s=n(610750),c=n(367817);function l(e){this._ellipsoid=e??s.A.WGS84,this._semimajorAxis=this._ellipsoid.maximumRadius,this._oneOverSemimajorAxis=1/this._semimajorAxis}Object.defineProperties(l.prototype,{ellipsoid:{get:function(){return this._ellipsoid}}}),l.mercatorAngleToGeodeticLatitude=function(e){return c.A.PI_OVER_TWO-2*Math.atan(Math.exp(-e))},l.geodeticLatitudeToMercatorAngle=function(e){e>l.MaximumLatitude?e=l.MaximumLatitude:e<-l.MaximumLatitude&&(e=-l.MaximumLatitude);const t=Math.sin(e);return.5*Math.log((1+t)/(1-t))},l.MaximumLatitude=l.mercatorAngleToGeodeticLatitude(Math.PI),l.prototype.project=function(e,t){const n=this._semimajorAxis,o=e.longitude*n,a=l.geodeticLatitudeToMercatorAngle(e.latitude)*n,s=e.height;return(0,r.A)(t)?(t.x=o,t.y=a,t.z=s,t):new i.A(o,a,s)},l.prototype.unproject=function(e,t){if(!(0,r.A)(e))throw new a.A("cartesian is required");const n=this._oneOverSemimajorAxis,i=e.x*n,s=l.mercatorAngleToGeodeticLatitude(e.y*n),c=e.z;return(0,r.A)(t)?(t.longitude=i,t.latitude=s,t.height=c,t):new o.A(i,s,c)};const h=l},666765:(e,t,n)=>{"use strict";n.d(t,{A:()=>r});var i=n(352581);const o={CLOCKWISE:i.A.CW,COUNTER_CLOCKWISE:i.A.CCW,validate:function(e){return e===o.CLOCKWISE||e===o.COUNTER_CLOCKWISE}},r=Object.freeze(o)},263604:(e,t,n)=>{"use strict";n.d(t,{A:()=>a});var i=n(369031),o=n(491446);const r=n(367817).A.EPSILON10,a=function(e,t,n,a){if(i.A.defined("equalsEpsilon",t),!(0,o.A)(e))return;n=n??!1;const s=(0,o.A)(a),c=e.length;if(c<2)return e;let l,h,u,d=e[0],p=0,m=-1;for(l=1;l<c;++l)h=e[l],t(d,h,r)?((0,o.A)(u)||(u=e.slice(0,l),p=l-1,m=0),s&&a.push(l)):((0,o.A)(u)&&(u.push(h),p=l,s&&(m=a.length)),d=h);return n&&t(e[0],e[c-1],r)&&(s&&((0,o.A)(u)?a.splice(m,0,p):a.push(c-1)),(0,o.A)(u)?u.length-=1:u=e.slice(0,-1)),(0,o.A)(u)?u:e}},744436:(e,t,n)=>{"use strict";n.d(t,{A:()=>u});var i=n(434067),o=n(267980),r=n(369031),a=n(491446),s=n(367817);const c=new o.A,l=new o.A,h=new o.A,u=function(e,t,n,u,d){let p,m,f,A,_,g,y,v;if(r.A.defined("point",e),r.A.defined("p0",t),r.A.defined("p1",n),r.A.defined("p2",u),(0,a.A)(d)||(d=new o.A),(0,a.A)(t.z)){if(o.A.equalsEpsilon(e,t,s.A.EPSILON14))return o.A.clone(o.A.UNIT_X,d);if(o.A.equalsEpsilon(e,n,s.A.EPSILON14))return o.A.clone(o.A.UNIT_Y,d);if(o.A.equalsEpsilon(e,u,s.A.EPSILON14))return o.A.clone(o.A.UNIT_Z,d);p=o.A.subtract(n,t,c),m=o.A.subtract(u,t,l),f=o.A.subtract(e,t,h),A=o.A.dot(p,p),_=o.A.dot(p,m),g=o.A.dot(p,f),y=o.A.dot(m,m),v=o.A.dot(m,f)}else{if(i.A.equalsEpsilon(e,t,s.A.EPSILON14))return o.A.clone(o.A.UNIT_X,d);if(i.A.equalsEpsilon(e,n,s.A.EPSILON14))return o.A.clone(o.A.UNIT_Y,d);if(i.A.equalsEpsilon(e,u,s.A.EPSILON14))return o.A.clone(o.A.UNIT_Z,d);p=i.A.subtract(n,t,c),m=i.A.subtract(u,t,l),f=i.A.subtract(e,t,h),A=i.A.dot(p,p),_=i.A.dot(p,m),g=i.A.dot(p,f),y=i.A.dot(m,m),v=i.A.dot(m,f)}d.y=y*g-_*v,d.z=A*v-_*g;const b=A*y-_*_;if(0!==b)return d.y/=b,d.z/=b,d.x=1-d.y-d.z,d}},673874:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i=function(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,function(e){const t=16*Math.random()|0;return("x"===e?t:3&t|8).toString(16)})}},471874:(e,t,n)=>{"use strict";n.d(t,{A:()=>c});var i=n(369031),o=n(744603),r=n(708025);let a;function s(e){let t;return i.A.defined("resourceOrUrlOrBuffer",e),t=e instanceof ArrayBuffer||ArrayBuffer.isView(e)?Promise.resolve(e):o.A.createIfNeeded(e).fetchArrayBuffer(),t.then(function(e){return r.A.transcode(e,a)})}s.setKTX2SupportedFormats=function(e,t,n,i,o,r){a={s3tc:e,pvrtc:t,astc:n,etc:i,etc1:o,bc7:r}};const c=s},841387:(e,t,n)=>{"use strict";n.d(t,{A:()=>r});var i=n(491446),o=n(605971);const r=function(e,t){if(!(0,i.A)(e))throw new o.A("array is required.");if(!(0,i.A)(t)||t<1)throw new o.A("numberOfArrays must be greater than 0.");const n=[],r=e.length;let a=0;for(;a<r;){const i=Math.ceil((r-a)/t--);n.push(e.slice(a,a+i)),a+=i}return n}},517638:(e,t,n)=>{"use strict";n.d(t,{A:()=>c});var i=n(41476),o=n(915325),r=n(491446),a=n(605971);let s;const c=function(e,t){if(!(0,r.A)(e))throw new a.A("text is required.");if(""===e)return;const n=(t=t??o.A.EMPTY_OBJECT).font??"10px sans-serif",c=t.stroke??!1,l=t.fill??!0,h=t.strokeWidth??1,u=t.backgroundColor??i.A.TRANSPARENT,d=t.padding??0,p=2*d,m=document.createElement("canvas");m.width=1,m.height=1,m.style.font=n;const f=m.getContext("2d",{willReadFrequently:!0});(0,r.A)(s)||((0,r.A)(f.imageSmoothingEnabled)?s="imageSmoothingEnabled":(0,r.A)(f.mozImageSmoothingEnabled)?s="mozImageSmoothingEnabled":(0,r.A)(f.webkitImageSmoothingEnabled)?s="webkitImageSmoothingEnabled":(0,r.A)(f.msImageSmoothingEnabled)&&(s="msImageSmoothingEnabled")),f.font=n,f.lineJoin="round",f.lineWidth=h,f[s]=!1,m.style.visibility="hidden",document.body.appendChild(m);const A=function(e,t,n,i,o){const r=e.measureText(t);if(/\S/.test(t)){const a=document.defaultView.getComputedStyle(e.canvas).getPropertyValue("font-size").replace("px",""),s=document.createElement("canvas"),c=100,l=r.width+c|0,h=3*a,u=h/2;s.width=l,s.height=h;const d=s.getContext("2d");d.font=n,d.fillStyle="white",d.fillRect(0,0,s.width+1,s.height+1),i&&(d.strokeStyle="black",d.lineWidth=e.lineWidth,d.strokeText(t,c/2,u)),o&&(d.fillStyle="black",d.fillText(t,c/2,u));const p=d.getImageData(0,0,l,h).data,m=p.length,f=4*l;let A,_,g,y;for(A=0;A<m;++A)if(255!==p[A]){g=A/f|0;break}for(A=m-1;A>=0;--A)if(255!==p[A]){y=A/f|0;break}let v=-1;for(A=0;A<l&&-1===v;++A)for(_=0;_<h;++_){const e=4*A+_*f;if(255!==p[e]||255!==p[e+1]||255!==p[e+2]||255!==p[e+3]){v=A;break}}return{width:r.width,height:y-g,ascent:u-g,descent:y-u,minx:v-c/2}}return{width:r.width,height:0,ascent:0,descent:0,minx:0}}(f,e,n,c,l);m.dimensions=A,document.body.removeChild(m),m.style.visibility="";const _=-A.minx,g=Math.ceil(A.width)+_+p,y=A.height+p,v=y-(y-A.ascent+d)+p;if(m.width=g,m.height=y,f.font=n,f.lineJoin="round",f.lineWidth=h,f[s]=!1,u!==i.A.TRANSPARENT&&(f.fillStyle=u.toCssColorString(),f.fillRect(0,0,m.width,m.height)),c){const n=t.strokeColor??i.A.BLACK;f.strokeStyle=n.toCssColorString(),f.strokeText(e,_+d,v)}if(l){const n=t.fillColor??i.A.WHITE;f.fillStyle=n.toCssColorString(),f.fillText(e,_+d,v)}return m}},470540:(e,t,n)=>{"use strict";n.d(t,{A:()=>l});var i=n(915325),o=n(491446),r=n(605971),a=n(955943),s=n(819488);function c(e){this._definitionChanged=new a.A,this._show=void 0,this._showSubscription=void 0,this._image=void 0,this._imageSubscription=void 0,this._scale=void 0,this._scaleSubscription=void 0,this._pixelOffset=void 0,this._pixelOffsetSubscription=void 0,this._eyeOffset=void 0,this._eyeOffsetSubscription=void 0,this._horizontalOrigin=void 0,this._horizontalOriginSubscription=void 0,this._verticalOrigin=void 0,this._verticalOriginSubscription=void 0,this._heightReference=void 0,this._heightReferenceSubscription=void 0,this._color=void 0,this._colorSubscription=void 0,this._rotation=void 0,this._rotationSubscription=void 0,this._alignedAxis=void 0,this._alignedAxisSubscription=void 0,this._sizeInMeters=void 0,this._sizeInMetersSubscription=void 0,this._width=void 0,this._widthSubscription=void 0,this._height=void 0,this._heightSubscription=void 0,this._scaleByDistance=void 0,this._scaleByDistanceSubscription=void 0,this._translucencyByDistance=void 0,this._translucencyByDistanceSubscription=void 0,this._pixelOffsetScaleByDistance=void 0,this._pixelOffsetScaleByDistanceSubscription=void 0,this._imageSubRegion=void 0,this._imageSubRegionSubscription=void 0,this._distanceDisplayCondition=void 0,this._distanceDisplayConditionSubscription=void 0,this._disableDepthTestDistance=void 0,this._disableDepthTestDistanceSubscription=void 0,this._splitDirection=void 0,this._splitDirectionSubscription=void 0,this.merge(e??i.A.EMPTY_OBJECT)}Object.defineProperties(c.prototype,{definitionChanged:{get:function(){return this._definitionChanged}},show:(0,s.A)("show"),image:(0,s.A)("image"),scale:(0,s.A)("scale"),pixelOffset:(0,s.A)("pixelOffset"),eyeOffset:(0,s.A)("eyeOffset"),horizontalOrigin:(0,s.A)("horizontalOrigin"),verticalOrigin:(0,s.A)("verticalOrigin"),heightReference:(0,s.A)("heightReference"),color:(0,s.A)("color"),rotation:(0,s.A)("rotation"),alignedAxis:(0,s.A)("alignedAxis"),sizeInMeters:(0,s.A)("sizeInMeters"),width:(0,s.A)("width"),height:(0,s.A)("height"),scaleByDistance:(0,s.A)("scaleByDistance"),translucencyByDistance:(0,s.A)("translucencyByDistance"),pixelOffsetScaleByDistance:(0,s.A)("pixelOffsetScaleByDistance"),imageSubRegion:(0,s.A)("imageSubRegion"),distanceDisplayCondition:(0,s.A)("distanceDisplayCondition"),disableDepthTestDistance:(0,s.A)("disableDepthTestDistance"),splitDirection:(0,s.A)("splitDirection")}),c.prototype.clone=function(e){return(0,o.A)(e)?(e.show=this._show,e.image=this._image,e.scale=this._scale,e.pixelOffset=this._pixelOffset,e.eyeOffset=this._eyeOffset,e.horizontalOrigin=this._horizontalOrigin,e.verticalOrigin=this._verticalOrigin,e.heightReference=this._heightReference,e.color=this._color,e.rotation=this._rotation,e.alignedAxis=this._alignedAxis,e.sizeInMeters=this._sizeInMeters,e.width=this._width,e.height=this._height,e.scaleByDistance=this._scaleByDistance,e.translucencyByDistance=this._translucencyByDistance,e.pixelOffsetScaleByDistance=this._pixelOffsetScaleByDistance,e.imageSubRegion=this._imageSubRegion,e.distanceDisplayCondition=this._distanceDisplayCondition,e.disableDepthTestDistance=this._disableDepthTestDistance,e.splitDirection=this._splitDirection,e):new c(this)},c.prototype.merge=function(e){if(!(0,o.A)(e))throw new r.A("source is required.");this.show=this._show??e.show,this.image=this._image??e.image,this.scale=this._scale??e.scale,this.pixelOffset=this._pixelOffset??e.pixelOffset,this.eyeOffset=this._eyeOffset??e.eyeOffset,this.horizontalOrigin=this._horizontalOrigin??e.horizontalOrigin,this.verticalOrigin=this._verticalOrigin??e.verticalOrigin,this.heightReference=this._heightReference??e.heightReference,this.color=this._color??e.color,this.rotation=this._rotation??e.rotation,this.alignedAxis=this._alignedAxis??e.alignedAxis,this.sizeInMeters=this._sizeInMeters??e.sizeInMeters,this.width=this._width??e.width,this.height=this._height??e.height,this.scaleByDistance=this._scaleByDistance??e.scaleByDistance,this.translucencyByDistance=this._translucencyByDistance??e.translucencyByDistance,this.pixelOffsetScaleByDistance=this._pixelOffsetScaleByDistance??e.pixelOffsetScaleByDistance,this.imageSubRegion=this._imageSubRegion??e.imageSubRegion,this.distanceDisplayCondition=this._distanceDisplayCondition??e.distanceDisplayCondition,this.disableDepthTestDistance=this._disableDepthTestDistance??e.disableDepthTestDistance,this.splitDirection=this.splitDirection??e.splitDirection};const l=c},326230:(e,t,n)=>{"use strict";n.d(t,{A:()=>h});var i=n(915325),o=n(491446),r=n(605971),a=n(955943),s=n(802733),c=n(819488);function l(e){this._definitionChanged=new a.A,this._show=void 0,this._showSubscription=void 0,this._dimensions=void 0,this._dimensionsSubscription=void 0,this._heightReference=void 0,this._heightReferenceSubscription=void 0,this._fill=void 0,this._fillSubscription=void 0,this._material=void 0,this._materialSubscription=void 0,this._outline=void 0,this._outlineSubscription=void 0,this._outlineColor=void 0,this._outlineColorSubscription=void 0,this._outlineWidth=void 0,this._outlineWidthSubscription=void 0,this._shadows=void 0,this._shadowsSubscription=void 0,this._distanceDisplayCondition=void 0,this._distanceDisplayConditionSubscription=void 0,this.merge(e??i.A.EMPTY_OBJECT)}Object.defineProperties(l.prototype,{definitionChanged:{get:function(){return this._definitionChanged}},show:(0,c.A)("show"),dimensions:(0,c.A)("dimensions"),heightReference:(0,c.A)("heightReference"),fill:(0,c.A)("fill"),material:(0,s.A)("material"),outline:(0,c.A)("outline"),outlineColor:(0,c.A)("outlineColor"),outlineWidth:(0,c.A)("outlineWidth"),shadows:(0,c.A)("shadows"),distanceDisplayCondition:(0,c.A)("distanceDisplayCondition")}),l.prototype.clone=function(e){return(0,o.A)(e)?(e.show=this.show,e.dimensions=this.dimensions,e.heightReference=this.heightReference,e.fill=this.fill,e.material=this.material,e.outline=this.outline,e.outlineColor=this.outlineColor,e.outlineWidth=this.outlineWidth,e.shadows=this.shadows,e.distanceDisplayCondition=this.distanceDisplayCondition,e):new l(this)},l.prototype.merge=function(e){if(!(0,o.A)(e))throw new r.A("source is required.");this.show=this.show??e.show,this.dimensions=this.dimensions??e.dimensions,this.heightReference=this.heightReference??e.heightReference,this.fill=this.fill??e.fill,this.material=this.material??e.material,this.outline=this.outline??e.outline,this.outlineColor=this.outlineColor??e.outlineColor,this.outlineWidth=this.outlineWidth??e.outlineWidth,this.shadows=this.shadows??e.shadows,this.distanceDisplayCondition=this.distanceDisplayCondition??e.distanceDisplayCondition};const h=l},692632:(e,t,n)=>{"use strict";n.d(t,{A:()=>l});var i=n(915325),o=n(491446),r=n(605971),a=n(955943),s=n(819488);function c(e){this._definitionChanged=new a.A,this._show=void 0,this._showSubscription=void 0,this._uri=void 0,this._uriSubscription=void 0,this._maximumScreenSpaceError=void 0,this._maximumScreenSpaceErrorSubscription=void 0,this.merge(e??i.A.EMPTY_OBJECT)}Object.defineProperties(c.prototype,{definitionChanged:{get:function(){return this._definitionChanged}},show:(0,s.A)("show"),uri:(0,s.A)("uri"),maximumScreenSpaceError:(0,s.A)("maximumScreenSpaceError")}),c.prototype.clone=function(e){return(0,o.A)(e)?(e.show=this.show,e.uri=this.uri,e.maximumScreenSpaceError=this.maximumScreenSpaceError,e):new c(this)},c.prototype.merge=function(e){if(!(0,o.A)(e))throw new r.A("source is required.");this.show=this.show??e.show,this.uri=this.uri??e.uri,this.maximumScreenSpaceError=this.maximumScreenSpaceError??e.maximumScreenSpaceError};const l=c},312421:(e,t,n)=>{"use strict";n.d(t,{A:()=>u});var i=n(41476),o=n(491446),r=n(955943),a=n(591978),s=n(819488),c=n(46257);function l(e){this._definitionChanged=new r.A,this._color=void 0,this._colorSubscription=void 0,this.color=e}Object.defineProperties(l.prototype,{isConstant:{get:function(){return c.A.isConstant(this._color)}},definitionChanged:{get:function(){return this._definitionChanged}},color:(0,s.A)("color")}),l.prototype.getType=function(e){return"Color"};const h=new a.A;l.prototype.getValue=function(e,t){return(0,o.A)(e)||(e=a.A.now(h)),(0,o.A)(t)||(t={}),t.color=c.A.getValueOrClonedDefault(this._color,e,i.A.WHITE,t.color),t},l.prototype.equals=function(e){return this===e||e instanceof l&&c.A.equals(this._color,e._color)};const u=l},808938:(e,t,n)=>{"use strict";n.d(t,{A:()=>d});var i=n(267980),o=n(491446),r=n(605971),a=n(955943),s=n(591978),c=n(886033),l=n(759078);function h(e,t){this._definitionChanged=new a.A,this._value=i.A.clone(e),this._referenceFrame=t??c.A.FIXED}Object.defineProperties(h.prototype,{isConstant:{get:function(){return!(0,o.A)(this._value)||this._referenceFrame===c.A.FIXED}},definitionChanged:{get:function(){return this._definitionChanged}},referenceFrame:{get:function(){return this._referenceFrame}}});const u=new s.A;h.prototype.getValue=function(e,t){return(0,o.A)(e)||(e=s.A.now(u)),this.getValueInReferenceFrame(e,c.A.FIXED,t)},h.prototype.setValue=function(e,t){let n=!1;i.A.equals(this._value,e)||(n=!0,this._value=i.A.clone(e)),(0,o.A)(t)&&this._referenceFrame!==t&&(n=!0,this._referenceFrame=t),n&&this._definitionChanged.raiseEvent(this)},h.prototype.getValueInReferenceFrame=function(e,t,n){if(!(0,o.A)(e))throw new r.A("time is required.");if(!(0,o.A)(t))throw new r.A("referenceFrame is required.");return l.A.convertToReferenceFrame(e,this._value,this._referenceFrame,t,n)},h.prototype.equals=function(e){return this===e||e instanceof h&&i.A.equals(this._value,e._value)&&this._referenceFrame===e._referenceFrame};const d=h},969077:(e,t,n)=>{"use strict";n.d(t,{A:()=>a});var i=n(491446),o=n(955943);function r(e){this._value=void 0,this._hasClone=!1,this._hasEquals=!1,this._definitionChanged=new o.A,this.setValue(e)}Object.defineProperties(r.prototype,{isConstant:{value:!0},definitionChanged:{get:function(){return this._definitionChanged}}}),r.prototype.getValue=function(e,t){return this._hasClone?this._value.clone(t):this._value},r.prototype.setValue=function(e){const t=this._value;if(t!==e){const n=(0,i.A)(e),o=n&&"function"==typeof e.clone,r=n&&"function"==typeof e.equals;(!r||!e.equals(t))&&(this._hasClone=o,this._hasEquals=r,this._value=o?e.clone(this._value):e,this._definitionChanged.raiseEvent(this))}},r.prototype.equals=function(e){return this===e||e instanceof r&&(!this._hasEquals&&this._value===e._value||this._hasEquals&&this._value.equals(e._value))},r.prototype.valueOf=function(){return this._value},r.prototype.toString=function(){return String(this._value)};const a=r},779675:(e,t,n)=>{"use strict";n.d(t,{A:()=>h});var i=n(915325),o=n(491446),r=n(605971),a=n(955943),s=n(802733),c=n(819488);function l(e){this._definitionChanged=new a.A,this._show=void 0,this._showSubscription=void 0,this._positions=void 0,this._positionsSubscription=void 0,this._width=void 0,this._widthSubscription=void 0,this._height=void 0,this._heightSubscription=void 0,this._heightReference=void 0,this._heightReferenceSubscription=void 0,this._extrudedHeight=void 0,this._extrudedHeightSubscription=void 0,this._extrudedHeightReference=void 0,this._extrudedHeightReferenceSubscription=void 0,this._cornerType=void 0,this._cornerTypeSubscription=void 0,this._granularity=void 0,this._granularitySubscription=void 0,this._fill=void 0,this._fillSubscription=void 0,this._material=void 0,this._materialSubscription=void 0,this._outline=void 0,this._outlineSubscription=void 0,this._outlineColor=void 0,this._outlineColorSubscription=void 0,this._outlineWidth=void 0,this._outlineWidthSubscription=void 0,this._shadows=void 0,this._shadowsSubscription=void 0,this._distanceDisplayCondition=void 0,this._distanceDisplayConditionSubscription=void 0,this._classificationType=void 0,this._classificationTypeSubscription=void 0,this._zIndex=void 0,this._zIndexSubscription=void 0,this.merge(e??i.A.EMPTY_OBJECT)}Object.defineProperties(l.prototype,{definitionChanged:{get:function(){return this._definitionChanged}},show:(0,c.A)("show"),positions:(0,c.A)("positions"),width:(0,c.A)("width"),height:(0,c.A)("height"),heightReference:(0,c.A)("heightReference"),extrudedHeight:(0,c.A)("extrudedHeight"),extrudedHeightReference:(0,c.A)("extrudedHeightReference"),cornerType:(0,c.A)("cornerType"),granularity:(0,c.A)("granularity"),fill:(0,c.A)("fill"),material:(0,s.A)("material"),outline:(0,c.A)("outline"),outlineColor:(0,c.A)("outlineColor"),outlineWidth:(0,c.A)("outlineWidth"),shadows:(0,c.A)("shadows"),distanceDisplayCondition:(0,c.A)("distanceDisplayCondition"),classificationType:(0,c.A)("classificationType"),zIndex:(0,c.A)("zIndex")}),l.prototype.clone=function(e){return(0,o.A)(e)?(e.show=this.show,e.positions=this.positions,e.width=this.width,e.height=this.height,e.heightReference=this.heightReference,e.extrudedHeight=this.extrudedHeight,e.extrudedHeightReference=this.extrudedHeightReference,e.cornerType=this.cornerType,e.granularity=this.granularity,e.fill=this.fill,e.material=this.material,e.outline=this.outline,e.outlineColor=this.outlineColor,e.outlineWidth=this.outlineWidth,e.shadows=this.shadows,e.distanceDisplayCondition=this.distanceDisplayCondition,e.classificationType=this.classificationType,e.zIndex=this.zIndex,e):new l(this)},l.prototype.merge=function(e){if(!(0,o.A)(e))throw new r.A("source is required.");this.show=this.show??e.show,this.positions=this.positions??e.positions,this.width=this.width??e.width,this.height=this.height??e.height,this.heightReference=this.heightReference??e.heightReference,this.extrudedHeight=this.extrudedHeight??e.extrudedHeight,this.extrudedHeightReference=this.extrudedHeightReference??e.extrudedHeightReference,this.cornerType=this.cornerType??e.cornerType,this.granularity=this.granularity??e.granularity,this.fill=this.fill??e.fill,this.material=this.material??e.material,this.outline=this.outline??e.outline,this.outlineColor=this.outlineColor??e.outlineColor,this.outlineWidth=this.outlineWidth??e.outlineWidth,this.shadows=this.shadows??e.shadows,this.distanceDisplayCondition=this.distanceDisplayCondition??e.distanceDisplayCondition,this.classificationType=this.classificationType??e.classificationType,this.zIndex=this.zIndex??e.zIndex};const h=l},755394:(e,t,n)=>{"use strict";n.d(t,{A:()=>h});var i=n(491446),o=n(605971),r=n(955943),a=n(367725),s=n(899629),c=n(151075);function l(e){this._name=e,this._clock=void 0,this._changed=new r.A,this._error=new r.A,this._isLoading=!1,this._loading=new r.A,this._entityCollection=new c.A(this),this._entityCluster=new s.A}Object.defineProperties(l.prototype,{name:{get:function(){return this._name},set:function(e){this._name!==e&&(this._name=e,this._changed.raiseEvent(this))}},clock:{get:function(){return this._clock},set:function(e){this._clock!==e&&(this._clock=e,this._changed.raiseEvent(this))}},entities:{get:function(){return this._entityCollection}},isLoading:{get:function(){return this._isLoading},set:function(e){a.A.setLoading(this,e)}},changedEvent:{get:function(){return this._changed}},errorEvent:{get:function(){return this._error}},loadingEvent:{get:function(){return this._loading}},show:{get:function(){return this._entityCollection.show},set:function(e){this._entityCollection.show=e}},clustering:{get:function(){return this._entityCluster},set:function(e){if(!(0,i.A)(e))throw new o.A("value must be defined.");this._entityCluster=e}}}),l.prototype.update=function(e){return!0};const h=l},881679:(e,t,n)=>{"use strict";n.d(t,{A:()=>h});var i=n(915325),o=n(491446),r=n(605971),a=n(955943),s=n(802733),c=n(819488);function l(e){this._definitionChanged=new a.A,this._show=void 0,this._showSubscription=void 0,this._length=void 0,this._lengthSubscription=void 0,this._topRadius=void 0,this._topRadiusSubscription=void 0,this._bottomRadius=void 0,this._bottomRadiusSubscription=void 0,this._heightReference=void 0,this._heightReferenceSubscription=void 0,this._fill=void 0,this._fillSubscription=void 0,this._material=void 0,this._materialSubscription=void 0,this._outline=void 0,this._outlineSubscription=void 0,this._outlineColor=void 0,this._outlineColorSubscription=void 0,this._outlineWidth=void 0,this._outlineWidthSubscription=void 0,this._numberOfVerticalLines=void 0,this._numberOfVerticalLinesSubscription=void 0,this._slices=void 0,this._slicesSubscription=void 0,this._shadows=void 0,this._shadowsSubscription=void 0,this._distanceDisplayCondition=void 0,this._distanceDisplayConditionSubscription=void 0,this.merge(e??i.A.EMPTY_OBJECT)}Object.defineProperties(l.prototype,{definitionChanged:{get:function(){return this._definitionChanged}},show:(0,c.A)("show"),length:(0,c.A)("length"),topRadius:(0,c.A)("topRadius"),bottomRadius:(0,c.A)("bottomRadius"),heightReference:(0,c.A)("heightReference"),fill:(0,c.A)("fill"),material:(0,s.A)("material"),outline:(0,c.A)("outline"),outlineColor:(0,c.A)("outlineColor"),outlineWidth:(0,c.A)("outlineWidth"),numberOfVerticalLines:(0,c.A)("numberOfVerticalLines"),slices:(0,c.A)("slices"),shadows:(0,c.A)("shadows"),distanceDisplayCondition:(0,c.A)("distanceDisplayCondition")}),l.prototype.clone=function(e){return(0,o.A)(e)?(e.show=this.show,e.length=this.length,e.topRadius=this.topRadius,e.bottomRadius=this.bottomRadius,e.heightReference=this.heightReference,e.fill=this.fill,e.material=this.material,e.outline=this.outline,e.outlineColor=this.outlineColor,e.outlineWidth=this.outlineWidth,e.numberOfVerticalLines=this.numberOfVerticalLines,e.slices=this.slices,e.shadows=this.shadows,e.distanceDisplayCondition=this.distanceDisplayCondition,e):new l(this)},l.prototype.merge=function(e){if(!(0,o.A)(e))throw new r.A("source is required.");this.show=this.show??e.show,this.length=this.length??e.length,this.topRadius=this.topRadius??e.topRadius,this.bottomRadius=this.bottomRadius??e.bottomRadius,this.heightReference=this.heightReference??e.heightReference,this.fill=this.fill??e.fill,this.material=this.material??e.material,this.outline=this.outline??e.outline,this.outlineColor=this.outlineColor??e.outlineColor,this.outlineWidth=this.outlineWidth??e.outlineWidth,this.numberOfVerticalLines=this.numberOfVerticalLines??e.numberOfVerticalLines,this.slices=this.slices??e.slices,this.shadows=this.shadows??e.shadows,this.distanceDisplayCondition=this.distanceDisplayCondition??e.distanceDisplayCondition};const h=l},367725:(e,t,n)=>{"use strict";n.d(t,{A:()=>r});var i=n(605971);function o(){i.A.throwInstantiationError()}Object.defineProperties(o.prototype,{name:{get:i.A.throwInstantiationError},clock:{get:i.A.throwInstantiationError},entities:{get:i.A.throwInstantiationError},isLoading:{get:i.A.throwInstantiationError},changedEvent:{get:i.A.throwInstantiationError},errorEvent:{get:i.A.throwInstantiationError},loadingEvent:{get:i.A.throwInstantiationError},show:{get:i.A.throwInstantiationError},clustering:{get:i.A.throwInstantiationError}}),o.prototype.update=function(e){i.A.throwInstantiationError()},o.setLoading=function(e,t){e._isLoading!==t&&(t?e._entityCollection.suspendEvents():e._entityCollection.resumeEvents(),e._isLoading=t,e._loading.raiseEvent(e,t))};const r=o},132753:(e,t,n)=>{"use strict";n.d(t,{A:()=>h});var i=n(915325),o=n(491446),r=n(605971),a=n(955943),s=n(802733),c=n(819488);function l(e){this._definitionChanged=new a.A,this._show=void 0,this._showSubscription=void 0,this._semiMajorAxis=void 0,this._semiMajorAxisSubscription=void 0,this._semiMinorAxis=void 0,this._semiMinorAxisSubscription=void 0,this._height=void 0,this._heightSubscription=void 0,this._heightReference=void 0,this._heightReferenceSubscription=void 0,this._extrudedHeight=void 0,this._extrudedHeightSubscription=void 0,this._extrudedHeightReference=void 0,this._extrudedHeightReferenceSubscription=void 0,this._rotation=void 0,this._rotationSubscription=void 0,this._stRotation=void 0,this._stRotationSubscription=void 0,this._granularity=void 0,this._granularitySubscription=void 0,this._fill=void 0,this._fillSubscription=void 0,this._material=void 0,this._materialSubscription=void 0,this._outline=void 0,this._outlineSubscription=void 0,this._outlineColor=void 0,this._outlineColorSubscription=void 0,this._outlineWidth=void 0,this._outlineWidthSubscription=void 0,this._numberOfVerticalLines=void 0,this._numberOfVerticalLinesSubscription=void 0,this._shadows=void 0,this._shadowsSubscription=void 0,this._distanceDisplayCondition=void 0,this._distanceDisplayConditionSubscription=void 0,this._classificationType=void 0,this._classificationTypeSubscription=void 0,this._zIndex=void 0,this._zIndexSubscription=void 0,this.merge(e??i.A.EMPTY_OBJECT)}Object.defineProperties(l.prototype,{definitionChanged:{get:function(){return this._definitionChanged}},show:(0,c.A)("show"),semiMajorAxis:(0,c.A)("semiMajorAxis"),semiMinorAxis:(0,c.A)("semiMinorAxis"),height:(0,c.A)("height"),heightReference:(0,c.A)("heightReference"),extrudedHeight:(0,c.A)("extrudedHeight"),extrudedHeightReference:(0,c.A)("extrudedHeightReference"),rotation:(0,c.A)("rotation"),stRotation:(0,c.A)("stRotation"),granularity:(0,c.A)("granularity"),fill:(0,c.A)("fill"),material:(0,s.A)("material"),outline:(0,c.A)("outline"),outlineColor:(0,c.A)("outlineColor"),outlineWidth:(0,c.A)("outlineWidth"),numberOfVerticalLines:(0,c.A)("numberOfVerticalLines"),shadows:(0,c.A)("shadows"),distanceDisplayCondition:(0,c.A)("distanceDisplayCondition"),classificationType:(0,c.A)("classificationType"),zIndex:(0,c.A)("zIndex")}),l.prototype.clone=function(e){return(0,o.A)(e)?(e.show=this.show,e.semiMajorAxis=this.semiMajorAxis,e.semiMinorAxis=this.semiMinorAxis,e.height=this.height,e.heightReference=this.heightReference,e.extrudedHeight=this.extrudedHeight,e.extrudedHeightReference=this.extrudedHeightReference,e.rotation=this.rotation,e.stRotation=this.stRotation,e.granularity=this.granularity,e.fill=this.fill,e.material=this.material,e.outline=this.outline,e.outlineColor=this.outlineColor,e.outlineWidth=this.outlineWidth,e.numberOfVerticalLines=this.numberOfVerticalLines,e.shadows=this.shadows,e.distanceDisplayCondition=this.distanceDisplayCondition,e.classificationType=this.classificationType,e.zIndex=this.zIndex,e):new l(this)},l.prototype.merge=function(e){if(!(0,o.A)(e))throw new r.A("source is required.");this.show=this.show??e.show,this.semiMajorAxis=this.semiMajorAxis??e.semiMajorAxis,this.semiMinorAxis=this.semiMinorAxis??e.semiMinorAxis,this.height=this.height??e.height,this.heightReference=this.heightReference??e.heightReference,this.extrudedHeight=this.extrudedHeight??e.extrudedHeight,this.extrudedHeightReference=this.extrudedHeightReference??e.extrudedHeightReference,this.rotation=this.rotation??e.rotation,this.stRotation=this.stRotation??e.stRotation,this.granularity=this.granularity??e.granularity,this.fill=this.fill??e.fill,this.material=this.material??e.material,this.outline=this.outline??e.outline,this.outlineColor=this.outlineColor??e.outlineColor,this.outlineWidth=this.outlineWidth??e.outlineWidth,this.numberOfVerticalLines=this.numberOfVerticalLines??e.numberOfVerticalLines,this.shadows=this.shadows??e.shadows,this.distanceDisplayCondition=this.distanceDisplayCondition??e.distanceDisplayCondition,this.classificationType=this.classificationType??e.classificationType,this.zIndex=this.zIndex??e.zIndex};const h=l},654986:(e,t,n)=>{"use strict";n.d(t,{A:()=>h});var i=n(915325),o=n(491446),r=n(605971),a=n(955943),s=n(802733),c=n(819488);function l(e){this._definitionChanged=new a.A,this._show=void 0,this._showSubscription=void 0,this._radii=void 0,this._radiiSubscription=void 0,this._innerRadii=void 0,this._innerRadiiSubscription=void 0,this._minimumClock=void 0,this._minimumClockSubscription=void 0,this._maximumClock=void 0,this._maximumClockSubscription=void 0,this._minimumCone=void 0,this._minimumConeSubscription=void 0,this._maximumCone=void 0,this._maximumConeSubscription=void 0,this._heightReference=void 0,this._heightReferenceSubscription=void 0,this._fill=void 0,this._fillSubscription=void 0,this._material=void 0,this._materialSubscription=void 0,this._outline=void 0,this._outlineSubscription=void 0,this._outlineColor=void 0,this._outlineColorSubscription=void 0,this._outlineWidth=void 0,this._outlineWidthSubscription=void 0,this._stackPartitions=void 0,this._stackPartitionsSubscription=void 0,this._slicePartitions=void 0,this._slicePartitionsSubscription=void 0,this._subdivisions=void 0,this._subdivisionsSubscription=void 0,this._shadows=void 0,this._shadowsSubscription=void 0,this._distanceDisplayCondition=void 0,this._distanceDisplayConditionSubscription=void 0,this.merge(e??i.A.EMPTY_OBJECT)}Object.defineProperties(l.prototype,{definitionChanged:{get:function(){return this._definitionChanged}},show:(0,c.A)("show"),radii:(0,c.A)("radii"),innerRadii:(0,c.A)("innerRadii"),minimumClock:(0,c.A)("minimumClock"),maximumClock:(0,c.A)("maximumClock"),minimumCone:(0,c.A)("minimumCone"),maximumCone:(0,c.A)("maximumCone"),heightReference:(0,c.A)("heightReference"),fill:(0,c.A)("fill"),material:(0,s.A)("material"),outline:(0,c.A)("outline"),outlineColor:(0,c.A)("outlineColor"),outlineWidth:(0,c.A)("outlineWidth"),stackPartitions:(0,c.A)("stackPartitions"),slicePartitions:(0,c.A)("slicePartitions"),subdivisions:(0,c.A)("subdivisions"),shadows:(0,c.A)("shadows"),distanceDisplayCondition:(0,c.A)("distanceDisplayCondition")}),l.prototype.clone=function(e){return(0,o.A)(e)?(e.show=this.show,e.radii=this.radii,e.innerRadii=this.innerRadii,e.minimumClock=this.minimumClock,e.maximumClock=this.maximumClock,e.minimumCone=this.minimumCone,e.maximumCone=this.maximumCone,e.heightReference=this.heightReference,e.fill=this.fill,e.material=this.material,e.outline=this.outline,e.outlineColor=this.outlineColor,e.outlineWidth=this.outlineWidth,e.stackPartitions=this.stackPartitions,e.slicePartitions=this.slicePartitions,e.subdivisions=this.subdivisions,e.shadows=this.shadows,e.distanceDisplayCondition=this.distanceDisplayCondition,e):new l(this)},l.prototype.merge=function(e){if(!(0,o.A)(e))throw new r.A("source is required.");this.show=this.show??e.show,this.radii=this.radii??e.radii,this.innerRadii=this.innerRadii??e.innerRadii,this.minimumClock=this.minimumClock??e.minimumClock,this.maximumClock=this.maximumClock??e.maximumClock,this.minimumCone=this.minimumCone??e.minimumCone,this.maximumCone=this.maximumCone??e.maximumCone,this.heightReference=this.heightReference??e.heightReference,this.fill=this.fill??e.fill,this.material=this.material??e.material,this.outline=this.outline??e.outline,this.outlineColor=this.outlineColor??e.outlineColor,this.outlineWidth=this.outlineWidth??e.outlineWidth,this.stackPartitions=this.stackPartitions??e.stackPartitions,this.slicePartitions=this.slicePartitions??e.slicePartitions,this.subdivisions=this.subdivisions??e.subdivisions,this.shadows=this.shadows??e.shadows,this.distanceDisplayCondition=this.distanceDisplayCondition??e.distanceDisplayCondition};const h=l},426807:(e,t,n)=>{"use strict";n.d(t,{A:()=>Z});var i=n(267980),o=n(336946),r=n(369031),a=n(673874),s=n(915325),c=n(491446),l=n(605971),h=n(955943),u=n(367817),d=n(331185),p=n(584164),m=n(99479),f=n(73772),A=n(543622),_=n(433052),g=n(623e3),y=n(63316),v=n(470540),b=n(326230),w=n(808938),T=n(779675),x=n(819488),C=n(91440),E=n(881679),S=n(132753),D=n(654986),O=n(280749),z=n(327458),I=n(692632),P=n(423798),R=n(810186),N=n(71005),L=n(193189),M=n(998261),F=n(278659),B=n(46257),k=n(470959),V=n(777370),G=n(685625);const H=new o.A,U=[];function W(e,t){return(0,x.A)(e,void 0,function(e){return e instanceof t?e:new t(e)})}function q(e){let t=(e=e??s.A.EMPTY_OBJECT).id;(0,c.A)(t)||(t=(0,a.A)()),this._availability=void 0,this._id=t,this._definitionChanged=new h.A,this._name=e.name,this._show=e.show??!0,this._trackingReferenceFrame=e.trackingReferenceFrame??f.A.AUTODETECT,this._parent=void 0,this._propertyNames=["billboard","box","corridor","cylinder","description","ellipse","ellipsoid","label","model","tileset","orientation","path","plane","point","polygon","polyline","polylineVolume","position","properties","rectangle","viewFrom","wall",...U],this._billboard=void 0,this._billboardSubscription=void 0,this._box=void 0,this._boxSubscription=void 0,this._corridor=void 0,this._corridorSubscription=void 0,this._cylinder=void 0,this._cylinderSubscription=void 0,this._description=void 0,this._descriptionSubscription=void 0,this._ellipse=void 0,this._ellipseSubscription=void 0,this._ellipsoid=void 0,this._ellipsoidSubscription=void 0,this._label=void 0,this._labelSubscription=void 0,this._model=void 0,this._modelSubscription=void 0,this._tileset=void 0,this._tilesetSubscription=void 0,this._orientation=void 0,this._orientationSubscription=void 0,this._path=void 0,this._pathSubscription=void 0,this._plane=void 0,this._planeSubscription=void 0,this._point=void 0,this._pointSubscription=void 0,this._polygon=void 0,this._polygonSubscription=void 0,this._polyline=void 0,this._polylineSubscription=void 0,this._polylineVolume=void 0,this._polylineVolumeSubscription=void 0,this._position=void 0,this._positionSubscription=void 0,this._properties=void 0,this._propertiesSubscription=void 0,this._rectangle=void 0,this._rectangleSubscription=void 0,this._viewFrom=void 0,this._viewFromSubscription=void 0,this._wall=void 0,this._wallSubscription=void 0,this._children=[],this.entityCollection=void 0,this.parent=e.parent,this.merge(e)}function j(e,t,n){const i=t.length;for(let e=0;e<i;e++){const i=t[e],o=i._show;(!n&&o)!==(n&&o)&&j(i,i._children,n)}e._definitionChanged.raiseEvent(e,"isShowing",n,!n)}Object.defineProperties(q.prototype,{availability:(0,C.A)("availability"),id:{get:function(){return this._id}},definitionChanged:{get:function(){return this._definitionChanged}},name:(0,C.A)("name"),show:{get:function(){return this._show},set:function(e){if(!(0,c.A)(e))throw new l.A("value is required.");if(e===this._show)return;const t=this.isShowing;this._show=e;const n=this.isShowing;t!==n&&j(this,this._children,n),this._definitionChanged.raiseEvent(this,"show",e,!e)}},trackingReferenceFrame:(0,C.A)("trackingReferenceFrame"),isShowing:{get:function(){return this._show&&(!(0,c.A)(this.entityCollection)||this.entityCollection.show)&&(!(0,c.A)(this._parent)||this._parent.isShowing)}},parent:{get:function(){return this._parent},set:function(e){const t=this._parent;if(t===e)return;const n=this.isShowing;if((0,c.A)(t)){const e=t._children.indexOf(this);t._children.splice(e,1)}this._parent=e,(0,c.A)(e)&&e._children.push(this);const i=this.isShowing;n!==i&&j(this,this._children,i),this._definitionChanged.raiseEvent(this,"parent",e,t)}},propertyNames:{get:function(){return this._propertyNames}},billboard:W("billboard",v.A),box:W("box",b.A),corridor:W("corridor",T.A),cylinder:W("cylinder",E.A),description:(0,x.A)("description"),ellipse:W("ellipse",S.A),ellipsoid:W("ellipsoid",D.A),label:W("label",O.A),model:W("model",z.A),tileset:W("tileset",I.A),orientation:(0,x.A)("orientation"),path:W("path",P.A),plane:W("plane",R.A),point:W("point",N.A),polygon:W("polygon",L.A),polyline:W("polyline",M.A),polylineVolume:W("polylineVolume",F.A),properties:W("properties",k.A),position:(0,x.A)("position",void 0,function(e){return new w.A(e)}),rectangle:W("rectangle",V.A),viewFrom:(0,x.A)("viewFrom"),wall:W("wall",G.A)}),q.registerEntityType=function(e,t){Object.defineProperties(q.prototype,{[e]:W(e,t)}),U.includes(e)||U.push(e)},q.prototype.isAvailable=function(e){if(!(0,c.A)(e))throw new l.A("time is required.");const t=this._availability;return!(0,c.A)(t)||t.contains(e)},q.prototype.addProperty=function(e){const t=this._propertyNames;if(!(0,c.A)(e))throw new l.A("propertyName is required.");if(-1!==t.indexOf(e))throw new l.A(`${e} is already a registered property.`);if(e in this)throw new l.A(`${e} is a reserved property name.`);t.push(e),Object.defineProperty(this,e,(0,C.A)(e,!0))},q.prototype.removeProperty=function(e){const t=this._propertyNames.indexOf(e);if(!(0,c.A)(e))throw new l.A("propertyName is required.");if(-1===t)throw new l.A(`${e} is not a registered property.`);this._propertyNames.splice(t,1),delete this[e]},q.prototype.merge=function(e){if(!(0,c.A)(e))throw new l.A("source is required.");this.name=this.name??e.name,this.availability=this.availability??e.availability;const t=this._propertyNames,n=(0,c.A)(e._propertyNames)?e._propertyNames:Object.keys(e),i=n.length;for(let o=0;o<i;o++){const i=n[o];if("parent"===i||"name"===i||"availability"===i||"children"===i)continue;const r=this[i],a=e[i];(0,c.A)(r)||-1!==t.indexOf(i)||this.addProperty(i),(0,c.A)(a)&&((0,c.A)(r)?(0,c.A)(r.merge)&&r.merge(a):(0,c.A)(a.merge)&&(0,c.A)(a.clone)?this[i]=a.clone():this[i]=a)}};const Y=new d.A,X=new i.A,$=new m.A;q.prototype.computeModelMatrix=function(e,t){r.A.typeOf.object("time",e);const n=B.A.getValueOrUndefined(this._position,e,X);if(!(0,c.A)(n))return;const i=B.A.getValueOrUndefined(this._orientation,e,$);return(0,c.A)(i)?p.A.fromRotationTranslation(d.A.fromQuaternion(i,Y),n,t):A.A.eastNorthUpToFixedFrame(n,void 0,t)},q.prototype.computeModelMatrixForHeightReference=function(e,t,n,o,a){r.A.typeOf.object("time",e);const s=B.A.getValueOrDefault(t,e,y.Ay.NONE);let l=B.A.getValueOrUndefined(this._position,e,X);if(s===y.Ay.NONE||!(0,c.A)(l)||i.A.equalsEpsilon(l,i.A.ZERO,u.A.EPSILON8))return this.computeModelMatrix(e,a);const h=o.cartesianToCartographic(l,H);(0,y.w_)(s)?h.height=n:h.height+=n,l=o.cartographicToCartesian(h,l);const m=B.A.getValueOrUndefined(this._orientation,e,$);return(0,c.A)(m)?p.A.fromRotationTranslation(d.A.fromQuaternion(m,Y),l,a):A.A.eastNorthUpToFixedFrame(l,void 0,a)},q.supportsMaterialsforEntitiesOnTerrain=function(e){return g.A.supportsMaterials(e)},q.supportsPolylinesOnTerrain=function(e){return _.A.isSupported(e)};const Z=q},899629:(e,t,n)=>{"use strict";n.d(t,{A:()=>k});var i=n(647934),o=n(434067),r=n(267980),a=n(915325),s=n(491446),c=n(199528),l=n(955943),h=n(584164),u=n(124547),d=n(770103),p=n(566798),m=n(465674),f=n(520853),A=n(24013),_=n(62467);const g=[Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array];class y{static from(e){if(!(e instanceof ArrayBuffer))throw new Error("Data must be an instance of ArrayBuffer.");const[t,n]=new Uint8Array(e,0,2);if(219!==t)throw new Error("Data does not appear to be in a KDBush format.");const i=n>>4;if(1!==i)throw new Error(`Got v${i} data when expected v1.`);const o=g[15&n];if(!o)throw new Error("Unrecognized array type.");const[r]=new Uint16Array(e,2,1),[a]=new Uint32Array(e,4,1);return new y(a,r,o,e)}constructor(e,t=64,n=Float64Array,i){if(isNaN(e)||e<0)throw new Error(`Unpexpected numItems value: ${e}.`);this.numItems=+e,this.nodeSize=Math.min(Math.max(+t,2),65535),this.ArrayType=n,this.IndexArrayType=e<65536?Uint16Array:Uint32Array;const o=g.indexOf(this.ArrayType),r=2*e*this.ArrayType.BYTES_PER_ELEMENT,a=e*this.IndexArrayType.BYTES_PER_ELEMENT,s=(8-a%8)%8;if(o<0)throw new Error(`Unexpected typed array class: ${n}.`);i&&i instanceof ArrayBuffer?(this.data=i,this.ids=new this.IndexArrayType(this.data,8,e),this.coords=new this.ArrayType(this.data,8+a+s,2*e),this._pos=2*e,this._finished=!0):(this.data=new ArrayBuffer(8+r+a+s),this.ids=new this.IndexArrayType(this.data,8,e),this.coords=new this.ArrayType(this.data,8+a+s,2*e),this._pos=0,this._finished=!1,new Uint8Array(this.data,0,2).set([219,16+o]),new Uint16Array(this.data,2,1)[0]=t,new Uint32Array(this.data,4,1)[0]=e)}add(e,t){const n=this._pos>>1;return this.ids[n]=n,this.coords[this._pos++]=e,this.coords[this._pos++]=t,n}finish(){const e=this._pos>>1;if(e!==this.numItems)throw new Error(`Added ${e} items when expected ${this.numItems}.`);return v(this.ids,this.coords,this.nodeSize,0,this.numItems-1,0),this._finished=!0,this}range(e,t,n,i){if(!this._finished)throw new Error("Data not yet indexed - call index.finish().");const{ids:o,coords:r,nodeSize:a}=this,s=[0,o.length-1,0],c=[];for(;s.length;){const l=s.pop()||0,h=s.pop()||0,u=s.pop()||0;if(h-u<=a){for(let a=u;a<=h;a++){const s=r[2*a],l=r[2*a+1];s>=e&&s<=n&&l>=t&&l<=i&&c.push(o[a])}continue}const d=u+h>>1,p=r[2*d],m=r[2*d+1];p>=e&&p<=n&&m>=t&&m<=i&&c.push(o[d]),(0===l?e<=p:t<=m)&&(s.push(u),s.push(d-1),s.push(1-l)),(0===l?n>=p:i>=m)&&(s.push(d+1),s.push(h),s.push(1-l))}return c}within(e,t,n){if(!this._finished)throw new Error("Data not yet indexed - call index.finish().");const{ids:i,coords:o,nodeSize:r}=this,a=[0,i.length-1,0],s=[],c=n*n;for(;a.length;){const l=a.pop()||0,h=a.pop()||0,u=a.pop()||0;if(h-u<=r){for(let n=u;n<=h;n++)x(o[2*n],o[2*n+1],e,t)<=c&&s.push(i[n]);continue}const d=u+h>>1,p=o[2*d],m=o[2*d+1];x(p,m,e,t)<=c&&s.push(i[d]),(0===l?e-n<=p:t-n<=m)&&(a.push(u),a.push(d-1),a.push(1-l)),(0===l?e+n>=p:t+n>=m)&&(a.push(d+1),a.push(h),a.push(1-l))}return s}}function v(e,t,n,i,o,r){if(o-i<=n)return;const a=i+o>>1;b(e,t,a,i,o,r),v(e,t,n,i,a-1,1-r),v(e,t,n,a+1,o,1-r)}function b(e,t,n,i,o,r){for(;o>i;){if(o-i>600){const a=o-i+1,s=n-i+1,c=Math.log(a),l=.5*Math.exp(2*c/3),h=.5*Math.sqrt(c*l*(a-l)/a)*(s-a/2<0?-1:1);b(e,t,n,Math.max(i,Math.floor(n-s*l/a+h)),Math.min(o,Math.floor(n+(a-s)*l/a+h)),r)}const a=t[2*n+r];let s=i,c=o;for(w(e,t,i,n),t[2*o+r]>a&&w(e,t,i,o);s<c;){for(w(e,t,s,c),s++,c--;t[2*s+r]<a;)s++;for(;t[2*c+r]>a;)c--}t[2*i+r]===a?w(e,t,i,c):(c++,w(e,t,c,o)),c<=n&&(i=c+1),n<=c&&(o=c-1)}}function w(e,t,n,i){T(e,n,i),T(t,2*n,2*i),T(t,2*n+1,2*i+1)}function T(e,t,n){const i=e[t];e[t]=e[n],e[n]=i}function x(e,t,n,i){const o=e-n,r=t-i;return o*o+r*r}function C(e){e=e??a.A.EMPTY_OBJECT,this._enabled=e.enabled??!1,this._pixelRange=e.pixelRange??80,this._minimumClusterSize=e.minimumClusterSize??2,this._clusterBillboards=e.clusterBillboards??!0,this._clusterLabels=e.clusterLabels??!0,this._clusterPoints=e.clusterPoints??!0,this._labelCollection=void 0,this._billboardCollection=void 0,this._pointCollection=void 0,this._clusterBillboardCollection=void 0,this._clusterLabelCollection=void 0,this._clusterPointCollection=void 0,this._collectionIndicesByEntity={},this._unusedLabelIndices=[],this._unusedBillboardIndices=[],this._unusedPointIndices=[],this._previousClusters=[],this._previousHeight=void 0,this._enabledDirty=!1,this._clusterDirty=!1,this._cluster=void 0,this._removeEventListener=void 0,this._clusterEvent=new l.A,this.show=e.show??!0}function E(e,t){e.x-=t,e.y-=t,e.width+=2*t,e.height+=2*t}const S=new i.A;function D(e,t,n,o,r){if((0,s.A)(e._labelCollection)&&o._clusterLabels?r=p.A.getScreenSpaceBoundingBox(e,t,r):(0,s.A)(e._billboardCollection)&&o._clusterBillboards?r=u.A.getScreenSpaceBoundingBox(e,t,r):(0,s.A)(e._pointPrimitiveCollection)&&o._clusterPoints&&(r=f.A.getScreenSpaceBoundingBox(e,t,r)),E(r,n),o._clusterLabels&&!(0,s.A)(e._labelCollection)&&(0,s.A)(e.id)&&I(o,e.id.id)&&(0,s.A)(e.id._label)){const a=o._collectionIndicesByEntity[e.id.id].labelIndex,s=o._labelCollection.get(a),c=p.A.getScreenSpaceBoundingBox(s,t,S);E(c,n),r=i.A.union(r,c,r)}return r}function O(e,t){if(e.clusterShow=!0,!(0,s.A)(e._labelCollection)&&(0,s.A)(e.id)&&I(t,e.id.id)&&(0,s.A)(e.id._label)){const n=t._collectionIndicesByEntity[e.id.id].labelIndex;t._labelCollection.get(n).clusterShow=!0}}function z(e,t,n,i){const o={billboard:i._clusterBillboardCollection.add(),label:i._clusterLabelCollection.add(),point:i._clusterPointCollection.add()};o.billboard.show=!1,o.point.show=!1,o.label.show=!0,o.label.text=t.toLocaleString(),o.label.id=n,o.billboard.position=o.label.position=o.point.position=e,i._clusterEvent.raiseEvent(n,o)}function I(e,t){return(0,s.A)(e)&&(0,s.A)(e._collectionIndicesByEntity[t])&&(0,s.A)(e._collectionIndicesByEntity[t].labelIndex)}function P(e,t,n,i,o){if(!(0,s.A)(e))return;const r=e.length;for(let a=0;a<r;++a){const r=e.get(a);if(r.clusterShow=!1,!r.show||o._scene.mode===_.A.SCENE3D&&!i.isPointVisible(r.position))continue;const c=o._clusterLabels&&(0,s.A)(r._labelCollection),l=o._clusterBillboards&&(0,s.A)(r.id._billboard),h=o._clusterPoints&&(0,s.A)(r.id._point);if(c&&(h||l))continue;const u=r.computeScreenSpacePosition(n);(0,s.A)(u)&&t.push({index:a,collection:e,clustered:!1,coord:u})}}const R=new i.A,N=new i.A,L=new i.A;function M(e,t,n,i){return function(o){let r=this[e];(0,s.A)(this._collectionIndicesByEntity)||(this._collectionIndicesByEntity={});let a,c,l=this._collectionIndicesByEntity[o.id];if((0,s.A)(l)||(l=this._collectionIndicesByEntity[o.id]={billboardIndex:void 0,labelIndex:void 0,pointIndex:void 0}),(0,s.A)(r)&&(0,s.A)(l[i]))return r.get(l[i]);(0,s.A)(r)||(r=this[e]=new t({scene:this._scene}));const h=this[n];h.length>0?(a=h.shift(),c=r.get(a)):(c=r.add(),a=r.length-1),l[i]=a;const u=this;return Promise.resolve().then(function(){u._clusterDirty=!0}),c}}function F(e,t){const n=e._collectionIndicesByEntity[t];(0,s.A)(n.billboardIndex)||(0,s.A)(n.labelIndex)||(0,s.A)(n.pointIndex)||delete e._collectionIndicesByEntity[t]}function B(e){if(!(0,s.A)(e))return;const t=e.length;for(let n=0;n<t;++n)e.get(n).clusterShow=!0}C.prototype._initialize=function(e){this._scene=e;const t=(n=this,function(e){if((0,s.A)(e)&&e<.05||!n.enabled)return;const t=n._scene,a=n._labelCollection,l=n._billboardCollection,p=n._pointCollection;if(!(0,s.A)(a)&&!(0,s.A)(l)&&!(0,s.A)(p)||!n._clusterBillboards&&!n._clusterLabels&&!n._clusterPoints)return;let f=n._clusterLabelCollection,_=n._clusterBillboardCollection,g=n._clusterPointCollection;(0,s.A)(f)?f.removeAll():f=n._clusterLabelCollection=new m.A({scene:t}),(0,s.A)(_)?_.removeAll():_=n._clusterBillboardCollection=new d.A({scene:t}),(0,s.A)(g)?g.removeAll():g=n._clusterPointCollection=new A.A;const v=n._pixelRange,b=n._minimumClusterSize,w=n._previousClusters,T=[],x=n._previousHeight,C=t.camera.positionCartographic.height,E=t.ellipsoid,S=t.camera.positionWC,I=new c.A(E,S),M=[];let F,B,k,V,G,H,U,W,q,j,Y,X;if(n._clusterLabels&&P(a,M,t,I,n),n._clusterBillboards&&P(l,M,t,I,n),n._clusterPoints&&P(p,M,t,I,n),M.length>0){const e=new y(M.length,64,Uint32Array);for(let t=0;t<M.length;++t)e.add(M[t].coord.x,M[t].coord.y);if(e.finish(),C<x)for(k=w.length,F=0;F<k;++F){const i=w[F];if(!I.isPointVisible(i.position))continue;const a=u.A._computeScreenSpacePosition(h.A.IDENTITY,i.position,r.A.ZERO,o.A.ZERO,t);if(!(0,s.A)(a))continue;const c=1-C/x;let l=i.width=i.width*c,d=i.height=i.height*c;l=Math.max(l,i.minimumWidth),d=Math.max(d,i.minimumHeight);const p=a.x-.5*l,m=a.y-.5*d,f=a.x+l,A=a.y+d;for(G=e.range(p,m,f,A),H=G.length,j=0,q=[],B=0;B<H;++B)U=G[B],W=M[U],W.clustered||(++j,Y=W.collection,X=W.index,q.push(Y.get(X).id));if(j>=b)for(z(i.position,j,q,n),T.push(i),B=0;B<H;++B)M[G[B]].clustered=!0}for(k=M.length,F=0;F<k;++F){const t=M[F];if(t.clustered)continue;t.clustered=!0,Y=t.collection,X=t.index;const o=Y.get(X);V=D(o,t.coord,v,n,R);const a=i.A.clone(V,N);G=e.range(V.x,V.y,V.x+V.width,V.y+V.height),H=G.length;const s=r.A.clone(o.position);for(j=1,q=[o.id],B=0;B<H;++B)if(U=G[B],W=M[U],!W.clustered){const e=W.collection.get(W.index),t=D(e,W.coord,v,n,L);r.A.add(e.position,s,s),i.A.union(a,t,a),++j,q.push(e.id)}if(j>=b){const e=r.A.multiplyByScalar(s,1/j,s);for(z(e,j,q,n),T.push({position:e,width:a.width,height:a.height,minimumWidth:V.width,minimumHeight:V.height}),B=0;B<H;++B)M[G[B]].clustered=!0}else O(o,n)}}0===f.length&&(f.destroy(),n._clusterLabelCollection=void 0),0===_.length&&(_.destroy(),n._clusterBillboardCollection=void 0),0===g.length&&(g.destroy(),n._clusterPointCollection=void 0),n._previousClusters=T,n._previousHeight=C});var n;this._cluster=t,this._removeEventListener=e.camera.changed.addEventListener(t)},Object.defineProperties(C.prototype,{enabled:{get:function(){return this._enabled},set:function(e){this._enabledDirty=e!==this._enabled,this._enabled=e}},pixelRange:{get:function(){return this._pixelRange},set:function(e){this._clusterDirty=this._clusterDirty||e!==this._pixelRange,this._pixelRange=e}},minimumClusterSize:{get:function(){return this._minimumClusterSize},set:function(e){this._clusterDirty=this._clusterDirty||e!==this._minimumClusterSize,this._minimumClusterSize=e}},clusterEvent:{get:function(){return this._clusterEvent}},clusterBillboards:{get:function(){return this._clusterBillboards},set:function(e){this._clusterDirty=this._clusterDirty||e!==this._clusterBillboards,this._clusterBillboards=e}},clusterLabels:{get:function(){return this._clusterLabels},set:function(e){this._clusterDirty=this._clusterDirty||e!==this._clusterLabels,this._clusterLabels=e}},clusterPoints:{get:function(){return this._clusterPoints},set:function(e){this._clusterDirty=this._clusterDirty||e!==this._clusterPoints,this._clusterPoints=e}},ready:{get:function(){return!this._enabledDirty&&!this._clusterDirty&&(!(0,s.A)(this._billboardCollection)||this._billboardCollection.ready)&&(!(0,s.A)(this._labelCollection)||this._labelCollection.ready)}}}),C.prototype.getLabel=M("_labelCollection",m.A,"_unusedLabelIndices","labelIndex"),C.prototype.removeLabel=function(e){const t=this._collectionIndicesByEntity&&this._collectionIndicesByEntity[e.id];if(!(0,s.A)(this._labelCollection)||!(0,s.A)(t)||!(0,s.A)(t.labelIndex))return;const n=t.labelIndex;t.labelIndex=void 0,F(this,e.id);const i=this._labelCollection.get(n);i.show=!1,i.text="",i.id=void 0,this._unusedLabelIndices.push(n),this._clusterDirty=!0},C.prototype.getBillboard=M("_billboardCollection",d.A,"_unusedBillboardIndices","billboardIndex"),C.prototype.removeBillboard=function(e){const t=this._collectionIndicesByEntity&&this._collectionIndicesByEntity[e.id];if(!(0,s.A)(this._billboardCollection)||!(0,s.A)(t)||!(0,s.A)(t.billboardIndex))return;const n=t.billboardIndex;t.billboardIndex=void 0,F(this,e.id);const i=this._billboardCollection.get(n);i.id=void 0,i.show=!1,i.image=void 0,this._unusedBillboardIndices.push(n),this._clusterDirty=!0},C.prototype.getPoint=M("_pointCollection",A.A,"_unusedPointIndices","pointIndex"),C.prototype.removePoint=function(e){const t=this._collectionIndicesByEntity&&this._collectionIndicesByEntity[e.id];if(!(0,s.A)(this._pointCollection)||!(0,s.A)(t)||!(0,s.A)(t.pointIndex))return;const n=t.pointIndex;t.pointIndex=void 0,F(this,e.id);const i=this._pointCollection.get(n);i.show=!1,i.id=void 0,this._unusedPointIndices.push(n),this._clusterDirty=!0},C.prototype.update=function(e){if(!this.show)return;let t;const n=this._labelCollection;(0,s.A)(n)&&n.length>0&&!n.ready&&(t=e.commandList,e.commandList=[],n.update(e),e.commandList=t);const i=this._billboardCollection;var o;(0,s.A)(i)&&i.length>0&&!i.ready&&(t=e.commandList,e.commandList=[],i.update(e),e.commandList=t),this._enabledDirty&&(this._enabledDirty=!1,(o=this).enabled||((0,s.A)(o._clusterLabelCollection)&&o._clusterLabelCollection.destroy(),(0,s.A)(o._clusterBillboardCollection)&&o._clusterBillboardCollection.destroy(),(0,s.A)(o._clusterPointCollection)&&o._clusterPointCollection.destroy(),o._clusterLabelCollection=void 0,o._clusterBillboardCollection=void 0,o._clusterPointCollection=void 0,B(o._labelCollection),B(o._billboardCollection),B(o._pointCollection)),this._clusterDirty=!0),this._clusterDirty&&(this._cluster(),this._clusterDirty=(0,s.A)(n)&&!n.ready||(0,s.A)(i)&&!i.ready),(0,s.A)(this._clusterLabelCollection)&&this._clusterLabelCollection.update(e),(0,s.A)(this._clusterBillboardCollection)&&this._clusterBillboardCollection.update(e),(0,s.A)(this._clusterPointCollection)&&this._clusterPointCollection.update(e),(0,s.A)(n)&&n.update(e),(0,s.A)(i)&&i.update(e),(0,s.A)(this._pointCollection)&&this._pointCollection.update(e)},C.prototype.destroy=function(){(0,s.A)(this._removeEventListener)&&(this._removeEventListener(),this._removeEventListener=void 0),this._labelCollection=this._labelCollection&&this._labelCollection.destroy(),this._billboardCollection=this._billboardCollection&&this._billboardCollection.destroy(),this._pointCollection=this._pointCollection&&this._pointCollection.destroy(),this._clusterLabelCollection=this._clusterLabelCollection&&this._clusterLabelCollection.destroy(),this._clusterBillboardCollection=this._clusterBillboardCollection&&this._clusterBillboardCollection.destroy(),this._clusterPointCollection=this._clusterPointCollection&&this._clusterPointCollection.destroy(),this._labelCollection=void 0,this._billboardCollection=void 0,this._pointCollection=void 0,this._clusterBillboardCollection=void 0,this._clusterLabelCollection=void 0,this._clusterPointCollection=void 0,this._collectionIndicesByEntity=void 0,this._unusedLabelIndices=[],this._unusedBillboardIndices=[],this._unusedPointIndices=[],this._previousClusters=[],this._previousHeight=void 0,this._enabledDirty=!1,this._pixelRangeDirty=!1,this._minimumClusterSizeDirty=!1};const k=C},151075:(e,t,n)=>{"use strict";n.d(t,{A:()=>f});var i=n(288787),o=n(673874),r=n(491446),a=n(605971),s=n(955943),c=n(32655),l=n(591978),h=n(93467),u=n(426807);const d={id:void 0};function p(e){if(e._firing)e._refire=!0;else if(0===e._suspendCount){const t=e._addedEntities,n=e._removedEntities,i=e._changedEntities;if(0!==i.length||0!==t.length||0!==n.length){e._firing=!0;do{e._refire=!1;const o=t.values.slice(0),r=n.values.slice(0),a=i.values.slice(0);t.removeAll(),n.removeAll(),i.removeAll(),e._collectionChanged.raiseEvent(e,o,r,a)}while(e._refire);e._firing=!1}}}function m(e){this._owner=e,this._entities=new i.A,this._addedEntities=new i.A,this._removedEntities=new i.A,this._changedEntities=new i.A,this._suspendCount=0,this._collectionChanged=new s.A,this._id=(0,o.A)(),this._show=!0,this._firing=!1,this._refire=!1}m.prototype.suspendEvents=function(){this._suspendCount++},m.prototype.resumeEvents=function(){if(0===this._suspendCount)throw new a.A("resumeEvents can not be called before suspendEvents.");this._suspendCount--,p(this)},Object.defineProperties(m.prototype,{collectionChanged:{get:function(){return this._collectionChanged}},id:{get:function(){return this._id}},values:{get:function(){return this._entities.values}},show:{get:function(){return this._show},set:function(e){if(!(0,r.A)(e))throw new a.A("value is required.");if(e===this._show)return;let t;this.suspendEvents();const n=[],i=this._entities.values,o=i.length;for(t=0;t<o;t++)n.push(i[t].isShowing);for(this._show=e,t=0;t<o;t++){const e=n[t],o=i[t];e!==o.isShowing&&o.definitionChanged.raiseEvent(o,"isShowing",o.isShowing,e)}this.resumeEvents()}},owner:{get:function(){return this._owner}}}),m.prototype.computeAvailability=function(){let e=c.A.MAXIMUM_VALUE,t=c.A.MINIMUM_VALUE;const n=this._entities.values;for(let i=0,o=n.length;i<o;i++){const o=n[i].availability;if((0,r.A)(o)){const n=o.start,i=o.stop;l.A.lessThan(n,e)&&!n.equals(c.A.MINIMUM_VALUE)&&(e=n),l.A.greaterThan(i,t)&&!i.equals(c.A.MAXIMUM_VALUE)&&(t=i)}}return c.A.MAXIMUM_VALUE.equals(e)&&(e=c.A.MINIMUM_VALUE),c.A.MINIMUM_VALUE.equals(t)&&(t=c.A.MAXIMUM_VALUE),new h.A({start:e,stop:t})},m.prototype.add=function(e){if(!(0,r.A)(e))throw new a.A("entity is required.");e instanceof u.A||(e=new u.A(e));const t=e.id,n=this._entities;if(n.contains(t))throw new a.A(`An entity with id ${t} already exists in this collection.`);return e.entityCollection=this,n.set(t,e),this._removedEntities.remove(t)||this._addedEntities.set(t,e),e.definitionChanged.addEventListener(m.prototype._onEntityDefinitionChanged,this),p(this),e},m.prototype.remove=function(e){return!!(0,r.A)(e)&&this.removeById(e.id)},m.prototype.contains=function(e){if(!(0,r.A)(e))throw new a.A("entity is required");return this._entities.get(e.id)===e},m.prototype.removeById=function(e){if(!(0,r.A)(e))return!1;const t=this._entities.get(e);return!!this._entities.remove(e)&&(this._addedEntities.remove(e)||(this._removedEntities.set(e,t),this._changedEntities.remove(e)),this._entities.remove(e),t.definitionChanged.removeEventListener(m.prototype._onEntityDefinitionChanged,this),p(this),!0)},m.prototype.removeAll=function(){const e=this._entities,t=e.length,n=e.values,i=this._addedEntities,o=this._removedEntities;for(let e=0;e<t;e++){const t=n[e],a=t.id,s=i.get(a);(0,r.A)(s)||(t.definitionChanged.removeEventListener(m.prototype._onEntityDefinitionChanged,this),o.set(a,t))}e.removeAll(),i.removeAll(),this._changedEntities.removeAll(),p(this)},m.prototype.getById=function(e){if(!(0,r.A)(e))throw new a.A("id is required.");return this._entities.get(e)},m.prototype.getOrCreateEntity=function(e){if(!(0,r.A)(e))throw new a.A("id is required.");let t=this._entities.get(e);return(0,r.A)(t)||(d.id=e,t=new u.A(d),this.add(t)),t},m.prototype._onEntityDefinitionChanged=function(e){const t=e.id;this._addedEntities.contains(t)||this._changedEntities.set(t,e),p(this)};const f=m},612967:(e,t,n)=>{"use strict";n.d(t,{A:()=>f});var i=n(434067),o=n(41476),r=n(915325),a=n(491446),s=n(955943),c=n(591978),l=n(819488),h=n(46257);const u=new i.A(1,1),d=o.A.WHITE;function p(e){e=e??r.A.EMPTY_OBJECT,this._definitionChanged=new s.A,this._image=void 0,this._imageSubscription=void 0,this._repeat=void 0,this._repeatSubscription=void 0,this._color=void 0,this._colorSubscription=void 0,this._transparent=void 0,this._transparentSubscription=void 0,this.image=e.image,this.repeat=e.repeat,this.color=e.color,this.transparent=e.transparent}Object.defineProperties(p.prototype,{isConstant:{get:function(){return h.A.isConstant(this._image)&&h.A.isConstant(this._repeat)}},definitionChanged:{get:function(){return this._definitionChanged}},image:(0,l.A)("image"),repeat:(0,l.A)("repeat"),color:(0,l.A)("color"),transparent:(0,l.A)("transparent")}),p.prototype.getType=function(e){return"Image"};const m=new c.A;p.prototype.getValue=function(e,t){return(0,a.A)(e)||(e=c.A.now(m)),(0,a.A)(t)||(t={}),t.image=h.A.getValueOrUndefined(this._image,e),t.repeat=h.A.getValueOrClonedDefault(this._repeat,e,u,t.repeat),t.color=h.A.getValueOrClonedDefault(this._color,e,d,t.color),h.A.getValueOrDefault(this._transparent,e,!1)&&(t.color.alpha=Math.min(.99,t.color.alpha)),t},p.prototype.equals=function(e){return this===e||e instanceof p&&h.A.equals(this._image,e._image)&&h.A.equals(this._repeat,e._repeat)&&h.A.equals(this._color,e._color)&&h.A.equals(this._transparent,e._transparent)};const f=p},280749:(e,t,n)=>{"use strict";n.d(t,{A:()=>l});var i=n(915325),o=n(491446),r=n(605971),a=n(955943),s=n(819488);function c(e){this._definitionChanged=new a.A,this._show=void 0,this._showSubscription=void 0,this._text=void 0,this._textSubscription=void 0,this._font=void 0,this._fontSubscription=void 0,this._style=void 0,this._styleSubscription=void 0,this._scale=void 0,this._scaleSubscription=void 0,this._showBackground=void 0,this._showBackgroundSubscription=void 0,this._backgroundColor=void 0,this._backgroundColorSubscription=void 0,this._backgroundPadding=void 0,this._backgroundPaddingSubscription=void 0,this._pixelOffset=void 0,this._pixelOffsetSubscription=void 0,this._eyeOffset=void 0,this._eyeOffsetSubscription=void 0,this._horizontalOrigin=void 0,this._horizontalOriginSubscription=void 0,this._verticalOrigin=void 0,this._verticalOriginSubscription=void 0,this._heightReference=void 0,this._heightReferenceSubscription=void 0,this._fillColor=void 0,this._fillColorSubscription=void 0,this._outlineColor=void 0,this._outlineColorSubscription=void 0,this._outlineWidth=void 0,this._outlineWidthSubscription=void 0,this._translucencyByDistance=void 0,this._translucencyByDistanceSubscription=void 0,this._pixelOffsetScaleByDistance=void 0,this._pixelOffsetScaleByDistanceSubscription=void 0,this._scaleByDistance=void 0,this._scaleByDistanceSubscription=void 0,this._distanceDisplayCondition=void 0,this._distanceDisplayConditionSubscription=void 0,this._disableDepthTestDistance=void 0,this._disableDepthTestDistanceSubscription=void 0,this.merge(e??i.A.EMPTY_OBJECT)}Object.defineProperties(c.prototype,{definitionChanged:{get:function(){return this._definitionChanged}},show:(0,s.A)("show"),text:(0,s.A)("text"),font:(0,s.A)("font"),style:(0,s.A)("style"),scale:(0,s.A)("scale"),showBackground:(0,s.A)("showBackground"),backgroundColor:(0,s.A)("backgroundColor"),backgroundPadding:(0,s.A)("backgroundPadding"),pixelOffset:(0,s.A)("pixelOffset"),eyeOffset:(0,s.A)("eyeOffset"),horizontalOrigin:(0,s.A)("horizontalOrigin"),verticalOrigin:(0,s.A)("verticalOrigin"),heightReference:(0,s.A)("heightReference"),fillColor:(0,s.A)("fillColor"),outlineColor:(0,s.A)("outlineColor"),outlineWidth:(0,s.A)("outlineWidth"),translucencyByDistance:(0,s.A)("translucencyByDistance"),pixelOffsetScaleByDistance:(0,s.A)("pixelOffsetScaleByDistance"),scaleByDistance:(0,s.A)("scaleByDistance"),distanceDisplayCondition:(0,s.A)("distanceDisplayCondition"),disableDepthTestDistance:(0,s.A)("disableDepthTestDistance")}),c.prototype.clone=function(e){return(0,o.A)(e)?(e.show=this.show,e.text=this.text,e.font=this.font,e.style=this.style,e.scale=this.scale,e.showBackground=this.showBackground,e.backgroundColor=this.backgroundColor,e.backgroundPadding=this.backgroundPadding,e.pixelOffset=this.pixelOffset,e.eyeOffset=this.eyeOffset,e.horizontalOrigin=this.horizontalOrigin,e.verticalOrigin=this.verticalOrigin,e.heightReference=this.heightReference,e.fillColor=this.fillColor,e.outlineColor=this.outlineColor,e.outlineWidth=this.outlineWidth,e.translucencyByDistance=this.translucencyByDistance,e.pixelOffsetScaleByDistance=this.pixelOffsetScaleByDistance,e.scaleByDistance=this.scaleByDistance,e.distanceDisplayCondition=this.distanceDisplayCondition,e.disableDepthTestDistance=this.disableDepthTestDistance,e):new c(this)},c.prototype.merge=function(e){if(!(0,o.A)(e))throw new r.A("source is required.");this.show=this.show??e.show,this.text=this.text??e.text,this.font=this.font??e.font,this.style=this.style??e.style,this.scale=this.scale??e.scale,this.showBackground=this.showBackground??e.showBackground,this.backgroundColor=this.backgroundColor??e.backgroundColor,this.backgroundPadding=this.backgroundPadding??e.backgroundPadding,this.pixelOffset=this.pixelOffset??e.pixelOffset,this.eyeOffset=this.eyeOffset??e.eyeOffset,this.horizontalOrigin=this.horizontalOrigin??e.horizontalOrigin,this.verticalOrigin=this.verticalOrigin??e.verticalOrigin,this.heightReference=this.heightReference??e.heightReference,this.fillColor=this.fillColor??e.fillColor,this.outlineColor=this.outlineColor??e.outlineColor,this.outlineWidth=this.outlineWidth??e.outlineWidth,this.translucencyByDistance=this.translucencyByDistance??e.translucencyByDistance,this.pixelOffsetScaleByDistance=this.pixelOffsetScaleByDistance??e.pixelOffsetScaleByDistance,this.scaleByDistance=this.scaleByDistance??e.scaleByDistance,this.distanceDisplayCondition=this.distanceDisplayCondition??e.distanceDisplayCondition,this.disableDepthTestDistance=this.disableDepthTestDistance??e.disableDepthTestDistance};const l=c},327458:(e,t,n)=>{"use strict";n.d(t,{A:()=>d});var i=n(915325),o=n(491446),r=n(605971),a=n(955943),s=n(819488),c=n(874804),l=n(470959);function h(e){return new c.A(e)}function u(e){this._definitionChanged=new a.A,this._show=void 0,this._showSubscription=void 0,this._uri=void 0,this._uriSubscription=void 0,this._scale=void 0,this._scaleSubscription=void 0,this._hasVerticalExaggeration=void 0,this._hasVerticalExaggerationSubscription=void 0,this._enableVerticalExaggeration=void 0,this._enableVerticalExaggerationSubscription=void 0,this._minimumPixelSize=void 0,this._minimumPixelSizeSubscription=void 0,this._maximumScale=void 0,this._maximumScaleSubscription=void 0,this._incrementallyLoadTextures=void 0,this._incrementallyLoadTexturesSubscription=void 0,this._runAnimations=void 0,this._runAnimationsSubscription=void 0,this._clampAnimations=void 0,this._clampAnimationsSubscription=void 0,this._shadows=void 0,this._shadowsSubscription=void 0,this._heightReference=void 0,this._heightReferenceSubscription=void 0,this._silhouetteColor=void 0,this._silhouetteColorSubscription=void 0,this._silhouetteSize=void 0,this._silhouetteSizeSubscription=void 0,this._color=void 0,this._colorSubscription=void 0,this._colorBlendMode=void 0,this._colorBlendModeSubscription=void 0,this._colorBlendAmount=void 0,this._colorBlendAmountSubscription=void 0,this._imageBasedLightingFactor=void 0,this._imageBasedLightingFactorSubscription=void 0,this._environmentMapOptions=void 0,this._environmentMapOptionsSubscription=void 0,this._lightColor=void 0,this._lightColorSubscription=void 0,this._distanceDisplayCondition=void 0,this._distanceDisplayConditionSubscription=void 0,this._nodeTransformations=void 0,this._nodeTransformationsSubscription=void 0,this._articulations=void 0,this._articulationsSubscription=void 0,this._clippingPlanes=void 0,this._clippingPlanesSubscription=void 0,this._customShader=void 0,this._customShaderSubscription=void 0,this.merge(e??i.A.EMPTY_OBJECT)}Object.defineProperties(u.prototype,{definitionChanged:{get:function(){return this._definitionChanged}},show:(0,s.A)("show"),uri:(0,s.A)("uri"),scale:(0,s.A)("scale"),enableVerticalExaggeration:(0,s.A)("enableVerticalExaggeration"),minimumPixelSize:(0,s.A)("minimumPixelSize"),maximumScale:(0,s.A)("maximumScale"),incrementallyLoadTextures:(0,s.A)("incrementallyLoadTextures"),runAnimations:(0,s.A)("runAnimations"),clampAnimations:(0,s.A)("clampAnimations"),shadows:(0,s.A)("shadows"),heightReference:(0,s.A)("heightReference"),silhouetteColor:(0,s.A)("silhouetteColor"),silhouetteSize:(0,s.A)("silhouetteSize"),color:(0,s.A)("color"),colorBlendMode:(0,s.A)("colorBlendMode"),colorBlendAmount:(0,s.A)("colorBlendAmount"),imageBasedLightingFactor:(0,s.A)("imageBasedLightingFactor"),environmentMapOptions:(0,s.A)("environmentMapOptions",void 0,function(e){return new l.A(e)}),lightColor:(0,s.A)("lightColor"),distanceDisplayCondition:(0,s.A)("distanceDisplayCondition"),nodeTransformations:(0,s.A)("nodeTransformations",void 0,function(e){return new l.A(e,h)}),articulations:(0,s.A)("articulations",void 0,function(e){return new l.A(e)}),clippingPlanes:(0,s.A)("clippingPlanes"),customShader:(0,s.A)("customShader")}),u.prototype.clone=function(e){return(0,o.A)(e)?(e.show=this.show,e.uri=this.uri,e.scale=this.scale,e.enableVerticalExaggeration=this.enableVerticalExaggeration,e.minimumPixelSize=this.minimumPixelSize,e.maximumScale=this.maximumScale,e.incrementallyLoadTextures=this.incrementallyLoadTextures,e.runAnimations=this.runAnimations,e.clampAnimations=this.clampAnimations,e.heightReference=this._heightReference,e.silhouetteColor=this.silhouetteColor,e.silhouetteSize=this.silhouetteSize,e.color=this.color,e.colorBlendMode=this.colorBlendMode,e.colorBlendAmount=this.colorBlendAmount,e.imageBasedLightingFactor=this.imageBasedLightingFactor,e.environmentMapOptions=this.environmentMapOptions,e.lightColor=this.lightColor,e.distanceDisplayCondition=this.distanceDisplayCondition,e.nodeTransformations=this.nodeTransformations,e.articulations=this.articulations,e.clippingPlanes=this.clippingPlanes,e.customShader=this.customShader,e):new u(this)},u.prototype.merge=function(e){if(!(0,o.A)(e))throw new r.A("source is required.");this.show=this.show??e.show,this.uri=this.uri??e.uri,this.scale=this.scale??e.scale,this.enableVerticalExaggeration=this.enableVerticalExaggeration??e.enableVerticalExaggeration,this.minimumPixelSize=this.minimumPixelSize??e.minimumPixelSize,this.maximumScale=this.maximumScale??e.maximumScale,this.incrementallyLoadTextures=this.incrementallyLoadTextures??e.incrementallyLoadTextures,this.runAnimations=this.runAnimations??e.runAnimations,this.clampAnimations=this.clampAnimations??e.clampAnimations,this.shadows=this.shadows??e.shadows,this.heightReference=this.heightReference??e.heightReference,this.silhouetteColor=this.silhouetteColor??e.silhouetteColor,this.silhouetteSize=this.silhouetteSize??e.silhouetteSize,this.color=this.color??e.color,this.colorBlendMode=this.colorBlendMode??e.colorBlendMode,this.colorBlendAmount=this.colorBlendAmount??e.colorBlendAmount,this.imageBasedLightingFactor=this.imageBasedLightingFactor??e.imageBasedLightingFactor,this.environmentMapOptions=this.environmentMapOptions??e.environmentMapOptions,this.lightColor=this.lightColor??e.lightColor,this.distanceDisplayCondition=this.distanceDisplayCondition??e.distanceDisplayCondition,this.clippingPlanes=this.clippingPlanes??e.clippingPlanes,this.customShader=this.customShader??e.customShader;const t=e.nodeTransformations;if((0,o.A)(t)){const e=this.nodeTransformations;(0,o.A)(e)?e.merge(t):this.nodeTransformations=new l.A(t,h)}const n=e.articulations;if((0,o.A)(n)){const e=this.articulations;(0,o.A)(e)?e.merge(n):this.articulations=new l.A(n)}};const d=u},874804:(e,t,n)=>{"use strict";n.d(t,{A:()=>p});var i=n(915325),o=n(491446),r=n(955943),a=n(591978),s=n(884842),c=n(819488),l=n(46257);const h=new s.A;function u(e){e=e??i.A.EMPTY_OBJECT,this._definitionChanged=new r.A,this._translation=void 0,this._translationSubscription=void 0,this._rotation=void 0,this._rotationSubscription=void 0,this._scale=void 0,this._scaleSubscription=void 0,this.translation=e.translation,this.rotation=e.rotation,this.scale=e.scale}Object.defineProperties(u.prototype,{isConstant:{get:function(){return l.A.isConstant(this._translation)&&l.A.isConstant(this._rotation)&&l.A.isConstant(this._scale)}},definitionChanged:{get:function(){return this._definitionChanged}},translation:(0,c.A)("translation"),rotation:(0,c.A)("rotation"),scale:(0,c.A)("scale")});const d=new a.A;u.prototype.getValue=function(e,t){return(0,o.A)(e)||(e=a.A.now(d)),(0,o.A)(t)||(t=new s.A),t.translation=l.A.getValueOrClonedDefault(this._translation,e,h.translation,t.translation),t.rotation=l.A.getValueOrClonedDefault(this._rotation,e,h.rotation,t.rotation),t.scale=l.A.getValueOrClonedDefault(this._scale,e,h.scale,t.scale),t},u.prototype.equals=function(e){return this===e||e instanceof u&&l.A.equals(this._translation,e._translation)&&l.A.equals(this._rotation,e._rotation)&&l.A.equals(this._scale,e._scale)};const p=u},423798:(e,t,n)=>{"use strict";n.d(t,{A:()=>h});var i=n(915325),o=n(491446),r=n(605971),a=n(955943),s=n(802733),c=n(819488);function l(e){this._definitionChanged=new a.A,this._show=void 0,this._showSubscription=void 0,this._leadTime=void 0,this._leadTimeSubscription=void 0,this._trailTime=void 0,this._trailTimeSubscription=void 0,this._width=void 0,this._widthSubscription=void 0,this._resolution=void 0,this._resolutionSubscription=void 0,this._material=void 0,this._materialSubscription=void 0,this._distanceDisplayCondition=void 0,this._distanceDisplayConditionSubscription=void 0,this.merge(e??i.A.EMPTY_OBJECT)}Object.defineProperties(l.prototype,{definitionChanged:{get:function(){return this._definitionChanged}},show:(0,c.A)("show"),leadTime:(0,c.A)("leadTime"),trailTime:(0,c.A)("trailTime"),width:(0,c.A)("width"),resolution:(0,c.A)("resolution"),material:(0,s.A)("material"),distanceDisplayCondition:(0,c.A)("distanceDisplayCondition")}),l.prototype.clone=function(e){return(0,o.A)(e)?(e.show=this.show,e.leadTime=this.leadTime,e.trailTime=this.trailTime,e.width=this.width,e.resolution=this.resolution,e.material=this.material,e.distanceDisplayCondition=this.distanceDisplayCondition,e):new l(this)},l.prototype.merge=function(e){if(!(0,o.A)(e))throw new r.A("source is required.");this.show=this.show??e.show,this.leadTime=this.leadTime??e.leadTime,this.trailTime=this.trailTime??e.trailTime,this.width=this.width??e.width,this.resolution=this.resolution??e.resolution,this.material=this.material??e.material,this.distanceDisplayCondition=this.distanceDisplayCondition??e.distanceDisplayCondition};const h=l},810186:(e,t,n)=>{"use strict";n.d(t,{A:()=>h});var i=n(915325),o=n(491446),r=n(605971),a=n(955943),s=n(802733),c=n(819488);function l(e){this._definitionChanged=new a.A,this._show=void 0,this._showSubscription=void 0,this._plane=void 0,this._planeSubscription=void 0,this._dimensions=void 0,this._dimensionsSubscription=void 0,this._fill=void 0,this._fillSubscription=void 0,this._material=void 0,this._materialSubscription=void 0,this._outline=void 0,this._outlineSubscription=void 0,this._outlineColor=void 0,this._outlineColorSubscription=void 0,this._outlineWidth=void 0,this._outlineWidthSubscription=void 0,this._shadows=void 0,this._shadowsSubscription=void 0,this._distanceDisplayCondition=void 0,this._distanceDisplayConditionSubscription=void 0,this.merge(e??i.A.EMPTY_OBJECT)}Object.defineProperties(l.prototype,{definitionChanged:{get:function(){return this._definitionChanged}},show:(0,c.A)("show"),plane:(0,c.A)("plane"),dimensions:(0,c.A)("dimensions"),fill:(0,c.A)("fill"),material:(0,s.A)("material"),outline:(0,c.A)("outline"),outlineColor:(0,c.A)("outlineColor"),outlineWidth:(0,c.A)("outlineWidth"),shadows:(0,c.A)("shadows"),distanceDisplayCondition:(0,c.A)("distanceDisplayCondition")}),l.prototype.clone=function(e){return(0,o.A)(e)?(e.show=this.show,e.plane=this.plane,e.dimensions=this.dimensions,e.fill=this.fill,e.material=this.material,e.outline=this.outline,e.outlineColor=this.outlineColor,e.outlineWidth=this.outlineWidth,e.shadows=this.shadows,e.distanceDisplayCondition=this.distanceDisplayCondition,e):new l(this)},l.prototype.merge=function(e){if(!(0,o.A)(e))throw new r.A("source is required.");this.show=this.show??e.show,this.plane=this.plane??e.plane,this.dimensions=this.dimensions??e.dimensions,this.fill=this.fill??e.fill,this.material=this.material??e.material,this.outline=this.outline??e.outline,this.outlineColor=this.outlineColor??e.outlineColor,this.outlineWidth=this.outlineWidth??e.outlineWidth,this.shadows=this.shadows??e.shadows,this.distanceDisplayCondition=this.distanceDisplayCondition??e.distanceDisplayCondition};const h=l},71005:(e,t,n)=>{"use strict";n.d(t,{A:()=>l});var i=n(915325),o=n(491446),r=n(605971),a=n(955943),s=n(819488);function c(e){this._definitionChanged=new a.A,this._show=void 0,this._showSubscription=void 0,this._pixelSize=void 0,this._pixelSizeSubscription=void 0,this._heightReference=void 0,this._heightReferenceSubscription=void 0,this._color=void 0,this._colorSubscription=void 0,this._outlineColor=void 0,this._outlineColorSubscription=void 0,this._outlineWidth=void 0,this._outlineWidthSubscription=void 0,this._scaleByDistance=void 0,this._scaleByDistanceSubscription=void 0,this._translucencyByDistance=void 0,this._translucencyByDistanceSubscription=void 0,this._distanceDisplayCondition=void 0,this._distanceDisplayConditionSubscription=void 0,this._disableDepthTestDistance=void 0,this._disableDepthTestDistanceSubscription=void 0,this._splitDirection=void 0,this._splitDirectionSubscription=void 0,this.merge(e??i.A.EMPTY_OBJECT)}Object.defineProperties(c.prototype,{definitionChanged:{get:function(){return this._definitionChanged}},show:(0,s.A)("show"),pixelSize:(0,s.A)("pixelSize"),heightReference:(0,s.A)("heightReference"),color:(0,s.A)("color"),outlineColor:(0,s.A)("outlineColor"),outlineWidth:(0,s.A)("outlineWidth"),scaleByDistance:(0,s.A)("scaleByDistance"),translucencyByDistance:(0,s.A)("translucencyByDistance"),distanceDisplayCondition:(0,s.A)("distanceDisplayCondition"),disableDepthTestDistance:(0,s.A)("disableDepthTestDistance"),splitDirection:(0,s.A)("splitDirection")}),c.prototype.clone=function(e){return(0,o.A)(e)?(e.show=this.show,e.pixelSize=this.pixelSize,e.heightReference=this.heightReference,e.color=this.color,e.outlineColor=this.outlineColor,e.outlineWidth=this.outlineWidth,e.scaleByDistance=this.scaleByDistance,e.translucencyByDistance=this._translucencyByDistance,e.distanceDisplayCondition=this.distanceDisplayCondition,e.disableDepthTestDistance=this.disableDepthTestDistance,e.splitDirection=this.splitDirection,e):new c(this)},c.prototype.merge=function(e){if(!(0,o.A)(e))throw new r.A("source is required.");this.show=this.show??e.show,this.pixelSize=this.pixelSize??e.pixelSize,this.heightReference=this.heightReference??e.heightReference,this.color=this.color??e.color,this.outlineColor=this.outlineColor??e.outlineColor,this.outlineWidth=this.outlineWidth??e.outlineWidth,this.scaleByDistance=this.scaleByDistance??e.scaleByDistance,this.translucencyByDistance=this._translucencyByDistance??e.translucencyByDistance,this.distanceDisplayCondition=this.distanceDisplayCondition??e.distanceDisplayCondition,this.disableDepthTestDistance=this.disableDepthTestDistance??e.disableDepthTestDistance,this.splitDirection=this.splitDirection??e.splitDirection};const l=c},193189:(e,t,n)=>{"use strict";n.d(t,{A:()=>d});var i=n(915325),o=n(491446),r=n(605971),a=n(955943),s=n(105330),c=n(969077),l=n(802733),h=n(819488);function u(e){this._definitionChanged=new a.A,this._show=void 0,this._showSubscription=void 0,this._hierarchy=void 0,this._hierarchySubscription=void 0,this._height=void 0,this._heightSubscription=void 0,this._heightReference=void 0,this._heightReferenceSubscription=void 0,this._extrudedHeight=void 0,this._extrudedHeightSubscription=void 0,this._extrudedHeightReference=void 0,this._extrudedHeightReferenceSubscription=void 0,this._stRotation=void 0,this._stRotationSubscription=void 0,this._granularity=void 0,this._granularitySubscription=void 0,this._fill=void 0,this._fillSubscription=void 0,this._material=void 0,this._materialSubscription=void 0,this._outline=void 0,this._outlineSubscription=void 0,this._outlineColor=void 0,this._outlineColorSubscription=void 0,this._outlineWidth=void 0,this._outlineWidthSubscription=void 0,this._perPositionHeight=void 0,this._perPositionHeightSubscription=void 0,this._closeTop=void 0,this._closeTopSubscription=void 0,this._closeBottom=void 0,this._closeBottomSubscription=void 0,this._arcType=void 0,this._arcTypeSubscription=void 0,this._shadows=void 0,this._shadowsSubscription=void 0,this._distanceDisplayCondition=void 0,this._distanceDisplayConditionSubscription=void 0,this._classificationType=void 0,this._classificationTypeSubscription=void 0,this._zIndex=void 0,this._zIndexSubscription=void 0,this._textureCoordinates=void 0,this._textureCoordinatesSubscription=void 0,this.merge(e??i.A.EMPTY_OBJECT)}Object.defineProperties(u.prototype,{definitionChanged:{get:function(){return this._definitionChanged}},show:(0,h.A)("show"),hierarchy:(0,h.A)("hierarchy",void 0,function(e){return Array.isArray(e)&&(e=new s.A(e)),new c.A(e)}),height:(0,h.A)("height"),heightReference:(0,h.A)("heightReference"),extrudedHeight:(0,h.A)("extrudedHeight"),extrudedHeightReference:(0,h.A)("extrudedHeightReference"),stRotation:(0,h.A)("stRotation"),granularity:(0,h.A)("granularity"),fill:(0,h.A)("fill"),material:(0,l.A)("material"),outline:(0,h.A)("outline"),outlineColor:(0,h.A)("outlineColor"),outlineWidth:(0,h.A)("outlineWidth"),perPositionHeight:(0,h.A)("perPositionHeight"),closeTop:(0,h.A)("closeTop"),closeBottom:(0,h.A)("closeBottom"),arcType:(0,h.A)("arcType"),shadows:(0,h.A)("shadows"),distanceDisplayCondition:(0,h.A)("distanceDisplayCondition"),classificationType:(0,h.A)("classificationType"),zIndex:(0,h.A)("zIndex"),textureCoordinates:(0,h.A)("textureCoordinates")}),u.prototype.clone=function(e){return(0,o.A)(e)?(e.show=this.show,e.hierarchy=this.hierarchy,e.height=this.height,e.heightReference=this.heightReference,e.extrudedHeight=this.extrudedHeight,e.extrudedHeightReference=this.extrudedHeightReference,e.stRotation=this.stRotation,e.granularity=this.granularity,e.fill=this.fill,e.material=this.material,e.outline=this.outline,e.outlineColor=this.outlineColor,e.outlineWidth=this.outlineWidth,e.perPositionHeight=this.perPositionHeight,e.closeTop=this.closeTop,e.closeBottom=this.closeBottom,e.arcType=this.arcType,e.shadows=this.shadows,e.distanceDisplayCondition=this.distanceDisplayCondition,e.classificationType=this.classificationType,e.zIndex=this.zIndex,e.textureCoordinates=this.textureCoordinates,e):new u(this)},u.prototype.merge=function(e){if(!(0,o.A)(e))throw new r.A("source is required.");this.show=this.show??e.show,this.hierarchy=this.hierarchy??e.hierarchy,this.height=this.height??e.height,this.heightReference=this.heightReference??e.heightReference,this.extrudedHeight=this.extrudedHeight??e.extrudedHeight,this.extrudedHeightReference=this.extrudedHeightReference??e.extrudedHeightReference,this.stRotation=this.stRotation??e.stRotation,this.granularity=this.granularity??e.granularity,this.fill=this.fill??e.fill,this.material=this.material??e.material,this.outline=this.outline??e.outline,this.outlineColor=this.outlineColor??e.outlineColor,this.outlineWidth=this.outlineWidth??e.outlineWidth,this.perPositionHeight=this.perPositionHeight??e.perPositionHeight,this.closeTop=this.closeTop??e.closeTop,this.closeBottom=this.closeBottom??e.closeBottom,this.arcType=this.arcType??e.arcType,this.shadows=this.shadows??e.shadows,this.distanceDisplayCondition=this.distanceDisplayCondition??e.distanceDisplayCondition,this.classificationType=this.classificationType??e.classificationType,this.zIndex=this.zIndex??e.zIndex,this.textureCoordinates=this.textureCoordinates??e.textureCoordinates};const d=u},998261:(e,t,n)=>{"use strict";n.d(t,{A:()=>h});var i=n(915325),o=n(491446),r=n(605971),a=n(955943),s=n(802733),c=n(819488);function l(e){this._definitionChanged=new a.A,this._show=void 0,this._showSubscription=void 0,this._positions=void 0,this._positionsSubscription=void 0,this._width=void 0,this._widthSubscription=void 0,this._granularity=void 0,this._granularitySubscription=void 0,this._material=void 0,this._materialSubscription=void 0,this._depthFailMaterial=void 0,this._depthFailMaterialSubscription=void 0,this._arcType=void 0,this._arcTypeSubscription=void 0,this._clampToGround=void 0,this._clampToGroundSubscription=void 0,this._shadows=void 0,this._shadowsSubscription=void 0,this._distanceDisplayCondition=void 0,this._distanceDisplayConditionSubscription=void 0,this._classificationType=void 0,this._classificationTypeSubscription=void 0,this._zIndex=void 0,this._zIndexSubscription=void 0,this.merge(e??i.A.EMPTY_OBJECT)}Object.defineProperties(l.prototype,{definitionChanged:{get:function(){return this._definitionChanged}},show:(0,c.A)("show"),positions:(0,c.A)("positions"),width:(0,c.A)("width"),granularity:(0,c.A)("granularity"),material:(0,s.A)("material"),depthFailMaterial:(0,s.A)("depthFailMaterial"),arcType:(0,c.A)("arcType"),clampToGround:(0,c.A)("clampToGround"),shadows:(0,c.A)("shadows"),distanceDisplayCondition:(0,c.A)("distanceDisplayCondition"),classificationType:(0,c.A)("classificationType"),zIndex:(0,c.A)("zIndex")}),l.prototype.clone=function(e){return(0,o.A)(e)?(e.show=this.show,e.positions=this.positions,e.width=this.width,e.granularity=this.granularity,e.material=this.material,e.depthFailMaterial=this.depthFailMaterial,e.arcType=this.arcType,e.clampToGround=this.clampToGround,e.shadows=this.shadows,e.distanceDisplayCondition=this.distanceDisplayCondition,e.classificationType=this.classificationType,e.zIndex=this.zIndex,e):new l(this)},l.prototype.merge=function(e){if(!(0,o.A)(e))throw new r.A("source is required.");this.show=this.show??e.show,this.positions=this.positions??e.positions,this.width=this.width??e.width,this.granularity=this.granularity??e.granularity,this.material=this.material??e.material,this.depthFailMaterial=this.depthFailMaterial??e.depthFailMaterial,this.arcType=this.arcType??e.arcType,this.clampToGround=this.clampToGround??e.clampToGround,this.shadows=this.shadows??e.shadows,this.distanceDisplayCondition=this.distanceDisplayCondition??e.distanceDisplayCondition,this.classificationType=this.classificationType??e.classificationType,this.zIndex=this.zIndex??e.zIndex};const h=l},278659:(e,t,n)=>{"use strict";n.d(t,{A:()=>h});var i=n(915325),o=n(491446),r=n(605971),a=n(955943),s=n(802733),c=n(819488);function l(e){this._definitionChanged=new a.A,this._show=void 0,this._showSubscription=void 0,this._positions=void 0,this._positionsSubscription=void 0,this._shape=void 0,this._shapeSubscription=void 0,this._cornerType=void 0,this._cornerTypeSubscription=void 0,this._granularity=void 0,this._granularitySubscription=void 0,this._fill=void 0,this._fillSubscription=void 0,this._material=void 0,this._materialSubscription=void 0,this._outline=void 0,this._outlineSubscription=void 0,this._outlineColor=void 0,this._outlineColorSubscription=void 0,this._outlineWidth=void 0,this._outlineWidthSubscription=void 0,this._shadows=void 0,this._shadowsSubscription=void 0,this._distanceDisplayCondition=void 0,this._distanceDisplayConditionSubsription=void 0,this.merge(e??i.A.EMPTY_OBJECT)}Object.defineProperties(l.prototype,{definitionChanged:{get:function(){return this._definitionChanged}},show:(0,c.A)("show"),positions:(0,c.A)("positions"),shape:(0,c.A)("shape"),cornerType:(0,c.A)("cornerType"),granularity:(0,c.A)("granularity"),fill:(0,c.A)("fill"),material:(0,s.A)("material"),outline:(0,c.A)("outline"),outlineColor:(0,c.A)("outlineColor"),outlineWidth:(0,c.A)("outlineWidth"),shadows:(0,c.A)("shadows"),distanceDisplayCondition:(0,c.A)("distanceDisplayCondition")}),l.prototype.clone=function(e){return(0,o.A)(e)?(e.show=this.show,e.positions=this.positions,e.shape=this.shape,e.cornerType=this.cornerType,e.granularity=this.granularity,e.fill=this.fill,e.material=this.material,e.outline=this.outline,e.outlineColor=this.outlineColor,e.outlineWidth=this.outlineWidth,e.shadows=this.shadows,e.distanceDisplayCondition=this.distanceDisplayCondition,e):new l(this)},l.prototype.merge=function(e){if(!(0,o.A)(e))throw new r.A("source is required.");this.show=this.show??e.show,this.positions=this.positions??e.positions,this.shape=this.shape??e.shape,this.cornerType=this.cornerType??e.cornerType,this.granularity=this.granularity??e.granularity,this.fill=this.fill??e.fill,this.material=this.material??e.material,this.outline=this.outline??e.outline,this.outlineColor=this.outlineColor??e.outlineColor,this.outlineWidth=this.outlineWidth??e.outlineWidth,this.shadows=this.shadows??e.shadows,this.distanceDisplayCondition=this.distanceDisplayCondition??e.distanceDisplayCondition};const h=l},759078:(e,t,n)=>{"use strict";n.d(t,{A:()=>u});var i=n(267980),o=n(491446),r=n(605971),a=n(331185),s=n(886033),c=n(543622);function l(){r.A.throwInstantiationError()}Object.defineProperties(l.prototype,{isConstant:{get:r.A.throwInstantiationError},definitionChanged:{get:r.A.throwInstantiationError},referenceFrame:{get:r.A.throwInstantiationError}}),l.prototype.getValue=r.A.throwInstantiationError,l.prototype.getValueInReferenceFrame=r.A.throwInstantiationError,l.prototype.equals=r.A.throwInstantiationError;const h=new a.A;l.convertToReferenceFrame=function(e,t,n,r,l){if(!(0,o.A)(t))return t;if((0,o.A)(l)||(l=new i.A),n===r)return i.A.clone(t,l);const u=c.A.computeIcrfToCentralBodyFixedMatrix(e,h);return n===s.A.INERTIAL?a.A.multiplyByVector(u,t,l):n===s.A.FIXED?a.A.multiplyByVector(a.A.transpose(u,h),t,l):void 0};const u=l},46257:(e,t,n)=>{"use strict";n.d(t,{A:()=>a});var i=n(491446),o=n(605971);function r(){o.A.throwInstantiationError()}Object.defineProperties(r.prototype,{isConstant:{get:o.A.throwInstantiationError},definitionChanged:{get:o.A.throwInstantiationError}}),r.prototype.getValue=o.A.throwInstantiationError,r.prototype.equals=o.A.throwInstantiationError,r.equals=function(e,t){return e===t||(0,i.A)(e)&&e.equals(t)},r.arrayEquals=function(e,t){if(e===t)return!0;if(!(0,i.A)(e)||!(0,i.A)(t)||e.length!==t.length)return!1;const n=e.length;for(let i=0;i<n;i++)if(!r.equals(e[i],t[i]))return!1;return!0},r.isConstant=function(e){return!(0,i.A)(e)||e.isConstant},r.getValueOrUndefined=function(e,t,n){return(0,i.A)(e)?e.getValue(t,n):void 0},r.getValueOrDefault=function(e,t,n,o){return(0,i.A)(e)?e.getValue(t,o)??n:n},r.getValueOrClonedDefault=function(e,t,n,o){let r;return(0,i.A)(e)&&(r=e.getValue(t,o)),(0,i.A)(r)||(r=n.clone(r)),r};const a=r},470959:(e,t,n)=>{"use strict";n.d(t,{A:()=>p});var i=n(491446),o=n(605971),r=n(955943),a=n(591978),s=n(969077),c=n(819488),l=n(46257);function h(e,t){this._propertyNames=[],this._definitionChanged=new r.A,(0,i.A)(e)&&this.merge(e,t)}function u(e){return new s.A(e)}Object.defineProperties(h.prototype,{propertyNames:{get:function(){return this._propertyNames}},isConstant:{get:function(){const e=this._propertyNames;for(let t=0,n=e.length;t<n;t++)if(!l.A.isConstant(this[e[t]]))return!1;return!0}},definitionChanged:{get:function(){return this._definitionChanged}}}),h.prototype.hasProperty=function(e){return-1!==this._propertyNames.indexOf(e)},h.prototype.addProperty=function(e,t,n){const r=this._propertyNames;if(!(0,i.A)(e))throw new o.A("propertyName is required.");if(-1!==r.indexOf(e))throw new o.A(`${e} is already a registered property.`);r.push(e),Object.defineProperty(this,e,(0,c.A)(e,!0,n??u)),(0,i.A)(t)&&(this[e]=t),this._definitionChanged.raiseEvent(this)},h.prototype.removeProperty=function(e){const t=this._propertyNames.indexOf(e);if(!(0,i.A)(e))throw new o.A("propertyName is required.");if(-1===t)throw new o.A(`${e} is not a registered property.`);this._propertyNames.splice(t,1),delete this[e],this._definitionChanged.raiseEvent(this)};const d=new a.A;h.prototype.getValue=function(e,t){(0,i.A)(e)||(e=a.A.now(d)),(0,i.A)(t)||(t={});const n=this._propertyNames;for(let i=0,o=n.length;i<o;i++){const o=n[i];t[o]=l.A.getValueOrUndefined(this[o],e,t[o])}return t},h.prototype.merge=function(e,t){if(!(0,i.A)(e))throw new o.A("source is required.");const n=this._propertyNames,r=(0,i.A)(e._propertyNames)?e._propertyNames:Object.keys(e);for(let o=0,a=r.length;o<a;o++){const a=r[o],s=this[a],c=e[a];void 0===s&&-1===n.indexOf(a)&&this.addProperty(a,void 0,t),void 0!==c&&(void 0!==s?(0,i.A)(s)&&(0,i.A)(s.merge)&&s.merge(c):(0,i.A)(c)&&(0,i.A)(c.merge)&&(0,i.A)(c.clone)?this[a]=c.clone():this[a]=c)}},h.prototype.equals=function(e){return this===e||e instanceof h&&function(e,t){const n=e._propertyNames,i=t._propertyNames,o=n.length;if(o!==i.length)return!1;for(let r=0;r<o;++r){const o=n[r];if(-1===i.indexOf(o))return!1;if(!l.A.equals(e[o],t[o]))return!1}return!0}(this,e)};const p=h},777370:(e,t,n)=>{"use strict";n.d(t,{A:()=>h});var i=n(915325),o=n(491446),r=n(605971),a=n(955943),s=n(802733),c=n(819488);function l(e){this._definitionChanged=new a.A,this._show=void 0,this._showSubscription=void 0,this._coordinates=void 0,this._coordinatesSubscription=void 0,this._height=void 0,this._heightSubscription=void 0,this._heightReference=void 0,this._heightReferenceSubscription=void 0,this._extrudedHeight=void 0,this._extrudedHeightSubscription=void 0,this._extrudedHeightReference=void 0,this._extrudedHeightReferenceSubscription=void 0,this._rotation=void 0,this._rotationSubscription=void 0,this._stRotation=void 0,this._stRotationSubscription=void 0,this._granularity=void 0,this._granularitySubscription=void 0,this._fill=void 0,this._fillSubscription=void 0,this._material=void 0,this._materialSubscription=void 0,this._outline=void 0,this._outlineSubscription=void 0,this._outlineColor=void 0,this._outlineColorSubscription=void 0,this._outlineWidth=void 0,this._outlineWidthSubscription=void 0,this._shadows=void 0,this._shadowsSubscription=void 0,this._distanceDisplayCondition=void 0,this._distancedisplayConditionSubscription=void 0,this._classificationType=void 0,this._classificationTypeSubscription=void 0,this._zIndex=void 0,this._zIndexSubscription=void 0,this.merge(e??i.A.EMPTY_OBJECT)}Object.defineProperties(l.prototype,{definitionChanged:{get:function(){return this._definitionChanged}},show:(0,c.A)("show"),coordinates:(0,c.A)("coordinates"),height:(0,c.A)("height"),heightReference:(0,c.A)("heightReference"),extrudedHeight:(0,c.A)("extrudedHeight"),extrudedHeightReference:(0,c.A)("extrudedHeightReference"),rotation:(0,c.A)("rotation"),stRotation:(0,c.A)("stRotation"),granularity:(0,c.A)("granularity"),fill:(0,c.A)("fill"),material:(0,s.A)("material"),outline:(0,c.A)("outline"),outlineColor:(0,c.A)("outlineColor"),outlineWidth:(0,c.A)("outlineWidth"),shadows:(0,c.A)("shadows"),distanceDisplayCondition:(0,c.A)("distanceDisplayCondition"),classificationType:(0,c.A)("classificationType"),zIndex:(0,c.A)("zIndex")}),l.prototype.clone=function(e){return(0,o.A)(e)?(e.show=this.show,e.coordinates=this.coordinates,e.height=this.height,e.heightReference=this.heightReference,e.extrudedHeight=this.extrudedHeight,e.extrudedHeightReference=this.extrudedHeightReference,e.rotation=this.rotation,e.stRotation=this.stRotation,e.granularity=this.granularity,e.fill=this.fill,e.material=this.material,e.outline=this.outline,e.outlineColor=this.outlineColor,e.outlineWidth=this.outlineWidth,e.shadows=this.shadows,e.distanceDisplayCondition=this.distanceDisplayCondition,e.classificationType=this.classificationType,e.zIndex=this.zIndex,e):new l(this)},l.prototype.merge=function(e){if(!(0,o.A)(e))throw new r.A("source is required.");this.show=this.show??e.show,this.coordinates=this.coordinates??e.coordinates,this.height=this.height??e.height,this.heightReference=this.heightReference??e.heightReference,this.extrudedHeight=this.extrudedHeight??e.extrudedHeight,this.extrudedHeightReference=this.extrudedHeightReference??e.extrudedHeightReference,this.rotation=this.rotation??e.rotation,this.stRotation=this.stRotation??e.stRotation,this.granularity=this.granularity??e.granularity,this.fill=this.fill??e.fill,this.material=this.material??e.material,this.outline=this.outline??e.outline,this.outlineColor=this.outlineColor??e.outlineColor,this.outlineWidth=this.outlineWidth??e.outlineWidth,this.shadows=this.shadows??e.shadows,this.distanceDisplayCondition=this.distanceDisplayCondition??e.distanceDisplayCondition,this.classificationType=this.classificationType??e.classificationType,this.zIndex=this.zIndex??e.zIndex};const h=l},685625:(e,t,n)=>{"use strict";n.d(t,{A:()=>h});var i=n(915325),o=n(491446),r=n(605971),a=n(955943),s=n(802733),c=n(819488);function l(e){this._definitionChanged=new a.A,this._show=void 0,this._showSubscription=void 0,this._positions=void 0,this._positionsSubscription=void 0,this._minimumHeights=void 0,this._minimumHeightsSubscription=void 0,this._maximumHeights=void 0,this._maximumHeightsSubscription=void 0,this._granularity=void 0,this._granularitySubscription=void 0,this._fill=void 0,this._fillSubscription=void 0,this._material=void 0,this._materialSubscription=void 0,this._outline=void 0,this._outlineSubscription=void 0,this._outlineColor=void 0,this._outlineColorSubscription=void 0,this._outlineWidth=void 0,this._outlineWidthSubscription=void 0,this._shadows=void 0,this._shadowsSubscription=void 0,this._distanceDisplayCondition=void 0,this._distanceDisplayConditionSubscription=void 0,this.merge(e??i.A.EMPTY_OBJECT)}Object.defineProperties(l.prototype,{definitionChanged:{get:function(){return this._definitionChanged}},show:(0,c.A)("show"),positions:(0,c.A)("positions"),minimumHeights:(0,c.A)("minimumHeights"),maximumHeights:(0,c.A)("maximumHeights"),granularity:(0,c.A)("granularity"),fill:(0,c.A)("fill"),material:(0,s.A)("material"),outline:(0,c.A)("outline"),outlineColor:(0,c.A)("outlineColor"),outlineWidth:(0,c.A)("outlineWidth"),shadows:(0,c.A)("shadows"),distanceDisplayCondition:(0,c.A)("distanceDisplayCondition")}),l.prototype.clone=function(e){return(0,o.A)(e)?(e.show=this.show,e.positions=this.positions,e.minimumHeights=this.minimumHeights,e.maximumHeights=this.maximumHeights,e.granularity=this.granularity,e.fill=this.fill,e.material=this.material,e.outline=this.outline,e.outlineColor=this.outlineColor,e.outlineWidth=this.outlineWidth,e.shadows=this.shadows,e.distanceDisplayCondition=this.distanceDisplayCondition,e):new l(this)},l.prototype.merge=function(e){if(!(0,o.A)(e))throw new r.A("source is required.");this.show=this.show??e.show,this.positions=this.positions??e.positions,this.minimumHeights=this.minimumHeights??e.minimumHeights,this.maximumHeights=this.maximumHeights??e.maximumHeights,this.granularity=this.granularity??e.granularity,this.fill=this.fill??e.fill,this.material=this.material??e.material,this.outline=this.outline??e.outline,this.outlineColor=this.outlineColor??e.outlineColor,this.outlineWidth=this.outlineWidth??e.outlineWidth,this.shadows=this.shadows??e.shadows,this.distanceDisplayCondition=this.distanceDisplayCondition??e.distanceDisplayCondition};const h=l},802733:(e,t,n)=>{"use strict";n.d(t,{A:()=>h});var i=n(41476),o=n(605971),r=n(744603),a=n(312421),s=n(819488),c=n(612967);function l(e){if(e instanceof i.A)return new a.A(e);if("string"==typeof e||e instanceof r.A||e instanceof HTMLCanvasElement||e instanceof HTMLVideoElement){const t=new c.A;return t.image=e,t}throw new o.A(`Unable to infer material type: ${e}`)}const h=function(e,t){return(0,s.A)(e,t,l)}},819488:(e,t,n)=>{"use strict";n.d(t,{A:()=>a});var i=n(491446),o=n(969077);function r(e){return new o.A(e)}const a=function(e,t,n){return function(e,t,n,o,r){return{configurable:o,get:function(){return this[t]},set:function(o){const a=this[t],s=this[n];(0,i.A)(s)&&(s(),this[n]=void 0),!(void 0!==o)||(0,i.A)(o)&&(0,i.A)(o.getValue)||!(0,i.A)(r)||(o=r(o)),a!==o&&(this[t]=o,this._definitionChanged.raiseEvent(this,e,o,a)),(0,i.A)(o)&&(0,i.A)(o.definitionChanged)&&(this[n]=o.definitionChanged.addEventListener(function(){this._definitionChanged.raiseEvent(this,e,o,o)},this))}}}(e,`_${e.toString()}`,`_${e.toString()}Subscription`,t??!1,n??r)}},91440:(e,t,n)=>{"use strict";n.d(t,{A:()=>r});var i=n(819488);function o(e){return e}const r=function(e,t){return(0,i.A)(e,t,o)}},481:(e,t,n)=>{"use strict";n.d(t,{A:()=>l});var i=n(267980),o=n(584164),r=n(352581);const a=new i.A;function s(e){this._size=e.size,this._datatype=e.datatype,this.getValue=e.getValue}const c={};c[r.A.FLOAT]="float",c[r.A.FLOAT_VEC2]="vec2",c[r.A.FLOAT_VEC3]="vec3",c[r.A.FLOAT_VEC4]="vec4",c[r.A.INT]="int",c[r.A.INT_VEC2]="ivec2",c[r.A.INT_VEC3]="ivec3",c[r.A.INT_VEC4]="ivec4",c[r.A.BOOL]="bool",c[r.A.BOOL_VEC2]="bvec2",c[r.A.BOOL_VEC3]="bvec3",c[r.A.BOOL_VEC4]="bvec4",c[r.A.FLOAT_MAT2]="mat2",c[r.A.FLOAT_MAT3]="mat3",c[r.A.FLOAT_MAT4]="mat4",c[r.A.SAMPLER_2D]="sampler2D",c[r.A.SAMPLER_CUBE]="samplerCube",s.prototype.getDeclaration=function(e){let t=`uniform ${c[this._datatype]} ${e}`;const n=this._size;return t+=1===n?";":`[${n.toString()}];`,t};const l={czm_viewport:new s({size:1,datatype:r.A.FLOAT_VEC4,getValue:function(e){return e.viewportCartesian4}}),czm_viewportOrthographic:new s({size:1,datatype:r.A.FLOAT_MAT4,getValue:function(e){return e.viewportOrthographic}}),czm_viewportTransformation:new s({size:1,datatype:r.A.FLOAT_MAT4,getValue:function(e){return e.viewportTransformation}}),czm_globeDepthTexture:new s({size:1,datatype:r.A.SAMPLER_2D,getValue:function(e){return e.globeDepthTexture}}),czm_model:new s({size:1,datatype:r.A.FLOAT_MAT4,getValue:function(e){return e.model}}),czm_inverseModel:new s({size:1,datatype:r.A.FLOAT_MAT4,getValue:function(e){return e.inverseModel}}),czm_view:new s({size:1,datatype:r.A.FLOAT_MAT4,getValue:function(e){return e.view}}),czm_view3D:new s({size:1,datatype:r.A.FLOAT_MAT4,getValue:function(e){return e.view3D}}),czm_viewRotation:new s({size:1,datatype:r.A.FLOAT_MAT3,getValue:function(e){return e.viewRotation}}),czm_viewRotation3D:new s({size:1,datatype:r.A.FLOAT_MAT3,getValue:function(e){return e.viewRotation3D}}),czm_inverseView:new s({size:1,datatype:r.A.FLOAT_MAT4,getValue:function(e){return e.inverseView}}),czm_inverseView3D:new s({size:1,datatype:r.A.FLOAT_MAT4,getValue:function(e){return e.inverseView3D}}),czm_inverseViewRotation:new s({size:1,datatype:r.A.FLOAT_MAT3,getValue:function(e){return e.inverseViewRotation}}),czm_inverseViewRotation3D:new s({size:1,datatype:r.A.FLOAT_MAT3,getValue:function(e){return e.inverseViewRotation3D}}),czm_projection:new s({size:1,datatype:r.A.FLOAT_MAT4,getValue:function(e){return e.projection}}),czm_inverseProjection:new s({size:1,datatype:r.A.FLOAT_MAT4,getValue:function(e){return e.inverseProjection}}),czm_infiniteProjection:new s({size:1,datatype:r.A.FLOAT_MAT4,getValue:function(e){return e.infiniteProjection}}),czm_modelView:new s({size:1,datatype:r.A.FLOAT_MAT4,getValue:function(e){return e.modelView}}),czm_modelView3D:new s({size:1,datatype:r.A.FLOAT_MAT4,getValue:function(e){return e.modelView3D}}),czm_modelViewRelativeToEye:new s({size:1,datatype:r.A.FLOAT_MAT4,getValue:function(e){return e.modelViewRelativeToEye}}),czm_inverseModelView:new s({size:1,datatype:r.A.FLOAT_MAT4,getValue:function(e){return e.inverseModelView}}),czm_inverseModelView3D:new s({size:1,datatype:r.A.FLOAT_MAT4,getValue:function(e){return e.inverseModelView3D}}),czm_viewProjection:new s({size:1,datatype:r.A.FLOAT_MAT4,getValue:function(e){return e.viewProjection}}),czm_inverseViewProjection:new s({size:1,datatype:r.A.FLOAT_MAT4,getValue:function(e){return e.inverseViewProjection}}),czm_modelViewProjection:new s({size:1,datatype:r.A.FLOAT_MAT4,getValue:function(e){return e.modelViewProjection}}),czm_inverseModelViewProjection:new s({size:1,datatype:r.A.FLOAT_MAT4,getValue:function(e){return e.inverseModelViewProjection}}),czm_modelViewProjectionRelativeToEye:new s({size:1,datatype:r.A.FLOAT_MAT4,getValue:function(e){return e.modelViewProjectionRelativeToEye}}),czm_modelViewInfiniteProjection:new s({size:1,datatype:r.A.FLOAT_MAT4,getValue:function(e){return e.modelViewInfiniteProjection}}),czm_orthographicIn3D:new s({size:1,datatype:r.A.FLOAT,getValue:function(e){return e.orthographicIn3D?1:0}}),czm_normal:new s({size:1,datatype:r.A.FLOAT_MAT3,getValue:function(e){return e.normal}}),czm_normal3D:new s({size:1,datatype:r.A.FLOAT_MAT3,getValue:function(e){return e.normal3D}}),czm_inverseNormal:new s({size:1,datatype:r.A.FLOAT_MAT3,getValue:function(e){return e.inverseNormal}}),czm_inverseNormal3D:new s({size:1,datatype:r.A.FLOAT_MAT3,getValue:function(e){return e.inverseNormal3D}}),czm_eyeHeight:new s({size:1,datatype:r.A.FLOAT,getValue:function(e){return e.eyeHeight}}),czm_eyeHeight2D:new s({size:1,datatype:r.A.FLOAT_VEC2,getValue:function(e){return e.eyeHeight2D}}),czm_eyeEllipsoidNormalEC:new s({size:1,datatype:r.A.FLOAT_VEC3,getValue:function(e){return e.eyeEllipsoidNormalEC}}),czm_eyeEllipsoidCurvature:new s({size:1,datatype:r.A.FLOAT_VEC2,getValue:function(e){return e.eyeEllipsoidCurvature}}),czm_modelToEnu:new s({size:1,datatype:r.A.FLOAT_MAT4,getValue:function(e){return e.modelToEnu}}),czm_enuToModel:new s({size:1,datatype:r.A.FLOAT_MAT4,getValue:function(e){return e.enuToModel}}),czm_entireFrustum:new s({size:1,datatype:r.A.FLOAT_VEC2,getValue:function(e){return e.entireFrustum}}),czm_currentFrustum:new s({size:1,datatype:r.A.FLOAT_VEC2,getValue:function(e){return e.currentFrustum}}),czm_frustumPlanes:new s({size:1,datatype:r.A.FLOAT_VEC4,getValue:function(e){return e.frustumPlanes}}),czm_farDepthFromNearPlusOne:new s({size:1,datatype:r.A.FLOAT,getValue:function(e){return e.farDepthFromNearPlusOne}}),czm_log2FarDepthFromNearPlusOne:new s({size:1,datatype:r.A.FLOAT,getValue:function(e){return e.log2FarDepthFromNearPlusOne}}),czm_oneOverLog2FarDepthFromNearPlusOne:new s({size:1,datatype:r.A.FLOAT,getValue:function(e){return e.oneOverLog2FarDepthFromNearPlusOne}}),czm_sunPositionWC:new s({size:1,datatype:r.A.FLOAT_VEC3,getValue:function(e){return e.sunPositionWC}}),czm_sunPositionColumbusView:new s({size:1,datatype:r.A.FLOAT_VEC3,getValue:function(e){return e.sunPositionColumbusView}}),czm_sunDirectionEC:new s({size:1,datatype:r.A.FLOAT_VEC3,getValue:function(e){return e.sunDirectionEC}}),czm_sunDirectionWC:new s({size:1,datatype:r.A.FLOAT_VEC3,getValue:function(e){return e.sunDirectionWC}}),czm_moonDirectionEC:new s({size:1,datatype:r.A.FLOAT_VEC3,getValue:function(e){return e.moonDirectionEC}}),czm_lightDirectionEC:new s({size:1,datatype:r.A.FLOAT_VEC3,getValue:function(e){return e.lightDirectionEC}}),czm_lightDirectionWC:new s({size:1,datatype:r.A.FLOAT_VEC3,getValue:function(e){return e.lightDirectionWC}}),czm_lightColor:new s({size:1,datatype:r.A.FLOAT_VEC3,getValue:function(e){return e.lightColor}}),czm_lightColorHdr:new s({size:1,datatype:r.A.FLOAT_VEC3,getValue:function(e){return e.lightColorHdr}}),czm_encodedCameraPositionMCHigh:new s({size:1,datatype:r.A.FLOAT_VEC3,getValue:function(e){return e.encodedCameraPositionMCHigh}}),czm_encodedCameraPositionMCLow:new s({size:1,datatype:r.A.FLOAT_VEC3,getValue:function(e){return e.encodedCameraPositionMCLow}}),czm_viewerPositionWC:new s({size:1,datatype:r.A.FLOAT_VEC3,getValue:function(e){return o.A.getTranslation(e.inverseView,a)}}),czm_frameNumber:new s({size:1,datatype:r.A.FLOAT,getValue:function(e){return e.frameState.frameNumber}}),czm_morphTime:new s({size:1,datatype:r.A.FLOAT,getValue:function(e){return e.frameState.morphTime}}),czm_sceneMode:new s({size:1,datatype:r.A.FLOAT,getValue:function(e){return e.frameState.mode}}),czm_pass:new s({size:1,datatype:r.A.FLOAT,getValue:function(e){return e.pass}}),czm_backgroundColor:new s({size:1,datatype:r.A.FLOAT_VEC4,getValue:function(e){return e.backgroundColor}}),czm_brdfLut:new s({size:1,datatype:r.A.SAMPLER_2D,getValue:function(e){return e.brdfLut}}),czm_environmentMap:new s({size:1,datatype:r.A.SAMPLER_CUBE,getValue:function(e){return e.environmentMap}}),czm_specularEnvironmentMaps:new s({size:1,datatype:r.A.SAMPLER_CUBE,getValue:function(e){return e.specularEnvironmentMaps}}),czm_specularEnvironmentMapsMaximumLOD:new s({size:1,datatype:r.A.FLOAT,getValue:function(e){return e.specularEnvironmentMapsMaximumLOD}}),czm_sphericalHarmonicCoefficients:new s({size:9,datatype:r.A.FLOAT_VEC3,getValue:function(e){return e.sphericalHarmonicCoefficients}}),czm_temeToPseudoFixed:new s({size:1,datatype:r.A.FLOAT_MAT3,getValue:function(e){return e.temeToPseudoFixedMatrix}}),czm_pixelRatio:new s({size:1,datatype:r.A.FLOAT,getValue:function(e){return e.pixelRatio}}),czm_fogDensity:new s({size:1,datatype:r.A.FLOAT,getValue:function(e){return e.fogDensity}}),czm_fogVisualDensityScalar:new s({size:1,datatype:r.A.FLOAT,getValue:function(e){return e.fogVisualDensityScalar}}),czm_fogMinimumBrightness:new s({size:1,datatype:r.A.FLOAT,getValue:function(e){return e.fogMinimumBrightness}}),czm_atmosphereHsbShift:new s({size:1,datatype:r.A.FLOAT_VEC3,getValue:function(e){return e.atmosphereHsbShift}}),czm_atmosphereLightIntensity:new s({size:1,datatype:r.A.FLOAT,getValue:function(e){return e.atmosphereLightIntensity}}),czm_atmosphereRayleighCoefficient:new s({size:1,datatype:r.A.FLOAT_VEC3,getValue:function(e){return e.atmosphereRayleighCoefficient}}),czm_atmosphereRayleighScaleHeight:new s({size:1,datatype:r.A.FLOAT,getValue:function(e){return e.atmosphereRayleighScaleHeight}}),czm_atmosphereMieCoefficient:new s({size:1,datatype:r.A.FLOAT_VEC3,getValue:function(e){return e.atmosphereMieCoefficient}}),czm_atmosphereMieScaleHeight:new s({size:1,datatype:r.A.FLOAT,getValue:function(e){return e.atmosphereMieScaleHeight}}),czm_atmosphereMieAnisotropy:new s({size:1,datatype:r.A.FLOAT,getValue:function(e){return e.atmosphereMieAnisotropy}}),czm_atmosphereDynamicLighting:new s({size:1,datatype:r.A.FLOAT,getValue:function(e){return e.atmosphereDynamicLighting}}),czm_splitPosition:new s({size:1,datatype:r.A.FLOAT,getValue:function(e){return e.splitPosition}}),czm_geometricToleranceOverMeter:new s({size:1,datatype:r.A.FLOAT,getValue:function(e){return e.geometricToleranceOverMeter}}),czm_minimumDisableDepthTestDistance:new s({size:1,datatype:r.A.FLOAT,getValue:function(e){return e.minimumDisableDepthTestDistance}}),czm_invertClassificationColor:new s({size:1,datatype:r.A.FLOAT_VEC4,getValue:function(e){return e.invertClassificationColor}}),czm_gamma:new s({size:1,datatype:r.A.FLOAT,getValue:function(e){return e.gamma}}),czm_ellipsoidRadii:new s({size:1,datatype:r.A.FLOAT_VEC3,getValue:function(e){return e.ellipsoid.radii}}),czm_ellipsoidInverseRadii:new s({size:1,datatype:r.A.FLOAT_VEC3,getValue:function(e){return e.ellipsoid.oneOverRadii}})}},641613:(e,t,n)=>{"use strict";n.d(t,{A:()=>p});var i=n(369031),o=n(673874),r=n(915325),a=n(491446),s=n(677354),c=n(605971),l=n(874915),h=n(352581),u=n(442790);function d(e){if(e=e??r.A.EMPTY_OBJECT,i.A.defined("options.context",e.context),!(0,a.A)(e.typedArray)&&!(0,a.A)(e.sizeInBytes))throw new c.A("Either options.sizeInBytes or options.typedArray is required.");if((0,a.A)(e.typedArray)&&(0,a.A)(e.sizeInBytes))throw new c.A("Cannot pass in both options.sizeInBytes and options.typedArray.");if((0,a.A)(e.typedArray)&&(i.A.typeOf.object("options.typedArray",e.typedArray),i.A.typeOf.number("options.typedArray.byteLength",e.typedArray.byteLength)),!u.A.validate(e.usage))throw new c.A("usage is invalid.");const t=e.context._gl,n=e.bufferTarget,s=e.typedArray;let l=e.sizeInBytes;const h=e.usage,d=(0,a.A)(s);d&&(l=s.byteLength),i.A.typeOf.number.greaterThan("sizeInBytes",l,0);const p=t.createBuffer();t.bindBuffer(n,p),t.bufferData(n,d?s:l,h),t.bindBuffer(n,null),this._id=(0,o.A)(),this._gl=t,this._webgl2=e.context._webgl2,this._bufferTarget=n,this._sizeInBytes=l,this._usage=h,this._buffer=p,this.vertexArrayDestroyable=!0}d.createVertexBuffer=function(e){return i.A.defined("options.context",e.context),new d({context:e.context,bufferTarget:h.A.ARRAY_BUFFER,typedArray:e.typedArray,sizeInBytes:e.sizeInBytes,usage:e.usage})},d.createIndexBuffer=function(e){if(i.A.defined("options.context",e.context),!l.A.validate(e.indexDatatype))throw new c.A("Invalid indexDatatype.");if(e.indexDatatype===l.A.UNSIGNED_INT&&!e.context.elementIndexUint)throw new c.A("IndexDatatype.UNSIGNED_INT requires OES_element_index_uint, which is not supported on this system.  Check context.elementIndexUint.");const t=e.context,n=e.indexDatatype,o=l.A.getSizeInBytes(n),r=new d({context:t,bufferTarget:h.A.ELEMENT_ARRAY_BUFFER,typedArray:e.typedArray,sizeInBytes:e.sizeInBytes,usage:e.usage}),a=r.sizeInBytes/o;return Object.defineProperties(r,{indexDatatype:{get:function(){return n}},bytesPerIndex:{get:function(){return o}},numberOfIndices:{get:function(){return a}}}),r},Object.defineProperties(d.prototype,{sizeInBytes:{get:function(){return this._sizeInBytes}},usage:{get:function(){return this._usage}}}),d.prototype._getBuffer=function(){return this._buffer},d.prototype.copyFromArrayView=function(e,t){t=t??0,i.A.defined("arrayView",e),i.A.typeOf.number.lessThanOrEquals("offsetInBytes + arrayView.byteLength",t+e.byteLength,this._sizeInBytes);const n=this._gl,o=this._bufferTarget;n.bindBuffer(o,this._buffer),n.bufferSubData(o,t,e),n.bindBuffer(o,null)},d.prototype.copyFromBuffer=function(e,t,n,i){if(!this._webgl2)throw new c.A("A WebGL 2 context is required.");if(!(0,a.A)(e))throw new c.A("readBuffer must be defined.");if(!(0,a.A)(i)||i<=0)throw new c.A("sizeInBytes must be defined and be greater than zero.");if(!(0,a.A)(t)||t<0||t+i>e._sizeInBytes)throw new c.A("readOffset must be greater than or equal to zero and readOffset + sizeInBytes must be less than of equal to readBuffer.sizeInBytes.");if(!(0,a.A)(n)||n<0||n+i>this._sizeInBytes)throw new c.A("writeOffset must be greater than or equal to zero and writeOffset + sizeInBytes must be less than of equal to this.sizeInBytes.");if(this._buffer===e._buffer&&(n>=t&&n<t+i||t>n&&t<n+i))throw new c.A("When readBuffer is equal to this, the ranges [readOffset + sizeInBytes) and [writeOffset, writeOffset + sizeInBytes) must not overlap.");if(this._bufferTarget===h.A.ELEMENT_ARRAY_BUFFER&&e._bufferTarget!==h.A.ELEMENT_ARRAY_BUFFER||this._bufferTarget!==h.A.ELEMENT_ARRAY_BUFFER&&e._bufferTarget===h.A.ELEMENT_ARRAY_BUFFER)throw new c.A("Can not copy an index buffer into another buffer type.");const o=h.A.COPY_READ_BUFFER,r=h.A.COPY_WRITE_BUFFER,s=this._gl;s.bindBuffer(r,this._buffer),s.bindBuffer(o,e._buffer),s.copyBufferSubData(o,r,t,n,i),s.bindBuffer(r,null),s.bindBuffer(o,null)},d.prototype.getBufferData=function(e,t,n,i){if(t=t??0,n=n??0,!this._webgl2)throw new c.A("A WebGL 2 context is required.");if(!(0,a.A)(e))throw new c.A("arrayView is required.");let o,r,s=e.byteLength;if((0,a.A)(i)?(o=i,(0,a.A)(s)?r=1:(s=e.length,r=e.BYTES_PER_ELEMENT)):(0,a.A)(s)?(o=s-n,r=1):(s=e.length,o=s-n,r=e.BYTES_PER_ELEMENT),n<0||n>s)throw new c.A("destinationOffset must be greater than zero and less than the arrayView length.");if(n+o>s)throw new c.A("destinationOffset + length must be less than or equal to the arrayViewLength.");if(t<0||t>this._sizeInBytes)throw new c.A("sourceOffset must be greater than zero and less than the buffers size.");if(t+o*r>this._sizeInBytes)throw new c.A("sourceOffset + length must be less than the buffers size.");const l=this._gl,u=h.A.COPY_READ_BUFFER;l.bindBuffer(u,this._buffer),l.getBufferSubData(u,t,e,n,i),l.bindBuffer(u,null)},d.prototype.isDestroyed=function(){return!1},d.prototype.destroy=function(){return this._gl.deleteBuffer(this._buffer),(0,s.A)(this)};const p=d},442790:(e,t,n)=>{"use strict";n.d(t,{A:()=>r});var i=n(352581);const o={STREAM_DRAW:i.A.STREAM_DRAW,STATIC_DRAW:i.A.STATIC_DRAW,DYNAMIC_DRAW:i.A.DYNAMIC_DRAW,validate:function(e){return e===o.STREAM_DRAW||e===o.STATIC_DRAW||e===o.DYNAMIC_DRAW}},r=Object.freeze(o)},430332:(e,t,n)=>{"use strict";n.d(t,{A:()=>o});const i={_maximumCombinedTextureImageUnits:0,_maximumCubeMapSize:0,_maximumFragmentUniformVectors:0,_maximumTextureImageUnits:0,_maximumRenderbufferSize:0,_maximumTextureSize:0,_maximumVaryingVectors:0,_maximumVertexAttributes:0,_maximumVertexTextureImageUnits:0,_maximumVertexUniformVectors:0,_minimumAliasedLineWidth:0,_maximumAliasedLineWidth:0,_minimumAliasedPointSize:0,_maximumAliasedPointSize:0,_maximumViewportWidth:0,_maximumViewportHeight:0,_maximumTextureFilterAnisotropy:0,_maximumDrawBuffers:0,_maximumColorAttachments:0,_maximumSamples:0,_highpFloatSupported:!1,_highpIntSupported:!1};Object.defineProperties(i,{maximumCombinedTextureImageUnits:{get:function(){return i._maximumCombinedTextureImageUnits}},maximumCubeMapSize:{get:function(){return i._maximumCubeMapSize}},maximumFragmentUniformVectors:{get:function(){return i._maximumFragmentUniformVectors}},maximumTextureImageUnits:{get:function(){return i._maximumTextureImageUnits}},maximumRenderbufferSize:{get:function(){return i._maximumRenderbufferSize}},maximumTextureSize:{get:function(){return i._maximumTextureSize}},maximumVaryingVectors:{get:function(){return i._maximumVaryingVectors}},maximumVertexAttributes:{get:function(){return i._maximumVertexAttributes}},maximumVertexTextureImageUnits:{get:function(){return i._maximumVertexTextureImageUnits}},maximumVertexUniformVectors:{get:function(){return i._maximumVertexUniformVectors}},minimumAliasedLineWidth:{get:function(){return i._minimumAliasedLineWidth}},maximumAliasedLineWidth:{get:function(){return i._maximumAliasedLineWidth}},minimumAliasedPointSize:{get:function(){return i._minimumAliasedPointSize}},maximumAliasedPointSize:{get:function(){return i._maximumAliasedPointSize}},maximumViewportWidth:{get:function(){return i._maximumViewportWidth}},maximumViewportHeight:{get:function(){return i._maximumViewportHeight}},maximumTextureFilterAnisotropy:{get:function(){return i._maximumTextureFilterAnisotropy}},maximumDrawBuffers:{get:function(){return i._maximumDrawBuffers}},maximumColorAttachments:{get:function(){return i._maximumColorAttachments}},maximumSamples:{get:function(){return i._maximumSamples}},highpFloatSupported:{get:function(){return i._highpFloatSupported}},highpIntSupported:{get:function(){return i._highpIntSupported}}});const o=i},346154:(e,t,n)=>{"use strict";n.d(t,{A:()=>S});var i=n(554630),o=n(267980),r=n(369031),a=n(915325),s=n(491446),c=n(677354),l=n(605971),h=n(34233),u=n(367817),d=n(276904),p=n(769534),m=n(442790),f=n(430332),A=n(671495),_=n(483128),g=n(418906),y=n(57775),v=n(654799),b=n(957233),w=n(78078),T=n(508380);function x(e){e=e??a.A.EMPTY_OBJECT,r.A.defined("options.context",e.context);const{context:t,source:n,pixelFormat:i=d.A.RGBA,pixelDatatype:o=y.A.UNSIGNED_BYTE,flipY:c=!0,skipColorSpaceConversion:h=!1,sampler:u=new v.A}=e,p=e.preMultiplyAlpha||i===d.A.RGB||i===d.A.LUMINANCE;let{width:m,height:_}=e;if((0,s.A)(n)){if(!Object.values(x.FaceName).every(e=>(0,s.A)(n[e])))throw new l.A(`options.source requires faces ${Object.values(x.FaceName).join(", ")}.`);({width:m,height:_}=n.positiveX);for(const e of x.faceNames()){const t=n[e];if(Number(t.width)!==m||Number(t.height)!==_)throw new l.A("Each face in options.source must have the same width and height.")}}const g=m;if(!(0,s.A)(m)||!(0,s.A)(_))throw new l.A("options requires a source field to create an initialized cube map or width and height fields to create a blank cube map.");if(m!==_)throw new l.A("Width must equal height.");if(g<=0)throw new l.A("Width and height must be greater than zero.");if(g>f.A.maximumCubeMapSize)throw new l.A(`Width and height must be less than or equal to the maximum cube map size (${f.A.maximumCubeMapSize}). Check maximumCubeMapSize.`);if(!d.A.validate(i))throw new l.A("Invalid options.pixelFormat.");if(d.A.isDepthFormat(i))throw new l.A("options.pixelFormat cannot be DEPTH_COMPONENT or DEPTH_STENCIL.");if(!y.A.validate(o))throw new l.A("Invalid options.pixelDatatype.");if(o===y.A.FLOAT&&!t.floatingPointTexture)throw new l.A("When options.pixelDatatype is FLOAT, this WebGL implementation must support the OES_texture_float extension.");if(o===y.A.HALF_FLOAT&&!t.halfFloatingPointTexture)throw new l.A("When options.pixelDatatype is HALF_FLOAT, this WebGL implementation must support the OES_texture_half_float extension.");const b=6*d.A.textureSizeInBytes(i,o,g,g),w=d.A.toInternalFormat(i,o,t),T=t._gl,S=T.TEXTURE_CUBE_MAP,D=T.createTexture();this._context=t,this._textureFilterAnisotropic=t._textureFilterAnisotropic,this._textureTarget=S,this._texture=D,this._pixelFormat=i,this._pixelDatatype=o,this._size=g,this._hasMipmap=!1,this._sizeInBytes=b,this._preMultiplyAlpha=p,this._flipY=c;const O=(0,s.A)(n);function z(e){return new A.A(t,D,S,e,w,i,o,g,p,c,O)}this._positiveX=z(T.TEXTURE_CUBE_MAP_POSITIVE_X),this._negativeX=z(T.TEXTURE_CUBE_MAP_NEGATIVE_X),this._positiveY=z(T.TEXTURE_CUBE_MAP_POSITIVE_Y),this._negativeY=z(T.TEXTURE_CUBE_MAP_NEGATIVE_Y),this._positiveZ=z(T.TEXTURE_CUBE_MAP_POSITIVE_Z),this._negativeZ=z(T.TEXTURE_CUBE_MAP_NEGATIVE_Z),this._sampler=u,E(this,u),T.activeTexture(T.TEXTURE0),T.bindTexture(S,D),h?T.pixelStorei(T.UNPACK_COLORSPACE_CONVERSION_WEBGL,T.NONE):T.pixelStorei(T.UNPACK_COLORSPACE_CONVERSION_WEBGL,T.BROWSER_DEFAULT_WEBGL);for(const e of x.faceNames())C(this[e],n?.[e],0);T.bindTexture(S,null)}function C(e,t,n){n=n??0;const i=e._targetFace,o=Math.max(Math.floor(e._size/2**n),1),r=e._pixelFormat,a=e._pixelDatatype,c=e._internalFormat,l=e._flipY,h=e._preMultiplyAlpha,u=e._context,p=u._gl;if(!(0,s.A)(t))return void p.texImage2D(i,n,c,o,o,0,r,y.A.toWebGLConstant(a,u),null);let{arrayBufferView:m}=t,f=4;(0,s.A)(m)&&(f=d.A.alignmentInBytes(r,a,o)),p.pixelStorei(p.UNPACK_ALIGNMENT,f),(0,s.A)(m)?(p.pixelStorei(p.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),p.pixelStorei(p.UNPACK_FLIP_Y_WEBGL,!1),l&&(m=d.A.flipY(m,r,a,o,o)),p.texImage2D(i,n,c,o,o,0,r,y.A.toWebGLConstant(a,u),m)):(p.pixelStorei(p.UNPACK_PREMULTIPLY_ALPHA_WEBGL,h),p.pixelStorei(p.UNPACK_FLIP_Y_WEBGL,l),p.texImage2D(i,n,c,r,y.A.toWebGLConstant(a,u),t))}function E(e,t){let{minificationFilter:n,magnificationFilter:i}=t;const o=[w.A.NEAREST_MIPMAP_NEAREST,w.A.NEAREST_MIPMAP_LINEAR,w.A.LINEAR_MIPMAP_NEAREST,w.A.LINEAR_MIPMAP_LINEAR].includes(n),r=e._context,a=e._pixelDatatype;(a===y.A.FLOAT&&!r.textureFloatLinear||a===y.A.HALF_FLOAT&&!r.textureHalfFloatLinear)&&(n=o?w.A.NEAREST_MIPMAP_NEAREST:w.A.NEAREST,i=b.A.NEAREST);const c=r._gl,l=e._textureTarget;c.activeTexture(c.TEXTURE0),c.bindTexture(l,e._texture),c.texParameteri(l,c.TEXTURE_MIN_FILTER,n),c.texParameteri(l,c.TEXTURE_MAG_FILTER,i),c.texParameteri(l,c.TEXTURE_WRAP_S,t.wrapS),c.texParameteri(l,c.TEXTURE_WRAP_T,t.wrapT),(0,s.A)(e._textureFilterAnisotropic)&&c.texParameteri(l,e._textureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT,t.maximumAnisotropy),c.bindTexture(l,null)}x.prototype.copyFace=function(e,t,n,i){const o=e.context,r=new _.A({context:o,colorTextures:[t],destroyAttachments:!1});r._bind(),this[n].copyMipmapFromFramebuffer(0,0,t.width,t.height,i??0),r._unBind(),r.destroy()},x.FaceName=Object.freeze({POSITIVEX:"positiveX",NEGATIVEX:"negativeX",POSITIVEY:"positiveY",NEGATIVEY:"negativeY",POSITIVEZ:"positiveZ",NEGATIVEZ:"negativeZ"}),x.faceNames=function(){return function*(){yield x.FaceName.POSITIVEX,yield x.FaceName.NEGATIVEX,yield x.FaceName.POSITIVEY,yield x.FaceName.NEGATIVEY,yield x.FaceName.POSITIVEZ,yield x.FaceName.NEGATIVEZ}()},x.loadFace=C,Object.defineProperties(x.prototype,{positiveX:{get:function(){return this._positiveX}},negativeX:{get:function(){return this._negativeX}},positiveY:{get:function(){return this._positiveY}},negativeY:{get:function(){return this._negativeY}},positiveZ:{get:function(){return this._positiveZ}},negativeZ:{get:function(){return this._negativeZ}},sampler:{get:function(){return this._sampler},set:function(e){E(this,e),this._sampler=e}},pixelFormat:{get:function(){return this._pixelFormat}},pixelDatatype:{get:function(){return this._pixelDatatype}},width:{get:function(){return this._size}},height:{get:function(){return this._size}},sizeInBytes:{get:function(){return this._hasMipmap?Math.floor(4*this._sizeInBytes/3):this._sizeInBytes}},preMultiplyAlpha:{get:function(){return this._preMultiplyAlpha}},flipY:{get:function(){return this._flipY}},_target:{get:function(){return this._textureTarget}}}),x.getDirection=function(e,t){switch(e){case x.FaceName.POSITIVEX:return o.A.clone(o.A.UNIT_X,t);case x.FaceName.NEGATIVEX:return o.A.negate(o.A.UNIT_X,t);case x.FaceName.POSITIVEY:return o.A.clone(o.A.UNIT_Y,t);case x.FaceName.NEGATIVEY:return o.A.negate(o.A.UNIT_Y,t);case x.FaceName.POSITIVEZ:return o.A.clone(o.A.UNIT_Z,t);case x.FaceName.NEGATIVEZ:return o.A.negate(o.A.UNIT_Z,t)}},x.prototype.loadMipmaps=function(e,t){if(r.A.defined("source",e),!Array.isArray(e))throw new l.A("source must be an array");const n=Math.log2(this._size);if(e.length!==n)throw new l.A("all mip levels must be defined");t=t??!1;const i=this._context._gl,o=this._texture,a=this._textureTarget;i.activeTexture(i.TEXTURE0),i.bindTexture(a,o),t?i.pixelStorei(i.UNPACK_COLORSPACE_CONVERSION_WEBGL,i.NONE):i.pixelStorei(i.UNPACK_COLORSPACE_CONVERSION_WEBGL,i.BROWSER_DEFAULT_WEBGL);for(let t=0;t<e.length;t++){const n=e[t],i=t+1;for(const e of x.faceNames())C(this[e],n[e],i)}i.bindTexture(a,null),this._hasMipmap=!0},x.prototype.generateMipmap=function(e){if(e=e??g.A.DONT_CARE,this._size>1&&!u.A.isPowerOfTwo(this._size))throw new l.A("width and height must be a power of two to call generateMipmap().");if(!g.A.validate(e))throw new l.A("hint is invalid.");this._hasMipmap=!0;const t=this._context._gl,n=this._textureTarget;t.hint(t.GENERATE_MIPMAP_HINT,e),t.activeTexture(t.TEXTURE0),t.bindTexture(n,this._texture),t.generateMipmap(n),t.bindTexture(n,null)},x.createVertexArray=function(e){const t=i.A.createGeometry(i.A.fromDimensions({dimensions:new o.A(2,2,2),vertexFormat:p.A.POSITION_ONLY})),n=this._attributeLocations=h.A.createAttributeLocations(t);return T.A.fromGeometry({context:e,geometry:t,attributeLocations:n,bufferUsage:m.A.STATIC_DRAW})},x.prototype.isDestroyed=function(){return!1},x.prototype.destroy=function(){return this._context._gl.deleteTexture(this._texture),this._positiveX=(0,c.A)(this._positiveX),this._negativeX=(0,c.A)(this._negativeX),this._positiveY=(0,c.A)(this._positiveY),this._negativeY=(0,c.A)(this._negativeY),this._positiveZ=(0,c.A)(this._positiveZ),this._negativeZ=(0,c.A)(this._negativeZ),(0,c.A)(this)};const S=x},671495:(e,t,n)=>{"use strict";n.d(t,{A:()=>l});var i=n(369031),o=n(491446),r=n(605971),a=n(276904),s=n(57775);function c(e,t,n,i,o,r,a,s,c,l,h){this._context=e,this._texture=t,this._textureTarget=n,this._targetFace=i,this._pixelDatatype=a,this._internalFormat=o,this._pixelFormat=r,this._size=s,this._preMultiplyAlpha=c,this._flipY=l,this._initialized=h}Object.defineProperties(c.prototype,{pixelFormat:{get:function(){return this._pixelFormat}},pixelDatatype:{get:function(){return this._pixelDatatype}},_target:{get:function(){return this._targetFace}}}),c.prototype.copyFrom=function(e){i.A.defined("options",e);const{xOffset:t=0,yOffset:n=0,source:c,skipColorSpaceConversion:l=!1}=e;if(i.A.defined("options.source",c),i.A.typeOf.number.greaterThanOrEquals("xOffset",t,0),i.A.typeOf.number.greaterThanOrEquals("yOffset",n,0),t+c.width>this._size)throw new r.A("xOffset + options.source.width must be less than or equal to width.");if(n+c.height>this._size)throw new r.A("yOffset + options.source.height must be less than or equal to height.");const{width:h,height:u}=c,d=this._context._gl,p=this._textureTarget,m=this._targetFace;d.activeTexture(d.TEXTURE0),d.bindTexture(p,this._texture);let f=c.arrayBufferView;const A=this._size,_=this._pixelFormat,g=this._internalFormat,y=this._pixelDatatype,v=this._preMultiplyAlpha,b=this._flipY;let w=4;(0,o.A)(f)&&(w=a.A.alignmentInBytes(_,y,h)),d.pixelStorei(d.UNPACK_ALIGNMENT,w),l?d.pixelStorei(d.UNPACK_COLORSPACE_CONVERSION_WEBGL,d.NONE):d.pixelStorei(d.UNPACK_COLORSPACE_CONVERSION_WEBGL,d.BROWSER_DEFAULT_WEBGL);let T=!1;if(!this._initialized){let e;0===t&&0===n&&h===A&&u===A?((0,o.A)(f)?(d.pixelStorei(d.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),d.pixelStorei(d.UNPACK_FLIP_Y_WEBGL,!1),b&&(f=a.A.flipY(f,_,y,A,A)),e=f):(d.pixelStorei(d.UNPACK_PREMULTIPLY_ALPHA_WEBGL,v),d.pixelStorei(d.UNPACK_FLIP_Y_WEBGL,b),e=c),T=!0):(d.pixelStorei(d.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),d.pixelStorei(d.UNPACK_FLIP_Y_WEBGL,!1),e=a.A.createTypedArray(_,y,A,A)),d.texImage2D(m,0,g,A,A,0,_,s.A.toWebGLConstant(y,this._context),e),this._initialized=!0}T||((0,o.A)(f)?(d.pixelStorei(d.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),d.pixelStorei(d.UNPACK_FLIP_Y_WEBGL,!1),b&&(f=a.A.flipY(f,_,y,h,u)),d.texSubImage2D(m,0,t,n,h,u,_,s.A.toWebGLConstant(y,this._context),f)):(d.pixelStorei(d.UNPACK_PREMULTIPLY_ALPHA_WEBGL,v),d.pixelStorei(d.UNPACK_FLIP_Y_WEBGL,b),d.texSubImage2D(m,0,t,n,_,s.A.toWebGLConstant(y,this._context),c))),d.bindTexture(p,null)},c.prototype.copyFromFramebuffer=function(e,t,n,o,a,c){if(e=e??0,t=t??0,n=n??0,o=o??0,a=a??this._size,c=c??this._size,i.A.typeOf.number.greaterThanOrEquals("xOffset",e,0),i.A.typeOf.number.greaterThanOrEquals("yOffset",t,0),i.A.typeOf.number.greaterThanOrEquals("framebufferXOffset",n,0),i.A.typeOf.number.greaterThanOrEquals("framebufferYOffset",o,0),e+a>this._size)throw new r.A("xOffset + source.width must be less than or equal to width.");if(t+c>this._size)throw new r.A("yOffset + source.height must be less than or equal to height.");if(this._pixelDatatype===s.A.FLOAT)throw new r.A("Cannot call copyFromFramebuffer when the texture pixel data type is FLOAT.");if(this._pixelDatatype===s.A.HALF_FLOAT)throw new r.A("Cannot call copyFromFramebuffer when the texture pixel data type is HALF_FLOAT.");const l=this._context._gl,h=this._textureTarget;l.activeTexture(l.TEXTURE0),l.bindTexture(h,this._texture),l.copyTexSubImage2D(this._targetFace,0,e,t,n,o,a,c),l.bindTexture(h,null),this._initialized=!0},c.prototype.copyMipmapFromFramebuffer=function(e,t,n,o,a){if(e=e??0,t=t??0,n=n??this._size,o=o??this._size,a=a??0,i.A.typeOf.number.greaterThanOrEquals("xOffset",e,0),i.A.typeOf.number.greaterThanOrEquals("yOffset",t,0),e+n>this._size)throw new r.A("xOffset + source.width must be less than or equal to width.");if(t+o>this._size)throw new r.A("yOffset + source.height must be less than or equal to height.");if(this._pixelDatatype===s.A.FLOAT)throw new r.A("Cannot call copyFromFramebuffer when the texture pixel data type is FLOAT.");if(this._pixelDatatype===s.A.HALF_FLOAT)throw new r.A("Cannot call copyFromFramebuffer when the texture pixel data type is HALF_FLOAT.");const c=this._context._gl,l=this._textureTarget;c.activeTexture(c.TEXTURE0),c.bindTexture(l,this._texture),c.copyTexImage2D(this._targetFace,a,this._internalFormat,e,t,n,o,0),c.bindTexture(l,null),this._initialized=!0};const l=c},377496:(e,t,n)=>{"use strict";n.d(t,{A:()=>l});var i=n(915325),o=n(491446),r=n(402330);function a(e){e=e??i.A.EMPTY_OBJECT,this._boundingVolume=e.boundingVolume,this._orientedBoundingBox=e.orientedBoundingBox,this._modelMatrix=e.modelMatrix,this._primitiveType=e.primitiveType??r.A.TRIANGLES,this._vertexArray=e.vertexArray,this._count=e.count,this._offset=e.offset??0,this._instanceCount=e.instanceCount??0,this._shaderProgram=e.shaderProgram,this._uniformMap=e.uniformMap,this._renderState=e.renderState,this._framebuffer=e.framebuffer,this._pass=e.pass,this._owner=e.owner,this._debugOverlappingFrustums=0,this._pickId=e.pickId,this._pickMetadataAllowed=!0===e.pickMetadataAllowed,this._pickedMetadataInfo=void 0,this._flags=0,this.cull=e.cull??!0,this.occlude=e.occlude??!0,this.executeInClosestFrustum=e.executeInClosestFrustum??!1,this.debugShowBoundingVolume=e.debugShowBoundingVolume??!1,this.castShadows=e.castShadows??!1,this.receiveShadows=e.receiveShadows??!1,this.pickOnly=e.pickOnly??!1,this.depthForTranslucentClassification=e.depthForTranslucentClassification??!1,this.dirty=!0,this.lastDirtyTime=0,this.derivedCommands={}}function s(e,t){return(e._flags&t)===t}function c(e,t,n){n?e._flags|=t:e._flags&=~t}Object.defineProperties(a.prototype,{boundingVolume:{get:function(){return this._boundingVolume},set:function(e){this._boundingVolume!==e&&(this._boundingVolume=e,this.dirty=!0)}},orientedBoundingBox:{get:function(){return this._orientedBoundingBox},set:function(e){this._orientedBoundingBox!==e&&(this._orientedBoundingBox=e,this.dirty=!0)}},cull:{get:function(){return s(this,1)},set:function(e){s(this,1)!==e&&(c(this,1,e),this.dirty=!0)}},occlude:{get:function(){return s(this,2)},set:function(e){s(this,2)!==e&&(c(this,2,e),this.dirty=!0)}},modelMatrix:{get:function(){return this._modelMatrix},set:function(e){this._modelMatrix!==e&&(this._modelMatrix=e,this.dirty=!0)}},primitiveType:{get:function(){return this._primitiveType},set:function(e){this._primitiveType!==e&&(this._primitiveType=e,this.dirty=!0)}},vertexArray:{get:function(){return this._vertexArray},set:function(e){this._vertexArray!==e&&(this._vertexArray=e,this.dirty=!0)}},count:{get:function(){return this._count},set:function(e){this._count!==e&&(this._count=e,this.dirty=!0)}},offset:{get:function(){return this._offset},set:function(e){this._offset!==e&&(this._offset=e,this.dirty=!0)}},instanceCount:{get:function(){return this._instanceCount},set:function(e){this._instanceCount!==e&&(this._instanceCount=e,this.dirty=!0)}},shaderProgram:{get:function(){return this._shaderProgram},set:function(e){this._shaderProgram!==e&&(this._shaderProgram=e,this.dirty=!0)}},castShadows:{get:function(){return s(this,16)},set:function(e){s(this,16)!==e&&(c(this,16,e),this.dirty=!0)}},receiveShadows:{get:function(){return s(this,32)},set:function(e){s(this,32)!==e&&(c(this,32,e),this.dirty=!0)}},uniformMap:{get:function(){return this._uniformMap},set:function(e){this._uniformMap!==e&&(this._uniformMap=e,this.dirty=!0)}},renderState:{get:function(){return this._renderState},set:function(e){this._renderState!==e&&(this._renderState=e,this.dirty=!0)}},framebuffer:{get:function(){return this._framebuffer},set:function(e){this._framebuffer!==e&&(this._framebuffer=e,this.dirty=!0)}},pass:{get:function(){return this._pass},set:function(e){this._pass!==e&&(this._pass=e,this.dirty=!0)}},executeInClosestFrustum:{get:function(){return s(this,4)},set:function(e){s(this,4)!==e&&(c(this,4,e),this.dirty=!0)}},owner:{get:function(){return this._owner},set:function(e){this._owner!==e&&(this._owner=e,this.dirty=!0)}},debugShowBoundingVolume:{get:function(){return s(this,8)},set:function(e){s(this,8)!==e&&(c(this,8,e),this.dirty=!0)}},debugOverlappingFrustums:{get:function(){return this._debugOverlappingFrustums},set:function(e){this._debugOverlappingFrustums!==e&&(this._debugOverlappingFrustums=e,this.dirty=!0)}},pickId:{get:function(){return this._pickId},set:function(e){this._pickId!==e&&(this._pickId=e,this.dirty=!0)}},pickMetadataAllowed:{get:function(){return this._pickMetadataAllowed}},pickedMetadataInfo:{get:function(){return this._pickedMetadataInfo},set:function(e){this._pickedMetadataInfo!==e&&(this._pickedMetadataInfo=e,this.dirty=!0)}},pickOnly:{get:function(){return s(this,64)},set:function(e){s(this,64)!==e&&(c(this,64,e),this.dirty=!0)}},depthForTranslucentClassification:{get:function(){return s(this,128)},set:function(e){s(this,128)!==e&&(c(this,128,e),this.dirty=!0)}}}),a.shallowClone=function(e,t){if((0,o.A)(e))return(0,o.A)(t)||(t=new a),t._boundingVolume=e._boundingVolume,t._orientedBoundingBox=e._orientedBoundingBox,t._modelMatrix=e._modelMatrix,t._primitiveType=e._primitiveType,t._vertexArray=e._vertexArray,t._count=e._count,t._offset=e._offset,t._instanceCount=e._instanceCount,t._shaderProgram=e._shaderProgram,t._uniformMap=e._uniformMap,t._renderState=e._renderState,t._framebuffer=e._framebuffer,t._pass=e._pass,t._owner=e._owner,t._debugOverlappingFrustums=e._debugOverlappingFrustums,t._pickId=e._pickId,t._pickMetadataAllowed=e._pickMetadataAllowed,t._pickedMetadataInfo=e._pickedMetadataInfo,t._flags=e._flags,t.dirty=!0,t.lastDirtyTime=0,t},a.prototype.execute=function(e,t){e.draw(this,t)};const l=a},483128:(e,t,n)=>{"use strict";n.d(t,{A:()=>m});var i=n(369031),o=n(915325),r=n(491446),a=n(677354),s=n(605971),c=n(276904),l=n(430332),h=n(57775);function u(e,t,n){const i=e._gl;i.framebufferTexture2D(i.FRAMEBUFFER,t,n._target,n._texture,0)}function d(e,t,n){const i=e._gl;i.framebufferRenderbuffer(i.FRAMEBUFFER,t,i.RENDERBUFFER,n._getRenderbuffer())}function p(e){const t=(e=e??o.A.EMPTY_OBJECT).context;i.A.defined("options.context",t);const n=t._gl,a=l.A.maximumColorAttachments;if(this._gl=n,this._framebuffer=n.createFramebuffer(),this._colorTextures=[],this._colorRenderbuffers=[],this._activeColorAttachments=[],this._depthTexture=void 0,this._depthRenderbuffer=void 0,this._stencilRenderbuffer=void 0,this._depthStencilTexture=void 0,this._depthStencilRenderbuffer=void 0,this.destroyAttachments=e.destroyAttachments??!0,(0,r.A)(e.colorTextures)&&(0,r.A)(e.colorRenderbuffers))throw new s.A("Cannot have both color texture and color renderbuffer attachments.");if((0,r.A)(e.depthTexture)&&(0,r.A)(e.depthRenderbuffer))throw new s.A("Cannot have both a depth texture and depth renderbuffer attachment.");if((0,r.A)(e.depthStencilTexture)&&(0,r.A)(e.depthStencilRenderbuffer))throw new s.A("Cannot have both a depth-stencil texture and depth-stencil renderbuffer attachment.");const p=(0,r.A)(e.depthTexture)||(0,r.A)(e.depthRenderbuffer),m=(0,r.A)(e.depthStencilTexture)||(0,r.A)(e.depthStencilRenderbuffer);if(p&&m)throw new s.A("Cannot have both a depth and depth-stencil attachment.");if((0,r.A)(e.stencilRenderbuffer)&&m)throw new s.A("Cannot have both a stencil and depth-stencil attachment.");if(p&&(0,r.A)(e.stencilRenderbuffer))throw new s.A("Cannot have both a depth and stencil attachment.");if(this._bind(),(0,r.A)(e.colorTextures)){const n=e.colorTextures,i=this._colorTextures.length=this._activeColorAttachments.length=n.length;if(i>a)throw new s.A("The number of color attachments exceeds the number supported.");for(let e=0;e<i;++e){const i=n[e];if(!c.A.isColorFormat(i.pixelFormat))throw new s.A("The color-texture pixel-format must be a color format.");if(i.pixelDatatype===h.A.FLOAT&&!t.colorBufferFloat)throw new s.A("The color texture pixel datatype is FLOAT and the WebGL implementation does not support the EXT_color_buffer_float or WEBGL_color_buffer_float extensions. See Context.colorBufferFloat.");if(i.pixelDatatype===h.A.HALF_FLOAT&&!t.colorBufferHalfFloat)throw new s.A("The color texture pixel datatype is HALF_FLOAT and the WebGL implementation does not support the EXT_color_buffer_half_float extension. See Context.colorBufferHalfFloat.");const o=this._gl.COLOR_ATTACHMENT0+e;u(this,o,i),this._activeColorAttachments[e]=o,this._colorTextures[e]=i}}if((0,r.A)(e.colorRenderbuffers)){const t=e.colorRenderbuffers,n=this._colorRenderbuffers.length=this._activeColorAttachments.length=t.length;if(n>a)throw new s.A("The number of color attachments exceeds the number supported.");for(let e=0;e<n;++e){const n=t[e],i=this._gl.COLOR_ATTACHMENT0+e;d(this,i,n),this._activeColorAttachments[e]=i,this._colorRenderbuffers[e]=n}}if((0,r.A)(e.depthTexture)){const t=e.depthTexture;if(t.pixelFormat!==c.A.DEPTH_COMPONENT)throw new s.A("The depth-texture pixel-format must be DEPTH_COMPONENT.");u(this,this._gl.DEPTH_ATTACHMENT,t),this._depthTexture=t}if((0,r.A)(e.depthRenderbuffer)){const t=e.depthRenderbuffer;d(this,this._gl.DEPTH_ATTACHMENT,t),this._depthRenderbuffer=t}if((0,r.A)(e.stencilRenderbuffer)){const t=e.stencilRenderbuffer;d(this,this._gl.STENCIL_ATTACHMENT,t),this._stencilRenderbuffer=t}if((0,r.A)(e.depthStencilTexture)){const t=e.depthStencilTexture;if(t.pixelFormat!==c.A.DEPTH_STENCIL)throw new s.A("The depth-stencil pixel-format must be DEPTH_STENCIL.");u(this,this._gl.DEPTH_STENCIL_ATTACHMENT,t),this._depthStencilTexture=t}if((0,r.A)(e.depthStencilRenderbuffer)){const t=e.depthStencilRenderbuffer;d(this,this._gl.DEPTH_STENCIL_ATTACHMENT,t),this._depthStencilRenderbuffer=t}this._unBind()}Object.defineProperties(p.prototype,{status:{get:function(){this._bind();const e=this._gl.checkFramebufferStatus(this._gl.FRAMEBUFFER);return this._unBind(),e}},numberOfColorAttachments:{get:function(){return this._activeColorAttachments.length}},depthTexture:{get:function(){return this._depthTexture}},depthRenderbuffer:{get:function(){return this._depthRenderbuffer}},stencilRenderbuffer:{get:function(){return this._stencilRenderbuffer}},depthStencilTexture:{get:function(){return this._depthStencilTexture}},depthStencilRenderbuffer:{get:function(){return this._depthStencilRenderbuffer}},hasDepthAttachment:{get:function(){return!!(this.depthTexture||this.depthRenderbuffer||this.depthStencilTexture||this.depthStencilRenderbuffer)}}}),p.prototype._bind=function(){const e=this._gl;e.bindFramebuffer(e.FRAMEBUFFER,this._framebuffer)},p.prototype._unBind=function(){const e=this._gl;e.bindFramebuffer(e.FRAMEBUFFER,null)},p.prototype.bindDraw=function(){const e=this._gl;e.bindFramebuffer(e.DRAW_FRAMEBUFFER,this._framebuffer)},p.prototype.bindRead=function(){const e=this._gl;e.bindFramebuffer(e.READ_FRAMEBUFFER,this._framebuffer)},p.prototype._getActiveColorAttachments=function(){return this._activeColorAttachments},p.prototype.getColorTexture=function(e){if(!(0,r.A)(e)||e<0||e>=this._colorTextures.length)throw new s.A("index is required, must be greater than or equal to zero and must be less than the number of color attachments.");return this._colorTextures[e]},p.prototype.getColorRenderbuffer=function(e){if(!(0,r.A)(e)||e<0||e>=this._colorRenderbuffers.length)throw new s.A("index is required, must be greater than or equal to zero and must be less than the number of color attachments.");return this._colorRenderbuffers[e]},p.prototype.isDestroyed=function(){return!1},p.prototype.destroy=function(){if(this.destroyAttachments){const e=this._colorTextures;for(let t=0;t<e.length;++t){const n=e[t];(0,r.A)(n)&&n.destroy()}const t=this._colorRenderbuffers;for(let e=0;e<t.length;++e){const n=t[e];(0,r.A)(n)&&n.destroy()}this._depthTexture=this._depthTexture&&this._depthTexture.destroy(),this._depthRenderbuffer=this._depthRenderbuffer&&this._depthRenderbuffer.destroy(),this._stencilRenderbuffer=this._stencilRenderbuffer&&this._stencilRenderbuffer.destroy(),this._depthStencilTexture=this._depthStencilTexture&&this._depthStencilTexture.destroy(),this._depthStencilRenderbuffer=this._depthStencilRenderbuffer&&this._depthStencilRenderbuffer.destroy()}return this._gl.deleteFramebuffer(this._framebuffer),(0,a.A)(this)};const m=p},418906:(e,t,n)=>{"use strict";n.d(t,{A:()=>r});var i=n(352581);const o={DONT_CARE:i.A.DONT_CARE,FASTEST:i.A.FASTEST,NICEST:i.A.NICEST,validate:function(e){return e===o.DONT_CARE||e===o.FASTEST||e===o.NICEST}},r=Object.freeze(o)},760866:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i=Object.freeze({ENVIRONMENT:0,COMPUTE:1,GLOBE:2,TERRAIN_CLASSIFICATION:3,CESIUM_3D_TILE:4,CESIUM_3D_TILE_CLASSIFICATION:5,CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW:6,OPAQUE:7,TRANSLUCENT:8,VOXELS:9,GAUSSIAN_SPLATS:10,OVERLAY:11,NUMBER_OF_PASSES:12})},57775:(e,t,n)=>{"use strict";n.d(t,{A:()=>r});var i=n(352581);const o={UNSIGNED_BYTE:i.A.UNSIGNED_BYTE,UNSIGNED_SHORT:i.A.UNSIGNED_SHORT,UNSIGNED_INT:i.A.UNSIGNED_INT,FLOAT:i.A.FLOAT,HALF_FLOAT:i.A.HALF_FLOAT_OES,UNSIGNED_INT_24_8:i.A.UNSIGNED_INT_24_8,UNSIGNED_SHORT_4_4_4_4:i.A.UNSIGNED_SHORT_4_4_4_4,UNSIGNED_SHORT_5_5_5_1:i.A.UNSIGNED_SHORT_5_5_5_1,UNSIGNED_SHORT_5_6_5:i.A.UNSIGNED_SHORT_5_6_5,toWebGLConstant:function(e,t){switch(e){case o.UNSIGNED_BYTE:return i.A.UNSIGNED_BYTE;case o.UNSIGNED_SHORT:return i.A.UNSIGNED_SHORT;case o.UNSIGNED_INT:return i.A.UNSIGNED_INT;case o.FLOAT:return i.A.FLOAT;case o.HALF_FLOAT:return t.webgl2?i.A.HALF_FLOAT:i.A.HALF_FLOAT_OES;case o.UNSIGNED_INT_24_8:return i.A.UNSIGNED_INT_24_8;case o.UNSIGNED_SHORT_4_4_4_4:return i.A.UNSIGNED_SHORT_4_4_4_4;case o.UNSIGNED_SHORT_5_5_5_1:return i.A.UNSIGNED_SHORT_5_5_5_1;case o.UNSIGNED_SHORT_5_6_5:return o.UNSIGNED_SHORT_5_6_5}},isPacked:function(e){return e===o.UNSIGNED_INT_24_8||e===o.UNSIGNED_SHORT_4_4_4_4||e===o.UNSIGNED_SHORT_5_5_5_1||e===o.UNSIGNED_SHORT_5_6_5},sizeInBytes:function(e){switch(e){case o.UNSIGNED_BYTE:return 1;case o.UNSIGNED_SHORT:case o.UNSIGNED_SHORT_4_4_4_4:case o.UNSIGNED_SHORT_5_5_5_1:case o.UNSIGNED_SHORT_5_6_5:case o.HALF_FLOAT:return 2;case o.UNSIGNED_INT:case o.FLOAT:case o.UNSIGNED_INT_24_8:return 4}},validate:function(e){return e===o.UNSIGNED_BYTE||e===o.UNSIGNED_SHORT||e===o.UNSIGNED_INT||e===o.FLOAT||e===o.HALF_FLOAT||e===o.UNSIGNED_INT_24_8||e===o.UNSIGNED_SHORT_4_4_4_4||e===o.UNSIGNED_SHORT_5_5_5_1||e===o.UNSIGNED_SHORT_5_6_5},getTypedArrayConstructor:function(e){const t=o.sizeInBytes(e);return t===Uint8Array.BYTES_PER_ELEMENT?Uint8Array:t===Uint16Array.BYTES_PER_ELEMENT?Uint16Array:t===Float32Array.BYTES_PER_ELEMENT&&e===o.FLOAT?Float32Array:Uint32Array}},r=Object.freeze(o)},40118:(e,t,n)=>{"use strict";n.d(t,{A:()=>L});var i=n(647934),o=n(41476),r=n(915325),a=n(491446),s=n(605971),c=n(352581),l=n(666765),h=n(430332),u=n(240863);function d(e){return e===c.A.FUNC_ADD||e===c.A.FUNC_SUBTRACT||e===c.A.FUNC_REVERSE_SUBTRACT||e===c.A.MIN||e===c.A.MAX}function p(e){return e===c.A.ZERO||e===c.A.ONE||e===c.A.SRC_COLOR||e===c.A.ONE_MINUS_SRC_COLOR||e===c.A.DST_COLOR||e===c.A.ONE_MINUS_DST_COLOR||e===c.A.SRC_ALPHA||e===c.A.ONE_MINUS_SRC_ALPHA||e===c.A.DST_ALPHA||e===c.A.ONE_MINUS_DST_ALPHA||e===c.A.CONSTANT_COLOR||e===c.A.ONE_MINUS_CONSTANT_COLOR||e===c.A.CONSTANT_ALPHA||e===c.A.ONE_MINUS_CONSTANT_ALPHA||e===c.A.SRC_ALPHA_SATURATE}function m(e){return e===c.A.NEVER||e===c.A.LESS||e===c.A.EQUAL||e===c.A.LEQUAL||e===c.A.GREATER||e===c.A.NOTEQUAL||e===c.A.GEQUAL||e===c.A.ALWAYS}function f(e){return e===c.A.ZERO||e===c.A.KEEP||e===c.A.REPLACE||e===c.A.INCR||e===c.A.DECR||e===c.A.INVERT||e===c.A.INCR_WRAP||e===c.A.DECR_WRAP}function A(e){const t=e??r.A.EMPTY_OBJECT,n=t.cull??r.A.EMPTY_OBJECT,u=t.polygonOffset??r.A.EMPTY_OBJECT,A=t.scissorTest??r.A.EMPTY_OBJECT,_=A.rectangle??r.A.EMPTY_OBJECT,g=t.depthRange??r.A.EMPTY_OBJECT,y=t.depthTest??r.A.EMPTY_OBJECT,v=t.colorMask??r.A.EMPTY_OBJECT,b=t.blending??r.A.EMPTY_OBJECT,w=b.color??r.A.EMPTY_OBJECT,T=t.stencilTest??r.A.EMPTY_OBJECT,x=T.frontOperation??r.A.EMPTY_OBJECT,C=T.backOperation??r.A.EMPTY_OBJECT,E=t.sampleCoverage??r.A.EMPTY_OBJECT,S=t.viewport;if(this.frontFace=t.frontFace??l.A.COUNTER_CLOCKWISE,this.cull={enabled:n.enabled??!1,face:n.face??c.A.BACK},this.lineWidth=t.lineWidth??1,this.polygonOffset={enabled:u.enabled??!1,factor:u.factor??0,units:u.units??0},this.scissorTest={enabled:A.enabled??!1,rectangle:i.A.clone(_)},this.depthRange={near:g.near??0,far:g.far??1},this.depthTest={enabled:y.enabled??!1,func:y.func??c.A.LESS},this.colorMask={red:v.red??!0,green:v.green??!0,blue:v.blue??!0,alpha:v.alpha??!0},this.depthMask=t.depthMask??!0,this.stencilMask=t.stencilMask??-1,this.blending={enabled:b.enabled??!1,color:new o.A(w.red??0,w.green??0,w.blue??0,w.alpha??0),equationRgb:b.equationRgb??c.A.FUNC_ADD,equationAlpha:b.equationAlpha??c.A.FUNC_ADD,functionSourceRgb:b.functionSourceRgb??c.A.ONE,functionSourceAlpha:b.functionSourceAlpha??c.A.ONE,functionDestinationRgb:b.functionDestinationRgb??c.A.ZERO,functionDestinationAlpha:b.functionDestinationAlpha??c.A.ZERO},this.stencilTest={enabled:T.enabled??!1,frontFunction:T.frontFunction??c.A.ALWAYS,backFunction:T.backFunction??c.A.ALWAYS,reference:T.reference??0,mask:T.mask??-1,frontOperation:{fail:x.fail??c.A.KEEP,zFail:x.zFail??c.A.KEEP,zPass:x.zPass??c.A.KEEP},backOperation:{fail:C.fail??c.A.KEEP,zFail:C.zFail??c.A.KEEP,zPass:C.zPass??c.A.KEEP}},this.sampleCoverage={enabled:E.enabled??!1,value:E.value??1,invert:E.invert??!1},this.viewport=(0,a.A)(S)?new i.A(S.x,S.y,S.width,S.height):void 0,this.lineWidth<h.A.minimumAliasedLineWidth||this.lineWidth>h.A.maximumAliasedLineWidth)throw new s.A("renderState.lineWidth is out of range.  Check minimumAliasedLineWidth and maximumAliasedLineWidth.");if(!l.A.validate(this.frontFace))throw new s.A("Invalid renderState.frontFace.");if((D=this.cull.face)!==c.A.FRONT&&D!==c.A.BACK&&D!==c.A.FRONT_AND_BACK)throw new s.A("Invalid renderState.cull.face.");var D,O;if(this.scissorTest.rectangle.width<0||this.scissorTest.rectangle.height<0)throw new s.A("renderState.scissorTest.rectangle.width and renderState.scissorTest.rectangle.height must be greater than or equal to zero.");if(this.depthRange.near>this.depthRange.far)throw new s.A("renderState.depthRange.near can not be greater than renderState.depthRange.far.");if(this.depthRange.near<0)throw new s.A("renderState.depthRange.near must be greater than or equal to zero.");if(this.depthRange.far>1)throw new s.A("renderState.depthRange.far must be less than or equal to one.");if((O=this.depthTest.func)!==c.A.NEVER&&O!==c.A.LESS&&O!==c.A.EQUAL&&O!==c.A.LEQUAL&&O!==c.A.GREATER&&O!==c.A.NOTEQUAL&&O!==c.A.GEQUAL&&O!==c.A.ALWAYS)throw new s.A("Invalid renderState.depthTest.func.");if(this.blending.color.red<0||this.blending.color.red>1||this.blending.color.green<0||this.blending.color.green>1||this.blending.color.blue<0||this.blending.color.blue>1||this.blending.color.alpha<0||this.blending.color.alpha>1)throw new s.A("renderState.blending.color components must be greater than or equal to zero and less than or equal to one.");if(!d(this.blending.equationRgb))throw new s.A("Invalid renderState.blending.equationRgb.");if(!d(this.blending.equationAlpha))throw new s.A("Invalid renderState.blending.equationAlpha.");if(!p(this.blending.functionSourceRgb))throw new s.A("Invalid renderState.blending.functionSourceRgb.");if(!p(this.blending.functionSourceAlpha))throw new s.A("Invalid renderState.blending.functionSourceAlpha.");if(!p(this.blending.functionDestinationRgb))throw new s.A("Invalid renderState.blending.functionDestinationRgb.");if(!p(this.blending.functionDestinationAlpha))throw new s.A("Invalid renderState.blending.functionDestinationAlpha.");if(!m(this.stencilTest.frontFunction))throw new s.A("Invalid renderState.stencilTest.frontFunction.");if(!m(this.stencilTest.backFunction))throw new s.A("Invalid renderState.stencilTest.backFunction.");if(!f(this.stencilTest.frontOperation.fail))throw new s.A("Invalid renderState.stencilTest.frontOperation.fail.");if(!f(this.stencilTest.frontOperation.zFail))throw new s.A("Invalid renderState.stencilTest.frontOperation.zFail.");if(!f(this.stencilTest.frontOperation.zPass))throw new s.A("Invalid renderState.stencilTest.frontOperation.zPass.");if(!f(this.stencilTest.backOperation.fail))throw new s.A("Invalid renderState.stencilTest.backOperation.fail.");if(!f(this.stencilTest.backOperation.zFail))throw new s.A("Invalid renderState.stencilTest.backOperation.zFail.");if(!f(this.stencilTest.backOperation.zPass))throw new s.A("Invalid renderState.stencilTest.backOperation.zPass.");if((0,a.A)(this.viewport)){if(this.viewport.width<0)throw new s.A("renderState.viewport.width must be greater than or equal to zero.");if(this.viewport.height<0)throw new s.A("renderState.viewport.height must be greater than or equal to zero.");if(this.viewport.width>h.A.maximumViewportWidth)throw new s.A(`renderState.viewport.width must be less than or equal to the maximum viewport width (${h.A.maximumViewportWidth.toString()}).  Check maximumViewportWidth.`);if(this.viewport.height>h.A.maximumViewportHeight)throw new s.A(`renderState.viewport.height must be less than or equal to the maximum viewport height (${h.A.maximumViewportHeight.toString()}).  Check maximumViewportHeight.`)}this.id=0,this._applyFunctions=[]}let _=0,g={};function y(e,t,n){n?e.enable(t):e.disable(t)}function v(e,t){e.frontFace(t.frontFace)}function b(e,t){const n=t.cull,i=n.enabled;y(e,e.CULL_FACE,i),i&&e.cullFace(n.face)}function w(e,t){e.lineWidth(t.lineWidth)}function T(e,t){const n=t.polygonOffset,i=n.enabled;y(e,e.POLYGON_OFFSET_FILL,i),i&&e.polygonOffset(n.factor,n.units)}function x(e,t,n){const i=t.scissorTest,o=(0,a.A)(n.scissorTest)?n.scissorTest.enabled:i.enabled;if(y(e,e.SCISSOR_TEST,o),o){const t=(0,a.A)(n.scissorTest)?n.scissorTest.rectangle:i.rectangle;e.scissor(t.x,t.y,t.width,t.height)}}function C(e,t){const n=t.depthRange;e.depthRange(n.near,n.far)}function E(e,t){const n=t.depthTest,i=n.enabled;y(e,e.DEPTH_TEST,i),i&&e.depthFunc(n.func)}function S(e,t){const n=t.colorMask;e.colorMask(n.red,n.green,n.blue,n.alpha)}function D(e,t){e.depthMask(t.depthMask)}function O(e,t){e.stencilMask(t.stencilMask)}function z(e,t,n){const i=t.blending,o=(0,a.A)(n.blendingEnabled)?n.blendingEnabled:i.enabled;y(e,e.BLEND,o),o&&(function(e,t){e.blendColor(t.red,t.green,t.blue,t.alpha)}(e,i.color),e.blendEquationSeparate(i.equationRgb,i.equationAlpha),e.blendFuncSeparate(i.functionSourceRgb,i.functionDestinationRgb,i.functionSourceAlpha,i.functionDestinationAlpha))}function I(e,t){const n=t.stencilTest,i=n.enabled;if(y(e,e.STENCIL_TEST,i),i){const t=n.frontFunction,i=n.backFunction,o=n.reference,r=n.mask;e.stencilFunc(t,o,r),e.stencilFuncSeparate(e.BACK,i,o,r),e.stencilFuncSeparate(e.FRONT,t,o,r);const a=n.frontOperation,s=a.fail,c=a.zFail,l=a.zPass;e.stencilOpSeparate(e.FRONT,s,c,l);const h=n.backOperation,u=h.fail,d=h.zFail,p=h.zPass;e.stencilOpSeparate(e.BACK,u,d,p)}}function P(e,t){const n=t.sampleCoverage,i=n.enabled;y(e,e.SAMPLE_COVERAGE,i),i&&e.sampleCoverage(n.value,n.invert)}A.fromCache=function(e){const t=JSON.stringify(e);let n=g[t];if((0,a.A)(n))return++n.referenceCount,n.state;let i=new A(e);const o=JSON.stringify(i);return n=g[o],(0,a.A)(n)||(i.id=_++,i=(0,u.A)(i),n={referenceCount:0,state:i},g[o]=n),++n.referenceCount,g[t]={referenceCount:1,state:n.state},n.state},A.removeFromCache=function(e){const t=new A(e),n=JSON.stringify(t),i=g[n],o=JSON.stringify(e),r=g[o];(0,a.A)(r)&&(--r.referenceCount,0===r.referenceCount&&(delete g[o],(0,a.A)(i)&&--i.referenceCount)),(0,a.A)(i)&&0===i.referenceCount&&delete g[n]},A.getCache=function(){return g},A.clearCache=function(){g={}};const R=new i.A;function N(e,t,n){let i=t.viewport??n.viewport;(0,a.A)(i)||(i=R,i.width=n.context.drawingBufferWidth,i.height=n.context.drawingBufferHeight),n.context.uniformState.viewport=i,e.viewport(i.x,i.y,i.width,i.height)}A.apply=function(e,t,n){v(e,t),b(e,t),w(e,t),T(e,t),C(e,t),E(e,t),S(e,t),D(e,t),O(e,t),I(e,t),P(e,t),x(e,t,n),z(e,t,n),N(e,t,n)},A.partialApply=function(e,t,n,i,o,r){if(t!==n){let i=n._applyFunctions[t.id];(0,a.A)(i)||(i=function(e,t){const n=[];return e.frontFace!==t.frontFace&&n.push(v),e.cull.enabled===t.cull.enabled&&e.cull.face===t.cull.face||n.push(b),e.lineWidth!==t.lineWidth&&n.push(w),e.polygonOffset.enabled===t.polygonOffset.enabled&&e.polygonOffset.factor===t.polygonOffset.factor&&e.polygonOffset.units===t.polygonOffset.units||n.push(T),e.depthRange.near===t.depthRange.near&&e.depthRange.far===t.depthRange.far||n.push(C),e.depthTest.enabled===t.depthTest.enabled&&e.depthTest.func===t.depthTest.func||n.push(E),e.colorMask.red===t.colorMask.red&&e.colorMask.green===t.colorMask.green&&e.colorMask.blue===t.colorMask.blue&&e.colorMask.alpha===t.colorMask.alpha||n.push(S),e.depthMask!==t.depthMask&&n.push(D),e.stencilMask!==t.stencilMask&&n.push(O),e.stencilTest.enabled===t.stencilTest.enabled&&e.stencilTest.frontFunction===t.stencilTest.frontFunction&&e.stencilTest.backFunction===t.stencilTest.backFunction&&e.stencilTest.reference===t.stencilTest.reference&&e.stencilTest.mask===t.stencilTest.mask&&e.stencilTest.frontOperation.fail===t.stencilTest.frontOperation.fail&&e.stencilTest.frontOperation.zFail===t.stencilTest.frontOperation.zFail&&e.stencilTest.backOperation.fail===t.stencilTest.backOperation.fail&&e.stencilTest.backOperation.zFail===t.stencilTest.backOperation.zFail&&e.stencilTest.backOperation.zPass===t.stencilTest.backOperation.zPass||n.push(I),e.sampleCoverage.enabled===t.sampleCoverage.enabled&&e.sampleCoverage.value===t.sampleCoverage.value&&e.sampleCoverage.invert===t.sampleCoverage.invert||n.push(P),n}(t,n),n._applyFunctions[t.id]=i);const o=i.length;for(let t=0;t<o;++t)i[t](e,n)}(((0,a.A)(i.scissorTest)?i.scissorTest:t.scissorTest)!==((0,a.A)(o.scissorTest)?o.scissorTest:n.scissorTest)||r)&&x(e,n,o);const s=(0,a.A)(i.blendingEnabled)?i.blendingEnabled:t.blending.enabled,c=(0,a.A)(o.blendingEnabled)?o.blendingEnabled:n.blending.enabled;(s!==c||c&&t.blending!==n.blending)&&z(e,n,o),t===n&&i===o&&i.context===o.context||N(e,n,o)},A.getState=function(e){if(!(0,a.A)(e))throw new s.A("renderState is required.");return{frontFace:e.frontFace,cull:{enabled:e.cull.enabled,face:e.cull.face},lineWidth:e.lineWidth,polygonOffset:{enabled:e.polygonOffset.enabled,factor:e.polygonOffset.factor,units:e.polygonOffset.units},scissorTest:{enabled:e.scissorTest.enabled,rectangle:i.A.clone(e.scissorTest.rectangle)},depthRange:{near:e.depthRange.near,far:e.depthRange.far},depthTest:{enabled:e.depthTest.enabled,func:e.depthTest.func},colorMask:{red:e.colorMask.red,green:e.colorMask.green,blue:e.colorMask.blue,alpha:e.colorMask.alpha},depthMask:e.depthMask,stencilMask:e.stencilMask,blending:{enabled:e.blending.enabled,color:o.A.clone(e.blending.color),equationRgb:e.blending.equationRgb,equationAlpha:e.blending.equationAlpha,functionSourceRgb:e.blending.functionSourceRgb,functionSourceAlpha:e.blending.functionSourceAlpha,functionDestinationRgb:e.blending.functionDestinationRgb,functionDestinationAlpha:e.blending.functionDestinationAlpha},stencilTest:{enabled:e.stencilTest.enabled,frontFunction:e.stencilTest.frontFunction,backFunction:e.stencilTest.backFunction,reference:e.stencilTest.reference,mask:e.stencilTest.mask,frontOperation:{fail:e.stencilTest.frontOperation.fail,zFail:e.stencilTest.frontOperation.zFail,zPass:e.stencilTest.frontOperation.zPass},backOperation:{fail:e.stencilTest.backOperation.fail,zFail:e.stencilTest.backOperation.zFail,zPass:e.stencilTest.backOperation.zPass}},sampleCoverage:{enabled:e.sampleCoverage.enabled,value:e.sampleCoverage.value,invert:e.sampleCoverage.invert},viewport:(0,a.A)(e.viewport)?i.A.clone(e.viewport):void 0}};const L=A},654799:(e,t,n)=>{"use strict";n.d(t,{A:()=>u});var i=n(369031),o=n(915325),r=n(491446),a=n(605971),s=n(957233),c=n(78078),l=n(557448);function h(e){e=e??o.A.EMPTY_OBJECT;const{wrapR:t=l.A.CLAMP_TO_EDGE,wrapS:n=l.A.CLAMP_TO_EDGE,wrapT:r=l.A.CLAMP_TO_EDGE,minificationFilter:h=c.A.LINEAR,magnificationFilter:u=s.A.LINEAR,maximumAnisotropy:d=1}=e;if(!l.A.validate(t))throw new a.A("Invalid sampler.wrapR.");if(!l.A.validate(n))throw new a.A("Invalid sampler.wrapS.");if(!l.A.validate(r))throw new a.A("Invalid sampler.wrapT.");if(!c.A.validate(h))throw new a.A("Invalid sampler.minificationFilter.");if(!s.A.validate(u))throw new a.A("Invalid sampler.magnificationFilter.");i.A.typeOf.number.greaterThanOrEquals("maximumAnisotropy",d,1),this._wrapR=t,this._wrapS=n,this._wrapT=r,this._minificationFilter=h,this._magnificationFilter=u,this._maximumAnisotropy=d}Object.defineProperties(h.prototype,{wrapR:{get:function(){return this._wrapR}},wrapS:{get:function(){return this._wrapS}},wrapT:{get:function(){return this._wrapT}},minificationFilter:{get:function(){return this._minificationFilter}},magnificationFilter:{get:function(){return this._magnificationFilter}},maximumAnisotropy:{get:function(){return this._maximumAnisotropy}}}),h.equals=function(e,t){return e===t||(0,r.A)(e)&&(0,r.A)(t)&&e._wrapR===t._wrapR&&e._wrapS===t._wrapS&&e._wrapT===t._wrapT&&e._minificationFilter===t._minificationFilter&&e._magnificationFilter===t._magnificationFilter&&e._maximumAnisotropy===t._maximumAnisotropy},h.NEAREST=Object.freeze(new h({wrapR:l.A.CLAMP_TO_EDGE,wrapS:l.A.CLAMP_TO_EDGE,wrapT:l.A.CLAMP_TO_EDGE,minificationFilter:c.A.NEAREST,magnificationFilter:s.A.NEAREST}));const u=h},302836:(e,t,n)=>{"use strict";n.d(t,{A:()=>y});var i=n(369031),o=n(915325),r=n(491446),a=n(677354),s=n(605971),c=n(123245),l=n(481),h=n(430332),u=n(764011),d=n(757146);let p=0;function m(e){let t=e.vertexShaderText,n=e.fragmentShaderText;"undefined"!=typeof spector&&(t=t.replace(/^#line/gm,"//#line"),n=n.replace(/^#line/gm,"//#line"));const i=function(e,t){const n={};if(!h.A.highpFloatSupported||!h.A.highpIntSupported){let i,o,r,a;const s=f(e),c=f(t),l=s.length,h=c.length;for(i=0;i<l;i++)for(o=0;o<h;o++)if(s[i]===c[o]){r=s[i],a=`czm_mediump_${r}`;const e=new RegExp(`${r}\\b`,"g");t=t.replace(e,a),n[a]=r}}return{fragmentShaderText:t,duplicateUniformNames:n}}(t,n);this._gl=e.gl,this._logShaderCompilation=e.logShaderCompilation,this._debugShaders=e.debugShaders,this._attributeLocations=e.attributeLocations,this._program=void 0,this._numberOfVertexAttributes=void 0,this._vertexAttributes=void 0,this._uniformsByName=void 0,this._uniforms=void 0,this._automaticUniforms=void 0,this._manualUniforms=void 0,this._duplicateUniformNames=i.duplicateUniformNames,this._cachedShader=void 0,this.maximumTextureUnitIndex=void 0,this._vertexShaderSource=e.vertexShaderSource,this._vertexShaderText=e.vertexShaderText,this._fragmentShaderSource=e.fragmentShaderSource,this._fragmentShaderText=i.fragmentShaderText,this.id=p++}function f(e){const t=[],n=e.match(/uniform.*?(?![^{]*})(?=[=\[;])/g);if((0,r.A)(n)){const e=n.length;for(let i=0;i<e;i++){const e=n[i].trim(),o=e.slice(e.lastIndexOf(" ")+1);t.push(o)}}return t}m.fromCache=function(e){return e=e??o.A.EMPTY_OBJECT,i.A.defined("options.context",e.context),e.context.shaderCache.getShaderProgram(e)},m.replaceCache=function(e){return e=e??o.A.EMPTY_OBJECT,i.A.defined("options.context",e.context),e.context.shaderCache.replaceShaderProgram(e)},Object.defineProperties(m.prototype,{vertexShaderSource:{get:function(){return this._vertexShaderSource}},fragmentShaderSource:{get:function(){return this._fragmentShaderSource}},vertexAttributes:{get:function(){return _(this),this._vertexAttributes}},numberOfVertexAttributes:{get:function(){return _(this),this._numberOfVertexAttributes}},allUniforms:{get:function(){return _(this),this._uniformsByName}}});const A="[Cesium WebGL] ";function _(e){(0,r.A)(e._program)||g(e)}function g(e){const t=e._program,n=e._gl,i=function(e,t){const n=t._vertexShaderText,i=t._fragmentShaderText,o=e.createShader(e.VERTEX_SHADER);e.shaderSource(o,n),e.compileShader(o);const a=e.createShader(e.FRAGMENT_SHADER);e.shaderSource(a,i),e.compileShader(a);const s=e.createProgram();e.attachShader(s,o),e.attachShader(s,a);const l=t._attributeLocations;if((0,r.A)(l))for(const t in l)l.hasOwnProperty(t)&&e.bindAttribLocation(s,l[t],t);let h,u;if(e.linkProgram(s),e.getProgramParameter(s,e.LINK_STATUS))return t._logShaderCompilation&&(h=e.getShaderInfoLog(o),(0,r.A)(h)&&h.length>0&&console.log(`${A}Vertex shader compile log: ${h}`),h=e.getShaderInfoLog(a),(0,r.A)(h)&&h.length>0&&console.log(`${A}Fragment shader compile log: ${h}`),h=e.getProgramInfoLog(s),(0,r.A)(h)&&h.length>0&&console.log(`${A}Shader program link log: ${h}`)),e.deleteShader(o),e.deleteShader(a),s;const d=t._debugShaders;throw e.getShaderParameter(a,e.COMPILE_STATUS)?e.getShaderParameter(o,e.COMPILE_STATUS)?(h=e.getProgramInfoLog(s),console.error(`${A}Shader program link log: ${h}`),p(o,"vertex"),p(a,"fragment"),u=`Program failed to link.  Link log: ${h}`):(h=e.getShaderInfoLog(o),console.error(`${A}Vertex shader compile log: ${h}`),console.error(`${A} Vertex shader source:\n${n}`),u=`Vertex shader failed to compile.  Compile log: ${h}`):(h=e.getShaderInfoLog(a),console.error(`${A}Fragment shader compile log: ${h}`),console.error(`${A} Fragment shader source:\n${i}`),u=`Fragment shader failed to compile.  Compile log: ${h}`),e.deleteShader(o),e.deleteShader(a),e.deleteProgram(s),new c.A(u);function p(e,t){if(!(0,r.A)(d))return;const n=d.getTranslatedShaderSource(e);""!==n?console.error(`${A}Translated ${t} shaderSource:\n${n}`):console.error(`${A}${t} shader translation failed.`)}}(n,e,e._debugShaders),o=n.getProgramParameter(i,n.ACTIVE_ATTRIBUTES),a=function(e,t){const n={},i=[],o=[],a=e.getProgramParameter(t,e.ACTIVE_UNIFORMS);for(let s=0;s<a;++s){const a=e.getActiveUniform(t,s),c="[0]",l=-1!==a.name.indexOf(c,a.name.length-c.length)?a.name.slice(0,a.name.length-3):a.name;if(0!==l.indexOf("gl_"))if(a.name.indexOf("[")<0){const r=e.getUniformLocation(t,l);if(null!==r){const t=(0,u.A)(e,a,l,r);n[l]=t,i.push(t),t._setSampler&&o.push(t)}}else{let s,c,h,u;const p=l.indexOf("[");if(p>=0){if(s=n[l.slice(0,p)],!(0,r.A)(s))continue;c=s._locations,c.length<=1&&(h=s.value,u=e.getUniformLocation(t,l),null!==u&&(c.push(u),h.push(e.getUniform(t,u))))}else{c=[];for(let n=0;n<a.size;++n)u=e.getUniformLocation(t,`${l}[${n}]`),null!==u&&c.push(u);s=(0,d.A)(e,a,l,c),n[l]=s,i.push(s),s._setSampler&&o.push(s)}}}return{uniformsByName:n,uniforms:i,samplerUniforms:o}}(n,i),s=function(e,t){const n=[],i=[];for(const o in t)if(t.hasOwnProperty(o)){const a=t[o];let s=o;const c=e._duplicateUniformNames[s];(0,r.A)(c)&&(a.name=c,s=c);const h=l.A[s];(0,r.A)(h)?n.push({uniform:a,automaticUniform:h}):i.push(a)}return{automaticUniforms:n,manualUniforms:i}}(e,a.uniformsByName);e._program=i,e._numberOfVertexAttributes=o,e._vertexAttributes=function(e,t,n){const i={};for(let o=0;o<n;++o){const n=e.getActiveAttrib(t,o),r=e.getAttribLocation(t,n.name);i[n.name]={name:n.name,type:n.type,index:r}}return i}(n,i,o),e._uniformsByName=a.uniformsByName,e._uniforms=a.uniforms,e._automaticUniforms=s.automaticUniforms,e._manualUniforms=s.manualUniforms,e.maximumTextureUnitIndex=function(e,t,n){e.useProgram(t);let i=0;const o=n.length;for(let e=0;e<o;++e)i=n[e]._setSampler(i);return e.useProgram(null),i}(n,i,a.samplerUniforms),t&&e._gl.deleteProgram(t),"undefined"!=typeof spector&&(e._program.__SPECTOR_rebuildProgram=function(t,n,i,o){const r=e._vertexShaderText,a=e._fragmentShaderText,s=/ ! = /g;e._vertexShaderText=t.replace(s," != "),e._fragmentShaderText=n.replace(s," != ");try{g(e),i(e._program)}catch(t){e._vertexShaderText=r,e._fragmentShaderText=a;const n=/(?:Compile|Link) error: ([^]*)/.exec(t.message);o(n?n[1]:t.message)}})}m.prototype._bind=function(){_(this),this._gl.useProgram(this._program)},m.prototype._setUniforms=function(e,t,n){let i,o;if((0,r.A)(e)){const t=this._manualUniforms;for(i=t.length,o=0;o<i;++o){const n=t[o];if(!(0,r.A)(e[n.name]))throw new s.A(`Unknown uniform: ${n.name}`);n.value=e[n.name]()}}const a=this._automaticUniforms;for(i=a.length,o=0;o<i;++o){const e=a[o];e.uniform.value=e.automaticUniform.getValue(t)}const c=this._uniforms;for(i=c.length,o=0;o<i;++o)c[o].set();if(n){const e=this._gl,t=this._program;if(e.validateProgram(t),!e.getProgramParameter(t,e.VALIDATE_STATUS))throw new s.A(`Program validation failed.  Program info log: ${e.getProgramInfoLog(t)}`)}},m.prototype.isDestroyed=function(){return!1},m.prototype.destroy=function(){this._cachedShader.cache.releaseShaderProgram(this)},m.prototype.finalDestroy=function(){return this._gl.deleteProgram(this._program),(0,a.A)(this)};const y=m},342875:(e,t,n)=>{"use strict";n.d(t,{A:()=>y});var i=n(915325),o=n(491446),r=n(605971),a=n(2218),s=n(481),c=n(790868);function l(e){return(e=e.replace(/\/\/.*/g,"")).replace(/\/\*\*[\s\S]*?\*\//gm,function(e){const t=e.match(/\n/gm).length;let n="";for(let e=0;e<t;++e)n+="\n";return n})}function h(e,t,n){let i;for(let t=0;t<n.length;++t)n[t].name===e&&(i=n[t]);return(0,o.A)(i)||(i={name:e,glslSource:t=l(t),dependsOn:[],requiredBy:[],evaluated:!1},n.push(i)),i}function u(e,t){if(e.evaluated)return;e.evaluated=!0;let n=e.glslSource.match(/\bczm_[a-zA-Z0-9_]*/g);(0,o.A)(n)&&null!==n&&(n=n.filter(function(e,t){return n.indexOf(e)===t}),n.forEach(function(n){if(n!==e.name&&m._czmBuiltinsAndUniforms.hasOwnProperty(n)){const i=h(n,m._czmBuiltinsAndUniforms[n],t);e.dependsOn.push(i),i.requiredBy.push(e),u(i,t)}}))}function d(e){const t=[],n=h("main",e,t);u(n,t),function(e){const t=[],n=[];for(;e.length>0;){const i=e.pop();n.push(i),0===i.requiredBy.length&&t.push(i)}for(;t.length>0;){const n=t.shift();e.push(n);for(let e=0;e<n.dependsOn.length;++e){const i=n.dependsOn[e],o=i.requiredBy.indexOf(n);i.requiredBy.splice(o,1),0===i.requiredBy.length&&t.push(i)}}const i=[];for(let e=0;e<n.length;++e)0!==n[e].requiredBy.length&&i.push(n[e]);if(0!==i.length){let e="A circular dependency was found in the following built-in functions/structs/constants: \n";for(let t=0;t<i.length;++t)e=`${e+i[t].name}\n`;throw new r.A(e)}}(t);let i="";for(let e=t.length-1;e>=0;--e)i=`${i+t[e].glslSource}\n`;return i.replace(n.glslSource,"")}function p(e,t,n){let i,a,s="";const h=e.sources;if((0,o.A)(h))for(i=0,a=h.length;i<a;++i)s+=`\n#line 0\n${h[i]}`;let u;s=l(s),s=s.replace(/#version\s+(.*?)\n/gm,function(e,t){if((0,o.A)(u)&&u!==t)throw new r.A(`inconsistent versions found: ${u} and ${t}`);return u=t,"\n"});const p=[];s=s.replace(/#extension.*\n/gm,function(e){return p.push(e),"\n"}),s=s.replace(/precision\s(lowp|mediump|highp)\s(float|int);/,"");const f=e.pickColorQualifier;(0,o.A)(f)&&(s=m.createPickFragmentShaderSource(s,f));let A="";const _=p.length;for(i=0;i<_;i++)A+=p[i];t&&(A+="#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n    precision highp int;\n#else\n    precision mediump float;\n    precision mediump int;\n    #define highp mediump\n#endif\n\n");const g=e.defines;if((0,o.A)(g))for(i=0,a=g.length;i<a;++i){const e=g[i];0!==e.length&&(A+=`#define ${e}\n`)}n.textureFloatLinear&&(A+="#define OES_texture_float_linear\n\n"),n.floatingPointTexture&&(A+="#define OES_texture_float\n\n");let y="";e.includeBuiltIns&&(y=d(s)),A+="\n#line 0\n";const v=y+s;return n.webgl2&&t&&!/layout\s*\(location\s*=\s*0\)\s*out\s+vec4\s+out_FragColor;/g.test(v)&&!/czm_out_FragColor/g.test(v)&&/out_FragColor/g.test(v)&&(A+="layout(location = 0) out vec4 out_FragColor;\n\n"),A+=y,A+=s,A=n.webgl2?`#version 300 es\n${A}`:(0,c.A)(A,t),A}function m(e){const t=(e=e??i.A.EMPTY_OBJECT).pickColorQualifier;if((0,o.A)(t)&&"uniform"!==t&&"in"!==t)throw new r.A("options.pickColorQualifier must be 'uniform' or 'in'.");this.defines=(0,o.A)(e.defines)?e.defines.slice(0):[],this.sources=(0,o.A)(e.sources)?e.sources.slice(0):[],this.pickColorQualifier=t,this.includeBuiltIns=e.includeBuiltIns??!0}m.prototype.clone=function(){return new m({sources:this.sources,defines:this.defines,pickColorQualifier:this.pickColorQualifier,includeBuiltIns:this.includeBuiltIns})},m.replaceMain=function(e,t){return t=`void ${t}()`,e.replace(/void\s+main\s*\(\s*(?:void)?\s*\)/g,t)},m.prototype.getCacheKey=function(){return`${this.defines.slice().sort().join(",")}:${this.pickColorQualifier}:${this.includeBuiltIns}:${this.sources.join("\n")}`},m.prototype.createCombinedVertexShader=function(e){return p(this,!1,e)},m.prototype.createCombinedFragmentShader=function(e){return p(this,!0,e)},m._czmBuiltinsAndUniforms={};for(const e in a.A)a.A.hasOwnProperty(e)&&(m._czmBuiltinsAndUniforms[e]=a.A[e]);for(const e in s.A)if(s.A.hasOwnProperty(e)){const t=s.A[e];"function"==typeof t.getDeclaration&&(m._czmBuiltinsAndUniforms[e]=t.getDeclaration(e))}function f(e,t){const n=e.sources,i=n.length;for(let e=0;e<i;++e)if(-1!==n[e].indexOf(t))return!0;return!1}function A(e,t){const n=t.length;for(let i=0;i<n;++i){const n=t[i];if(f(e,n))return n}}m.createPickVertexShaderSource=function(e){return`${m.replaceMain(e,"czm_old_main")}\nin vec4 pickColor; \nout vec4 czm_pickColor; \nvoid main() \n{ \n    czm_old_main(); \n    czm_pickColor = pickColor; \n}`},m.createPickFragmentShaderSource=function(e,t){return`${m.replaceMain(e,"czm_old_main")}\n${t} vec4 czm_pickColor; \nvoid main() \n{ \n    czm_old_main(); \n    if (out_FragColor.a == 0.0) { \n       discard; \n    } \n    out_FragColor = czm_pickColor; \n}`};const _=["v_normalEC","v_normal"];m.findNormalVarying=function(e){return f(e,"#ifdef HAS_NORMALS")?function(e){const t=e.defines,n=t.length;for(let e=0;e<n;++e)if("HAS_NORMALS"===t[e])return!0;return!1}(e)?"v_normalEC":void 0:A(e,_)};const g=["v_positionEC"];m.findPositionVarying=function(e){return A(e,g)};const y=m},616e3:(e,t,n)=>{"use strict";n.d(t,{A:()=>x});var i=n(434067),o=n(369031),r=n(673874),a=n(915325),s=n(491446),c=n(677354),l=n(605971),h=n(367817),u=n(276904),d=n(430332),p=n(418906),m=n(57775),f=n(654799),A=n(957233),_=n(78078);function g(e){e=e??a.A.EMPTY_OBJECT,o.A.defined("options.context",e.context);const{context:t,source:n,pixelFormat:c=u.A.RGBA,pixelDatatype:h=m.A.UNSIGNED_BYTE,flipY:p=!0,skipColorSpaceConversion:A=!1,sampler:_=new f.A}=e;let{width:g,height:x}=e;(0,s.A)(n)&&((0,s.A)(g)||(g=n.videoWidth??n.naturalWidth??n.width),(0,s.A)(x)||(x=n.videoHeight??n.naturalHeight??n.height));const C=e.preMultiplyAlpha||c===u.A.RGB||c===u.A.LUMINANCE,E=u.A.toInternalFormat(c,h,t),S=u.A.isCompressedFormat(E);if(!(0,s.A)(g)||!(0,s.A)(x))throw new l.A("options requires a source field to create an initialized texture or width and height fields to create a blank texture.");if(o.A.typeOf.number.greaterThan("width",g,0),g>d.A.maximumTextureSize)throw new l.A(`Width must be less than or equal to the maximum texture size (${d.A.maximumTextureSize}).  Check maximumTextureSize.`);if(o.A.typeOf.number.greaterThan("height",x,0),x>d.A.maximumTextureSize)throw new l.A(`Height must be less than or equal to the maximum texture size (${d.A.maximumTextureSize}).  Check maximumTextureSize.`);if(!u.A.validate(c))throw new l.A("Invalid options.pixelFormat.");if(!S&&!m.A.validate(h))throw new l.A("Invalid options.pixelDatatype.");if(c===u.A.DEPTH_COMPONENT&&h!==m.A.UNSIGNED_SHORT&&h!==m.A.UNSIGNED_INT)throw new l.A("When options.pixelFormat is DEPTH_COMPONENT, options.pixelDatatype must be UNSIGNED_SHORT or UNSIGNED_INT.");if(c===u.A.DEPTH_STENCIL&&h!==m.A.UNSIGNED_INT_24_8)throw new l.A("When options.pixelFormat is DEPTH_STENCIL, options.pixelDatatype must be UNSIGNED_INT_24_8.");if(h===m.A.FLOAT&&!t.floatingPointTexture)throw new l.A("When options.pixelDatatype is FLOAT, this WebGL implementation must support the OES_texture_float extension.  Check context.floatingPointTexture.");if(h===m.A.HALF_FLOAT&&!t.halfFloatingPointTexture)throw new l.A("When options.pixelDatatype is HALF_FLOAT, this WebGL implementation must support the OES_texture_half_float extension. Check context.halfFloatingPointTexture.");if(u.A.isDepthFormat(c)){if((0,s.A)(n))throw new l.A("When options.pixelFormat is DEPTH_COMPONENT or DEPTH_STENCIL, source cannot be provided.");if(!t.depthTexture)throw new l.A("When options.pixelFormat is DEPTH_COMPONENT or DEPTH_STENCIL, this WebGL implementation must support WEBGL_depth_texture.  Check context.depthTexture.")}if(S){if(!(0,s.A)(n)||!(0,s.A)(n.arrayBufferView))throw new l.A("When options.pixelFormat is compressed, options.source.arrayBufferView must be defined.");if(u.A.isDXTFormat(E)&&!t.s3tc)throw new l.A("When options.pixelFormat is S3TC compressed, this WebGL implementation must support the WEBGL_compressed_texture_s3tc extension. Check context.s3tc.");if(u.A.isPVRTCFormat(E)&&!t.pvrtc)throw new l.A("When options.pixelFormat is PVRTC compressed, this WebGL implementation must support the WEBGL_compressed_texture_pvrtc extension. Check context.pvrtc.");if(u.A.isASTCFormat(E)&&!t.astc)throw new l.A("When options.pixelFormat is ASTC compressed, this WebGL implementation must support the WEBGL_compressed_texture_astc extension. Check context.astc.");if(u.A.isETC2Format(E)&&!t.etc)throw new l.A("When options.pixelFormat is ETC2 compressed, this WebGL implementation must support the WEBGL_compressed_texture_etc extension. Check context.etc.");if(u.A.isETC1Format(E)&&!t.etc1)throw new l.A("When options.pixelFormat is ETC1 compressed, this WebGL implementation must support the WEBGL_compressed_texture_etc1 extension. Check context.etc1.");if(u.A.isBC7Format(E)&&!t.bc7)throw new l.A("When options.pixelFormat is BC7 compressed, this WebGL implementation must support the EXT_texture_compression_bptc extension. Check context.bc7.");if(u.A.compressedTextureSizeInBytes(E,g,x)!==n.arrayBufferView.byteLength)throw new l.A("The byte length of the array buffer is invalid for the compressed texture with the given width and height.")}const D=t._gl,O=S?u.A.compressedTextureSizeInBytes(c,g,x):u.A.textureSizeInBytes(c,h,g,x);this._id=e.id??(0,r.A)(),this._context=t,this._textureFilterAnisotropic=t._textureFilterAnisotropic,this._textureTarget=D.TEXTURE_2D,this._texture=D.createTexture(),this._internalFormat=E,this._pixelFormat=c,this._pixelDatatype=h,this._width=g,this._height=x,this._dimensions=new i.A(g,x),this._hasMipmap=!1,this._sizeInBytes=O,this._preMultiplyAlpha=C,this._flipY=p,this._initialized=!1,this._sampler=void 0,this._sampler=_,T(this,_),D.activeTexture(D.TEXTURE0),D.bindTexture(this._textureTarget,this._texture),(0,s.A)(n)?(A?D.pixelStorei(D.UNPACK_COLORSPACE_CONVERSION_WEBGL,D.NONE):D.pixelStorei(D.UNPACK_COLORSPACE_CONVERSION_WEBGL,D.BROWSER_DEFAULT_WEBGL),(0,s.A)(n.arrayBufferView)?u.A.isCompressedFormat(E)?function(e,t){const n=e._context._gl,i=e._textureTarget,o=e._internalFormat,{width:r,height:a}=e;if(n.pixelStorei(n.UNPACK_ALIGNMENT,4),n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,!1),n.compressedTexImage2D(i,0,o,r,a,0,t.arrayBufferView),(0,s.A)(t.mipLevels)){let e=r,s=a;for(let r=0;r<t.mipLevels.length;++r)e=b(e),s=b(s),n.compressedTexImage2D(i,r+1,o,e,s,0,t.mipLevels[r])}}(this,n):y(this,n):(0,s.A)(n.framebuffer)?function(e,t){const n=e._context,i=n._gl;i.pixelStorei(i.UNPACK_ALIGNMENT,4),i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL,!1),t.framebuffer!==n.defaultFramebuffer&&t.framebuffer._bind(),i.copyTexImage2D(e._textureTarget,0,e._internalFormat,t.xOffset,t.yOffset,e.width,e.height,0),t.framebuffer!==n.defaultFramebuffer&&t.framebuffer._unBind()}(this,n):v(this,n),this._initialized=!0):w(this),D.bindTexture(this._textureTarget,null)}function y(e,t){const n=e._context,i=n._gl,o=e._textureTarget,r=e._internalFormat,{width:a,height:c,pixelFormat:l,pixelDatatype:h,flipY:d}=e,p=u.A.alignmentInBytes(l,h,a);i.pixelStorei(i.UNPACK_ALIGNMENT,p),i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL,!1);let{arrayBufferView:f}=t;if(d&&(f=u.A.flipY(f,l,h,a,c)),i.texImage2D(o,0,r,a,c,0,l,m.A.toWebGLConstant(h,n),f),(0,s.A)(t.mipLevels)){let e=a,s=c;for(let a=0;a<t.mipLevels.length;++a)e=b(e),s=b(s),i.texImage2D(o,a+1,r,e,s,0,l,m.A.toWebGLConstant(h,n),t.mipLevels[a])}}function v(e,t){const n=e._context,i=n._gl;i.pixelStorei(i.UNPACK_ALIGNMENT,4),i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL,e.preMultiplyAlpha),i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL,e.flipY),i.texImage2D(e._textureTarget,0,e._internalFormat,e.pixelFormat,m.A.toWebGLConstant(e.pixelDatatype,n),t)}function b(e){const t=0|Math.floor(e/2);return Math.max(t,1)}function w(e){const t=e._context;t._gl.texImage2D(e._textureTarget,0,e._internalFormat,e._width,e._height,0,e._pixelFormat,m.A.toWebGLConstant(e._pixelDatatype,t),null)}function T(e,t){let{minificationFilter:n,magnificationFilter:i}=t;const o=[_.A.NEAREST_MIPMAP_NEAREST,_.A.NEAREST_MIPMAP_LINEAR,_.A.LINEAR_MIPMAP_NEAREST,_.A.LINEAR_MIPMAP_LINEAR].includes(n),r=e._context,a=e._pixelFormat,c=e._pixelDatatype;(c===m.A.FLOAT&&!r.textureFloatLinear||c===m.A.HALF_FLOAT&&!r.textureHalfFloatLinear)&&(n=o?_.A.NEAREST_MIPMAP_NEAREST:_.A.NEAREST,i=A.A.NEAREST),r.webgl2&&u.A.isDepthFormat(a)&&(n=_.A.NEAREST,i=A.A.NEAREST);const l=r._gl,h=e._textureTarget;l.activeTexture(l.TEXTURE0),l.bindTexture(h,e._texture),l.texParameteri(h,l.TEXTURE_MIN_FILTER,n),l.texParameteri(h,l.TEXTURE_MAG_FILTER,i),l.texParameteri(h,l.TEXTURE_WRAP_S,t.wrapS),l.texParameteri(h,l.TEXTURE_WRAP_T,t.wrapT),(0,s.A)(e._textureFilterAnisotropic)&&l.texParameteri(h,e._textureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT,t.maximumAnisotropy),l.bindTexture(h,null)}g.create=function(e){return new g(e)},g.fromFramebuffer=function(e){e=e??a.A.EMPTY_OBJECT,o.A.defined("options.context",e.context);const t=e.context,{pixelFormat:n=u.A.RGB,framebufferXOffset:i=0,framebufferYOffset:r=0,width:c=t.drawingBufferWidth,height:h=t.drawingBufferHeight,framebuffer:d}=e;if(!u.A.validate(n))throw new l.A("Invalid pixelFormat.");if(u.A.isDepthFormat(n)||u.A.isCompressedFormat(n))throw new l.A("pixelFormat cannot be DEPTH_COMPONENT, DEPTH_STENCIL or a compressed format.");if(o.A.defined("options.context",t),o.A.typeOf.number.greaterThanOrEquals("framebufferXOffset",i,0),o.A.typeOf.number.greaterThanOrEquals("framebufferYOffset",r,0),i+c>t.drawingBufferWidth)throw new l.A("framebufferXOffset + width must be less than or equal to drawingBufferWidth");if(r+h>t.drawingBufferHeight)throw new l.A("framebufferYOffset + height must be less than or equal to drawingBufferHeight.");return new g({context:t,width:c,height:h,pixelFormat:n,source:{framebuffer:(0,s.A)(d)?d:t.defaultFramebuffer,xOffset:i,yOffset:r,width:c,height:h}})},Object.defineProperties(g.prototype,{id:{get:function(){return this._id}},sampler:{get:function(){return this._sampler},set:function(e){T(this,e),this._sampler=e}},pixelFormat:{get:function(){return this._pixelFormat}},pixelDatatype:{get:function(){return this._pixelDatatype}},dimensions:{get:function(){return this._dimensions}},preMultiplyAlpha:{get:function(){return this._preMultiplyAlpha}},flipY:{get:function(){return this._flipY}},width:{get:function(){return this._width}},height:{get:function(){return this._height}},sizeInBytes:{get:function(){return this._hasMipmap?Math.floor(4*this._sizeInBytes/3):this._sizeInBytes}},_target:{get:function(){return this._textureTarget}}}),g.prototype.copyFrom=function(e){o.A.defined("options",e);const{xOffset:t=0,yOffset:n=0,source:i,skipColorSpaceConversion:r=!1}=e;if(o.A.defined("options.source",i),u.A.isDepthFormat(this._pixelFormat))throw new l.A("Cannot call copyFrom when the texture pixel format is DEPTH_COMPONENT or DEPTH_STENCIL.");if(u.A.isCompressedFormat(this._pixelFormat))throw new l.A("Cannot call copyFrom with a compressed texture pixel format.");o.A.typeOf.number.greaterThanOrEquals("xOffset",t,0),o.A.typeOf.number.greaterThanOrEquals("yOffset",n,0),o.A.typeOf.number.lessThanOrEquals("xOffset + options.source.width",t+i.width,this._width),o.A.typeOf.number.lessThanOrEquals("yOffset + options.source.height",n+i.height,this._height);const a=this._context._gl,c=this._textureTarget;a.activeTexture(a.TEXTURE0),a.bindTexture(c,this._texture);let{width:h,height:d}=i;(0,s.A)(i.videoWidth)&&(0,s.A)(i.videoHeight)?(h=i.videoWidth,d=i.videoHeight):(0,s.A)(i.naturalWidth)&&(0,s.A)(i.naturalHeight)&&(h=i.naturalWidth,d=i.naturalHeight),r?a.pixelStorei(a.UNPACK_COLORSPACE_CONVERSION_WEBGL,a.NONE):a.pixelStorei(a.UNPACK_COLORSPACE_CONVERSION_WEBGL,a.BROWSER_DEFAULT_WEBGL);let p=!1;this._initialized||(0===t&&0===n&&h===this._width&&d===this._height?((0,s.A)(i.arrayBufferView)?y(this,i):v(this,i),p=!0):(a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL,!1),w(this)),this._initialized=!0),p||((0,s.A)(i.arrayBufferView)?function(e,t,n,i,o,r){const a=e._context,s=a._gl,{pixelFormat:c,pixelDatatype:l}=e,h=u.A.alignmentInBytes(c,l,o);s.pixelStorei(s.UNPACK_ALIGNMENT,h),s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL,!1),e.flipY&&(t=u.A.flipY(t,c,l,o,r)),s.texSubImage2D(e._textureTarget,0,n,i,o,r,c,m.A.toWebGLConstant(l,a),t)}(this,i.arrayBufferView,t,n,h,d):function(e,t,n,i){const o=e._context,r=o._gl;r.pixelStorei(r.UNPACK_ALIGNMENT,4),r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL,e.preMultiplyAlpha),r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL,e.flipY),r.texSubImage2D(e._textureTarget,0,n,i,e.pixelFormat,m.A.toWebGLConstant(e.pixelDatatype,o),t)}(this,i,t,n)),a.bindTexture(c,null)},g.prototype.copyFromFramebuffer=function(e,t,n,i,r,a){if(e=e??0,t=t??0,n=n??0,i=i??0,r=r??this._width,a=a??this._height,u.A.isDepthFormat(this._pixelFormat))throw new l.A("Cannot call copyFromFramebuffer when the texture pixel format is DEPTH_COMPONENT or DEPTH_STENCIL.");if(this._pixelDatatype===m.A.FLOAT)throw new l.A("Cannot call copyFromFramebuffer when the texture pixel data type is FLOAT.");if(this._pixelDatatype===m.A.HALF_FLOAT)throw new l.A("Cannot call copyFromFramebuffer when the texture pixel data type is HALF_FLOAT.");if(u.A.isCompressedFormat(this._pixelFormat))throw new l.A("Cannot call copyFrom with a compressed texture pixel format.");o.A.typeOf.number.greaterThanOrEquals("xOffset",e,0),o.A.typeOf.number.greaterThanOrEquals("yOffset",t,0),o.A.typeOf.number.greaterThanOrEquals("framebufferXOffset",n,0),o.A.typeOf.number.greaterThanOrEquals("framebufferYOffset",i,0),o.A.typeOf.number.lessThanOrEquals("xOffset + width",e+r,this._width),o.A.typeOf.number.lessThanOrEquals("yOffset + height",t+a,this._height);const s=this._context._gl,c=this._textureTarget;s.activeTexture(s.TEXTURE0),s.bindTexture(c,this._texture),s.copyTexSubImage2D(c,0,e,t,n,i,r,a),s.bindTexture(c,null),this._initialized=!0},g.prototype.generateMipmap=function(e){if(e=e??p.A.DONT_CARE,u.A.isDepthFormat(this._pixelFormat))throw new l.A("Cannot call generateMipmap when the texture pixel format is DEPTH_COMPONENT or DEPTH_STENCIL.");if(u.A.isCompressedFormat(this._pixelFormat))throw new l.A("Cannot call generateMipmap with a compressed pixel format.");if(!this._context.webgl2){if(this._width>1&&!h.A.isPowerOfTwo(this._width))throw new l.A("width must be a power of two to call generateMipmap() in a WebGL1 context.");if(this._height>1&&!h.A.isPowerOfTwo(this._height))throw new l.A("height must be a power of two to call generateMipmap() in a WebGL1 context.")}if(!p.A.validate(e))throw new l.A("hint is invalid.");this._hasMipmap=!0;const t=this._context._gl,n=this._textureTarget;t.hint(t.GENERATE_MIPMAP_HINT,e),t.activeTexture(t.TEXTURE0),t.bindTexture(n,this._texture),t.generateMipmap(n),t.bindTexture(n,null)},g.prototype.isDestroyed=function(){return!1},g.prototype.destroy=function(){return this._context._gl.deleteTexture(this._texture),(0,c.A)(this)};const x=g},66589:(e,t,n)=>{"use strict";n.d(t,{A:()=>y});var i=n(647934),o=n(434067),r=n(369031),a=n(673874),s=n(915325),c=n(491446),l=n(677354),h=n(367817),u=n(276904),d=n(744603),p=n(123245),m=n(878626),f=n(483128),A=n(616e3);function _(e){const t=(e=e??s.A.EMPTY_OBJECT).borderWidthInPixels??1,n=e.initialSize??new o.A(16,16);r.A.typeOf.number.greaterThanOrEquals("options.borderWidthInPixels",t,0),r.A.typeOf.number.greaterThan("options.initialSize.x",n.x,0),r.A.typeOf.number.greaterThan("options.initialSize.y",n.y,0),this._pixelFormat=e.pixelFormat??u.A.RGBA,this._sampler=e.sampler,this._borderWidthInPixels=t,this._initialSize=n,this._texturePacker=void 0,this._rectangles=[],this._subRegions=new Map,this._guid=(0,a.A)(),this._imagesToAddQueue=[],this._indexById=new Map,this._indexPromiseById=new Map,this._nextIndex=0}function g({index:e,image:t,resolve:n,reject:i}){this.index=e,this.image=t,this.resolve=n,this.reject=i,this.rectangle=void 0}Object.defineProperties(_.prototype,{borderWidthInPixels:{get:function(){return this._borderWidthInPixels}},rectangles:{get:function(){return this._rectangles}},texture:{get:function(){return this._texture}},pixelFormat:{get:function(){return this._pixelFormat}},sampler:{get:function(){return this._sampler}},numberOfImages:{get:function(){return this._nextIndex}},guid:{get:function(){return this._guid}},sizeInBytes:{get:function(){return(0,c.A)(this._texture)?this._texture.sizeInBytes:0}}}),_.prototype.computeTextureCoordinates=function(e,t){r.A.typeOf.number.greaterThanOrEquals("index",e,0);const n=this._texture,o=this._rectangles[e];if((0,c.A)(t)||(t=new i.A),!(0,c.A)(o))return t.x=0,t.y=0,t.width=0,t.height=0,t;const a=n.width,s=n.height,l=o.width,h=o.height;let u=o.x,d=o.y;const p=this._subRegions.get(e);if((0,c.A)(p)){const e=this._rectangles[p];u+=e.x,d+=e.y}return t.x=u/a,t.y=d/s,t.width=l/a,t.height=h/s,t},_.prototype._copyFromTexture=function(e,t,n,i){const o=this._pixelFormat,r=this._sampler,a=new A.A({context:e,height:n,width:t,pixelFormat:o,sampler:r}),s=e._gl,l=a._textureTarget,h=this._texture,u=new f.A({context:e,colorTextures:[h],destroyAttachments:!1});s.activeTexture(s.TEXTURE0),s.bindTexture(l,a._texture),u._bind();const d=this.rectangles,p=this._subRegions;for(let e=0;e<d.length;++e){const t=i[e],n=d[e];if(!(0,c.A)(t)||!(0,c.A)(n)||(0,c.A)(p.get(e)))continue;const{x:o,y:r,width:a,height:h}=t;s.copyTexSubImage2D(l,0,o,r,n.x,n.y,a,h)}return s.bindTexture(l,null),a._initialized=!0,u._unBind(),u.destroy(),a},_.prototype._resize=function(e,t=0){const n=this._borderWidthInPixels,i=this._rectangles,o=this._imagesToAddQueue,r=this._texture;let s=r.width,l=r.height;const u=this._subRegions,d=i.map((e,t)=>new g({index:t,image:e})).filter((e,t)=>(0,c.A)(e.image)&&!(0,c.A)(u.get(t)));let p=0,f=0,A=0;for(let e=t;e<o.length;++e){const{width:t,height:n}=o[e].image;p=Math.max(p,t),f=Math.max(f,n),A+=t*n,d.push(o[e])}s=Math.max(p,s),l=Math.max(f,l),e.webgl2||(s=h.A.nextPowerOfTwo(s),l=h.A.nextPowerOfTwo(l));const _=A;let y=1;for(;_/s/l>=1;)y*=2,s>l?l*=y:s*=y;d.sort(({image:e},{image:t})=>t.height*t.width-e.height*e.width);const v=new Array(this._nextIndex);for(const e of this._subRegions.keys())(0,c.A)(u.get(e))&&(v[e]=i[e]);let b,w=!1;for(;!w;){let e;for(b=new m.A({height:l,width:s,borderPadding:n}),e=0;e<d.length;++e){const{index:t,image:n}=d[e];if(!(0,c.A)(n))continue;const i=b.pack(t,n);if(!(0,c.A)(i)){s>l?l*=2:s*=2;break}v[t]=i.rectangle}w=e===d.length}this._texturePacker=b,this._texture=this._copyFromTexture(e,s,l,v),r.destroy(),this._rectangles=v,this._guid=(0,a.A)()},_.prototype.getImageIndex=function(e){return r.A.typeOf.string("id",e),this._indexById.get(e)},_.prototype._copyImageToTexture=function({index:e,image:t,resolve:n,reject:i}){const o=this._texture,r=this._rectangles[e];try{o.copyFrom({source:t,xOffset:r.x,yOffset:r.y}),(0,c.A)(n)&&n(e)}catch(e){if((0,c.A)(i))return void i(e)}},_.prototype._addImage=function(e,t){return r.A.typeOf.number.greaterThanOrEquals("index",e,0),r.A.defined("image",t),new Promise((n,i)=>{this._imagesToAddQueue.push(new g({index:e,image:t,resolve:n,reject:i})),this._imagesToAddQueue.sort(({image:e},{image:t})=>t.height*t.width-e.height*e.width)})},_.prototype._processImageQueue=function(e){const t=this._imagesToAddQueue;if(0===t.length)return!1;let n,i;for(this._rectangles.length=this._nextIndex,n=0;n<t.length;++n){const o=t[n],{image:r,index:a}=o,s=this._texturePacker.pack(a,r);if(!(0,c.A)(s)){try{this._resize(e,n)}catch(e){i=e,(0,c.A)(o.reject)&&o.reject(i)}break}this._rectangles[a]=s.rectangle}if((0,c.A)(i)){for(n+=1;n<t.length;++n){const{resolve:e}=t[n];(0,c.A)(e)&&e(-1)}return t.length=0,!1}for(let e=0;e<t.length;++e)this._copyImageToTexture(t[e]);return t.length=0,!0},_.prototype.update=function(e){if(!(0,c.A)(this._texture)){const t=this._initialSize.x,n=this._initialSize.y,i=this._pixelFormat,o=this._sampler,r=this._borderWidthInPixels;this._texture=new A.A({context:e,width:t,height:n,pixelFormat:i,sampler:o}),this._texturePacker=new m.A({height:n,width:t,borderPadding:r})}return this._processImageQueue(e)},_.prototype.addImage=function(e,t){r.A.typeOf.string("id",e),r.A.defined("image",t);let n=this._indexPromiseById.get(e);if((0,c.A)(n))return n;const i=this._nextIndex++;return this._indexById.set(e,i),n=(async()=>(t=await async function(e,t){return"function"==typeof e&&(e=e(t)),("string"==typeof e||e instanceof d.A)&&(e=d.A.createIfNeeded(e).fetchImage()),e}(t,e),r.A.defined("image",t),this.isDestroyed()||!(0,c.A)(t)?-1:this._addImage(i,t)))(),this._indexPromiseById.set(e,n),n},_.prototype.addImageSubRegion=function(e,t){r.A.typeOf.string("id",e),r.A.defined("subRegion",t);const n=this._indexById.get(e);if(!(0,c.A)(n))throw new p.A(`image with id "${e}" not found in the atlas.`);const i=this._indexPromiseById.get(e);for(const[e,o]of this._subRegions.entries())if(n===o&&this._rectangles[e].equals(t))return i.then(t=>-1===t?-1:e);const o=this._nextIndex++;return this._subRegions.set(o,n),this._rectangles[o]=t.clone(),i.then(e=>{if(-1===e)return-1;const n=this._rectangles[e];return r.A.typeOf.number.lessThanOrEquals("subRegion.x",t.x,n.width),r.A.typeOf.number.lessThanOrEquals("subRegion.x + subRegion.width",t.x+t.width,n.width),r.A.typeOf.number.lessThanOrEquals("subRegion.y",t.y,n.height),r.A.typeOf.number.lessThanOrEquals("subRegion.y + subRegion.height",t.y+t.height,n.height),o})},_.prototype.isDestroyed=function(){return!1},_.prototype.destroy=function(){return this._texture=this._texture&&this._texture.destroy(),this._imagesToAddQueue.forEach(({resolve:e})=>{(0,c.A)(e)&&e(-1)}),(0,l.A)(this)};const y=_},957233:(e,t,n)=>{"use strict";n.d(t,{A:()=>r});var i=n(352581);const o={NEAREST:i.A.NEAREST,LINEAR:i.A.LINEAR,validate:function(e){return e===o.NEAREST||e===o.LINEAR}},r=Object.freeze(o)},78078:(e,t,n)=>{"use strict";n.d(t,{A:()=>r});var i=n(352581);const o={NEAREST:i.A.NEAREST,LINEAR:i.A.LINEAR,NEAREST_MIPMAP_NEAREST:i.A.NEAREST_MIPMAP_NEAREST,LINEAR_MIPMAP_NEAREST:i.A.LINEAR_MIPMAP_NEAREST,NEAREST_MIPMAP_LINEAR:i.A.NEAREST_MIPMAP_LINEAR,LINEAR_MIPMAP_LINEAR:i.A.LINEAR_MIPMAP_LINEAR,validate:function(e){return e===o.NEAREST||e===o.LINEAR||e===o.NEAREST_MIPMAP_NEAREST||e===o.LINEAR_MIPMAP_NEAREST||e===o.NEAREST_MIPMAP_LINEAR||e===o.LINEAR_MIPMAP_LINEAR}},r=Object.freeze(o)},557448:(e,t,n)=>{"use strict";n.d(t,{A:()=>r});var i=n(352581);const o={CLAMP_TO_EDGE:i.A.CLAMP_TO_EDGE,REPEAT:i.A.REPEAT,MIRRORED_REPEAT:i.A.MIRRORED_REPEAT,validate:function(e){return e===o.CLAMP_TO_EDGE||e===o.REPEAT||e===o.MIRRORED_REPEAT}},r=Object.freeze(o)},508380:(e,t,n)=>{"use strict";n.d(t,{A:()=>w});var i=n(369031),o=n(571804),r=n(915325),a=n(491446),s=n(677354),c=n(605971),l=n(944479),h=n(874915),u=n(367817),d=n(123245),p=n(641613),m=n(442790),f=n(430332),A=n(730839);function _(e,t,n,i){const r=(0,a.A)(t.vertexBuffer),s=(0,a.A)(t.value),l=t.value?t.value.length:t.componentsPerAttribute;if(!r&&!s)throw new c.A("attribute must have a vertexBuffer or a value.");if(r&&s)throw new c.A("attribute cannot have both a vertexBuffer and a value.  It must have either a vertexBuffer property defining per-vertex data or a value property defining data for all vertices.");if(1!==l&&2!==l&&3!==l&&4!==l){if(s)throw new c.A("attribute.value.length must be in the range [1, 4].");throw new c.A("attribute.componentsPerAttribute must be in the range [1, 4].")}if((0,a.A)(t.componentDatatype)&&!o.A.validate(t.componentDatatype))throw new c.A("attribute must have a valid componentDatatype or not specify it.");if((0,a.A)(t.strideInBytes)&&t.strideInBytes>255)throw new c.A("attribute must have a strideInBytes less than or equal to 255 or not specify it.");if((0,a.A)(t.instanceDivisor)&&t.instanceDivisor>0&&!i.instancedArrays)throw new c.A("instanced arrays is not supported");if((0,a.A)(t.instanceDivisor)&&t.instanceDivisor<0)throw new c.A("attribute must have an instanceDivisor greater than or equal to zero");if((0,a.A)(t.instanceDivisor)&&s)throw new c.A("attribute cannot have have an instanceDivisor if it is not backed by a buffer");if((0,a.A)(t.instanceDivisor)&&t.instanceDivisor>0&&0===t.index)throw new c.A("attribute zero cannot have an instanceDivisor greater than 0");const h={index:t.index??n,enabled:t.enabled??!0,vertexBuffer:t.vertexBuffer,value:s?t.value.slice(0):void 0,componentsPerAttribute:l,componentDatatype:t.componentDatatype??o.A.FLOAT,normalize:t.normalize??!1,offsetInBytes:t.offsetInBytes??0,strideInBytes:t.strideInBytes??0,instanceDivisor:t.instanceDivisor??0};if(r)h.vertexAttrib=function(e){const t=this.index;e.bindBuffer(e.ARRAY_BUFFER,this.vertexBuffer._getBuffer()),e.vertexAttribPointer(t,this.componentsPerAttribute,this.componentDatatype,this.normalize,this.strideInBytes,this.offsetInBytes),e.enableVertexAttribArray(t),this.instanceDivisor>0&&(i.glVertexAttribDivisor(t,this.instanceDivisor),i._vertexAttribDivisors[t]=this.instanceDivisor,i._previousDrawInstanced=!0)},h.disableVertexAttribArray=function(e){e.disableVertexAttribArray(this.index),this.instanceDivisor>0&&i.glVertexAttribDivisor(n,0)};else{switch(h.componentsPerAttribute){case 1:h.vertexAttrib=function(e){e.vertexAttrib1fv(this.index,this.value)};break;case 2:h.vertexAttrib=function(e){e.vertexAttrib2fv(this.index,this.value)};break;case 3:h.vertexAttrib=function(e){e.vertexAttrib3fv(this.index,this.value)};break;case 4:h.vertexAttrib=function(e){e.vertexAttrib4fv(this.index,this.value)}}h.disableVertexAttribArray=function(e){}}e.push(h)}function g(e,t,n){for(let n=0;n<t.length;++n){const i=t[n];i.enabled&&i.vertexAttrib(e)}(0,a.A)(n)&&e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n._getBuffer())}function y(e){e=e??r.A.EMPTY_OBJECT,i.A.defined("options.context",e.context),i.A.defined("options.attributes",e.attributes);const t=e.context,n=t._gl,s=e.attributes,l=e.indexBuffer;let h;const u=[];let d=1,p=!1,m=!1,f=s.length;for(h=0;h<f;++h)_(u,s[h],h,t);for(f=u.length,h=0;h<f;++h){const e=u[h];if((0,a.A)(e.vertexBuffer)&&0===e.instanceDivisor){const t=e.strideInBytes||e.componentsPerAttribute*o.A.getSizeInBytes(e.componentDatatype);d=e.vertexBuffer.sizeInBytes/t;break}}for(h=0;h<f;++h)u[h].instanceDivisor>0&&(p=!0),(0,a.A)(u[h].value)&&(m=!0);const A={};for(h=0;h<f;++h){const e=u[h].index;if(A[e])throw new c.A(`Index ${e} is used by more than one attribute.`);A[e]=!0}let y;t.vertexArrayObject&&(y=t.glCreateVertexArray(),t.glBindVertexArray(y),g(n,u,l),t.glBindVertexArray(null)),this._numberOfVertices=d,this._hasInstancedAttributes=p,this._hasConstantAttributes=m,this._context=t,this._gl=n,this._vao=y,this._attributes=u,this._indexBuffer=l}function v(e){return e.values.length/e.componentsPerAttribute}function b(e){return o.A.getSizeInBytes(e.componentDatatype)*e.componentsPerAttribute}y.fromGeometry=function(e){e=e??r.A.EMPTY_OBJECT,i.A.defined("options.context",e.context);const t=e.context,n=e.geometry??r.A.EMPTY_OBJECT,s=e.bufferUsage??m.A.DYNAMIC_DRAW,c=e.attributeLocations??r.A.EMPTY_OBJECT,f=e.interleave??!1,_=e.vertexArrayAttributes;let g,w,T;const x=(0,a.A)(_)?_:[],C=n.attributes;if(f){const e=function(e){let t,n,i;const r=[];for(n in e)e.hasOwnProperty(n)&&(0,a.A)(e[n])&&(0,a.A)(e[n].values)&&(r.push(n),e[n].componentDatatype===o.A.DOUBLE&&(e[n].componentDatatype=o.A.FLOAT,e[n].values=o.A.createTypedArray(o.A.FLOAT,e[n].values)));let s;const c=r.length;if(c>0)for(s=v(e[r[0]]),t=1;t<c;++t){const n=v(e[r[t]]);if(n!==s)throw new d.A(`Each attribute list must have the same number of vertices.  Attribute ${r[t]} has a different number of vertices (${n.toString()}) than attribute ${r[0]} (${s.toString()}).`)}r.sort(function(t,n){return o.A.getSizeInBytes(e[n].componentDatatype)-o.A.getSizeInBytes(e[t].componentDatatype)});let l=0;const h={};for(t=0;t<c;++t)n=r[t],i=e[n],h[n]=l,l+=b(i);if(l>0){const a=o.A.getSizeInBytes(e[r[0]].componentDatatype),u=l%a;0!==u&&(l+=a-u);const d=new ArrayBuffer(s*l),p={};for(t=0;t<c;++t){n=r[t];const i=o.A.getSizeInBytes(e[n].componentDatatype);p[n]={pointer:o.A.createTypedArray(e[n].componentDatatype,d),index:h[n]/i,strideInComponentType:l/i}}for(t=0;t<s;++t)for(let o=0;o<c;++o){n=r[o],i=e[n];const a=i.values,s=p[n],c=s.pointer,l=i.componentsPerAttribute;for(let e=0;e<l;++e)c[s.index+e]=a[t*l+e];s.index+=s.strideInComponentType}return{buffer:d,offsetsInBytes:h,vertexSizeInBytes:l}}}(C);if((0,a.A)(e)){T=p.A.createVertexBuffer({context:t,typedArray:e.buffer,usage:s});const n=e.offsetsInBytes,i=e.vertexSizeInBytes;for(g in C)C.hasOwnProperty(g)&&(0,a.A)(C[g])&&(w=C[g],(0,a.A)(w.values)?x.push({index:c[g],vertexBuffer:T,componentDatatype:w.componentDatatype,componentsPerAttribute:w.componentsPerAttribute,normalize:w.normalize,offsetInBytes:n[g],strideInBytes:i}):x.push({index:c[g],value:w.value,componentDatatype:w.componentDatatype,normalize:w.normalize}))}}else for(g in C)if(C.hasOwnProperty(g)&&(0,a.A)(C[g])){w=C[g];let e=w.componentDatatype;e===o.A.DOUBLE&&(e=o.A.FLOAT);let n={};T=void 0,(0,a.A)(w.values)&&(T=p.A.createVertexBuffer({context:t,typedArray:o.A.createTypedArray(e,w.values),usage:s}),n={index:c[g],vertexBuffer:T,value:w.value,componentDatatype:e,componentsPerAttribute:w.componentsPerAttribute,normalize:w.normalize}),(0,a.A)(w.typedArray)&&(T=p.A.createVertexBuffer({context:t,typedArray:w.typedArray,usage:s}),n={index:c[g],vertexBuffer:T,value:void 0,componentDatatype:e,componentsPerAttribute:A.A.getNumberOfComponents(w.type),normalize:w.normalized,instanceDivisor:w.instanceDivisor}),x.push(n)}let E;const S=n.indices;return(0,a.A)(S)&&(E=l.A.computeNumberOfVertices(n)>=u.A.SIXTY_FOUR_KILOBYTES&&t.elementIndexUint?p.A.createIndexBuffer({context:t,typedArray:new Uint32Array(S),usage:s,indexDatatype:h.A.UNSIGNED_INT}):p.A.createIndexBuffer({context:t,typedArray:new Uint16Array(S),usage:s,indexDatatype:h.A.UNSIGNED_SHORT})),new y({context:t,attributes:x,indexBuffer:E})},Object.defineProperties(y.prototype,{numberOfAttributes:{get:function(){return this._attributes.length}},numberOfVertices:{get:function(){return this._numberOfVertices}},indexBuffer:{get:function(){return this._indexBuffer}}}),y.prototype.getAttribute=function(e){return i.A.defined("index",e),this._attributes[e]},y.prototype._bind=function(){(0,a.A)(this._vao)?(this._context.glBindVertexArray(this._vao),this._context.instancedArrays&&function(e){const t=e._context,n=e._hasInstancedAttributes;if(!n&&!t._previousDrawInstanced)return;t._previousDrawInstanced=n;const i=t._vertexAttribDivisors,o=e._attributes,r=f.A.maximumVertexAttributes;let a;if(n){const e=o.length;for(a=0;a<e;++a){const e=o[a];if(e.enabled){const n=e.instanceDivisor,o=e.index;n!==i[o]&&(t.glVertexAttribDivisor(o,n),i[o]=n)}}}else for(a=0;a<r;++a)i[a]>0&&(t.glVertexAttribDivisor(a,0),i[a]=0)}(this),this._hasConstantAttributes&&function(e,t){const n=e._attributes,i=n.length;for(let e=0;e<i;++e){const i=n[e];i.enabled&&(0,a.A)(i.value)&&i.vertexAttrib(t)}}(this,this._gl)):g(this._gl,this._attributes,this._indexBuffer)},y.prototype._unBind=function(){if((0,a.A)(this._vao))this._context.glBindVertexArray(null);else{const e=this._attributes,t=this._gl;for(let n=0;n<e.length;++n){const i=e[n];i.enabled&&i.disableVertexAttribArray(t)}this._indexBuffer&&t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)}},y.prototype.isDestroyed=function(){return!1},y.prototype.destroy=function(){const e=this._attributes;for(let t=0;t<e.length;++t){const n=e[t].vertexBuffer;(0,a.A)(n)&&!n.isDestroyed()&&n.vertexArrayDestroyable&&n.destroy()}const t=this._indexBuffer;return(0,a.A)(t)&&!t.isDestroyed()&&t.vertexArrayDestroyable&&t.destroy(),(0,a.A)(this._vao)&&this._context.glDeleteVertexArray(this._vao),(0,s.A)(this)};const w=y},193470:(e,t,n)=>{"use strict";n.d(t,{A:()=>_});var i=n(369031),o=n(571804),r=n(491446),a=n(677354),s=n(605971),c=n(367817),l=n(641613),h=n(442790),u=n(508380);function d(e,t,n,a){if(i.A.defined("context",e),!t||0===t.length)throw new s.A("At least one attribute is required.");const c=d._verifyAttributes(t);n=n??0;const l=[],h={};let u,p;const m=c.length;for(let e=0;e<m;++e){const t=c[e];t.vertexBuffer?l.push(t):(p=t.usage,u=h[p],(0,r.A)(u)||(u=h[p]=[]),u.push(t))}function f(e,t){return o.A.getSizeInBytes(t.componentDatatype)-o.A.getSizeInBytes(e.componentDatatype)}for(p in this._allBuffers=[],h)if(h.hasOwnProperty(p)){u=h[p],u.sort(f);const e=d._vertexSizeInBytes(u),t={vertexSizeInBytes:e,vertexBuffer:void 0,usage:u[0].usage,needsCommit:!1,arrayBuffer:void 0,arrayViews:d._createArrayViews(u,e)};this._allBuffers.push(t)}this._size=0,this._instanced=a??!1,this._precreated=l,this._context=e,this.writers=void 0,this.va=void 0,this.resize(n)}d._verifyAttributes=function(e){const t=[];for(let n=0;n<e.length;++n){const i=e[n],r={index:i.index??n,enabled:i.enabled??!0,componentsPerAttribute:i.componentsPerAttribute,componentDatatype:i.componentDatatype??o.A.FLOAT,normalize:i.normalize??!1,vertexBuffer:i.vertexBuffer,usage:i.usage??h.A.STATIC_DRAW};if(t.push(r),1!==r.componentsPerAttribute&&2!==r.componentsPerAttribute&&3!==r.componentsPerAttribute&&4!==r.componentsPerAttribute)throw new s.A("attribute.componentsPerAttribute must be in the range [1, 4].");const a=r.componentDatatype;if(!o.A.validate(a))throw new s.A("Attribute must have a valid componentDatatype or not specify it.");if(!h.A.validate(r.usage))throw new s.A("Attribute must have a valid usage or not specify it.")}const n=new Array(t.length);for(let e=0;e<t.length;++e){const i=t[e].index;if(n[i])throw new s.A(`Index ${i} is used by more than one attribute.`);n[i]=!0}return t},d._vertexSizeInBytes=function(e){let t=0;const n=e.length;for(let i=0;i<n;++i){const n=e[i];t+=n.componentsPerAttribute*o.A.getSizeInBytes(n.componentDatatype)}const i=n>0?o.A.getSizeInBytes(e[0].componentDatatype):0,r=i>0?t%i:0;return t+=0===r?0:i-r,t},d._createArrayViews=function(e,t){const n=[];let i=0;const r=e.length;for(let a=0;a<r;++a){const r=e[a],s=r.componentDatatype;n.push({index:r.index,enabled:r.enabled,componentsPerAttribute:r.componentsPerAttribute,componentDatatype:s,normalize:r.normalize,offsetInBytes:i,vertexSizeInComponentType:t/o.A.getSizeInBytes(s),view:void 0}),i+=r.componentsPerAttribute*o.A.getSizeInBytes(s)}return n},d.prototype.resize=function(e){this._size=e;const t=this._allBuffers;this.writers=[];for(let e=0,n=t.length;e<n;++e){const n=t[e];d._resize(n,this._size),d._appendWriters(this.writers,n)}A(this)},d._resize=function(e,t){if(e.vertexSizeInBytes>0){const n=new ArrayBuffer(t*e.vertexSizeInBytes);if((0,r.A)(e.arrayBuffer)){const t=new Uint8Array(n),i=new Uint8Array(e.arrayBuffer),o=i.length;for(let e=0;e<o;++e)t[e]=i[e]}const i=e.arrayViews,a=i.length;for(let e=0;e<a;++e){const t=i[e];t.view=o.A.createArrayBufferView(t.componentDatatype,n,t.offsetInBytes)}e.arrayBuffer=n}};const p=[function(e,t,n){return function(i,o){t[i*n]=o,e.needsCommit=!0}},function(e,t,n){return function(i,o,r){const a=i*n;t[a]=o,t[a+1]=r,e.needsCommit=!0}},function(e,t,n){return function(i,o,r,a){const s=i*n;t[s]=o,t[s+1]=r,t[s+2]=a,e.needsCommit=!0}},function(e,t,n){return function(i,o,r,a,s){const c=i*n;t[c]=o,t[c+1]=r,t[c+2]=a,t[c+3]=s,e.needsCommit=!0}}];function m(e,t){if(t.needsCommit&&t.vertexSizeInBytes>0){t.needsCommit=!1;const n=t.vertexBuffer,i=e._size*t.vertexSizeInBytes,o=(0,r.A)(n);if(!o||n.sizeInBytes<i)return o&&n.destroy(),t.vertexBuffer=l.A.createVertexBuffer({context:e._context,typedArray:t.arrayBuffer,usage:t.usage}),t.vertexBuffer.vertexArrayDestroyable=!1,!0;t.vertexBuffer.copyFromArrayView(t.arrayBuffer)}return!1}function f(e,t,n){if(e.needsCommit&&e.vertexSizeInBytes>0){const i=e.vertexSizeInBytes*t,o=e.vertexSizeInBytes*n;e.vertexBuffer.copyFromArrayView(new Uint8Array(e.arrayBuffer,i,o),i)}}function A(e){const t=e.va;if(!(0,r.A)(t))return;const n=t.length;for(let e=0;e<n;++e)t[e].va.destroy();e.va=void 0}d._appendWriters=function(e,t){const n=t.arrayViews,i=n.length;for(let o=0;o<i;++o){const i=n[o];e[i.index]=p[i.componentsPerAttribute-1](t,i.view,i.vertexSizeInComponentType)}},d.prototype.commit=function(e){let t=!1;const n=this._allBuffers;let i,o,a;for(o=0,a=n.length;o<a;++o)i=n[o],t=m(this,i)||t;if(t||!(0,r.A)(this.va)){A(this);const t=this.va=[],s=c.A.SIXTY_FOUR_KILOBYTES-4,l=(0,r.A)(e)&&!this._instanced?Math.ceil(this._size/s):1;for(let r=0;r<l;++r){let c=[];for(o=0,a=n.length;o<a;++o){i=n[o];const e=r*(i.vertexSizeInBytes*s);d._appendAttributes(c,i,e,this._instanced)}c=c.concat(this._precreated),t.push({va:new u.A({context:this._context,attributes:c,indexBuffer:e}),indicesCount:1.5*(r!==l-1?s:this._size%s)})}}},d._appendAttributes=function(e,t,n,i){const o=t.arrayViews,r=o.length;for(let a=0;a<r;++a){const r=o[a];e.push({index:r.index,enabled:r.enabled,componentsPerAttribute:r.componentsPerAttribute,componentDatatype:r.componentDatatype,normalize:r.normalize,vertexBuffer:t.vertexBuffer,offsetInBytes:n+r.offsetInBytes,strideInBytes:t.vertexSizeInBytes,instanceDivisor:i?1:0})}},d.prototype.subCommit=function(e,t){if(e<0||e>=this._size)throw new s.A("offsetInVertices must be greater than or equal to zero and less than the vertex array size.");if(e+t>this._size)throw new s.A("offsetInVertices + lengthInVertices cannot exceed the vertex array size.");const n=this._allBuffers;for(let i=0,o=n.length;i<o;++i)f(n[i],e,t)},d.prototype.endSubCommits=function(){const e=this._allBuffers;for(let t=0,n=e.length;t<n;++t)e[t].needsCommit=!1},d.prototype.isDestroyed=function(){return!1},d.prototype.destroy=function(){const e=this._allBuffers;for(let t=0,n=e.length;t<n;++t){const n=e[t];n.vertexBuffer=n.vertexBuffer&&n.vertexBuffer.destroy()}return A(this),(0,a.A)(this)};const _=d},764011:(e,t,n)=>{"use strict";n.d(t,{A:()=>D});var i=n(434067),o=n(267980),r=n(626809),a=n(41476),s=n(491446),c=n(605971),l=n(463298),h=n(331185),u=n(584164),d=n(123245);function p(e,t,n,i){this.name=n,this.value=void 0,this._value=0,this._gl=e,this._location=i}function m(e,t,n,o){this.name=n,this.value=void 0,this._value=new i.A,this._gl=e,this._location=o}function f(e,t,n,i){this.name=n,this.value=void 0,this._value=void 0,this._gl=e,this._location=i}function A(e,t,n,i){this.name=n,this.value=void 0,this._value=void 0,this._gl=e,this._location=i}function _(e,t,n,i){this.name=n,this.value=void 0,this._gl=e,this._location=i,this.textureUnitIndex=void 0}function g(e,t,n,i){this.name=n,this.value=void 0,this._value=0,this._gl=e,this._location=i}function y(e,t,n,o){this.name=n,this.value=void 0,this._value=new i.A,this._gl=e,this._location=o}function v(e,t,n,i){this.name=n,this.value=void 0,this._value=new o.A,this._gl=e,this._location=i}function b(e,t,n,i){this.name=n,this.value=void 0,this._value=new r.A,this._gl=e,this._location=i}p.prototype.set=function(){this.value!==this._value&&(this._value=this.value,this._gl.uniform1f(this._location,this.value))},m.prototype.set=function(){const e=this.value;i.A.equals(e,this._value)||(i.A.clone(e,this._value),this._gl.uniform2f(this._location,e.x,e.y))},f.prototype.set=function(){const e=this.value;if((0,s.A)(e.red))a.A.equals(e,this._value)||(this._value=a.A.clone(e,this._value),this._gl.uniform3f(this._location,e.red,e.green,e.blue));else{if(!(0,s.A)(e.x))throw new c.A(`Invalid vec3 value for uniform "${this.name}".`);o.A.equals(e,this._value)||(this._value=o.A.clone(e,this._value),this._gl.uniform3f(this._location,e.x,e.y,e.z))}},A.prototype.set=function(){const e=this.value;if((0,s.A)(e.red))a.A.equals(e,this._value)||(this._value=a.A.clone(e,this._value),this._gl.uniform4f(this._location,e.red,e.green,e.blue,e.alpha));else{if(!(0,s.A)(e.x))throw new c.A(`Invalid vec4 value for uniform "${this.name}".`);r.A.equals(e,this._value)||(this._value=r.A.clone(e,this._value),this._gl.uniform4f(this._location,e.x,e.y,e.z,e.w))}},_.prototype.set=function(){const e=this._gl;e.activeTexture(e.TEXTURE0+this.textureUnitIndex);const t=this.value;e.bindTexture(t._target,t._texture)},_.prototype._setSampler=function(e){return this.textureUnitIndex=e,this._gl.uniform1i(this._location,e),e+1},g.prototype.set=function(){this.value!==this._value&&(this._value=this.value,this._gl.uniform1i(this._location,this.value))},y.prototype.set=function(){const e=this.value;i.A.equals(e,this._value)||(i.A.clone(e,this._value),this._gl.uniform2i(this._location,e.x,e.y))},v.prototype.set=function(){const e=this.value;o.A.equals(e,this._value)||(o.A.clone(e,this._value),this._gl.uniform3i(this._location,e.x,e.y,e.z))},b.prototype.set=function(){const e=this.value;r.A.equals(e,this._value)||(r.A.clone(e,this._value),this._gl.uniform4i(this._location,e.x,e.y,e.z,e.w))};const w=new Float32Array(4);function T(e,t,n,i){this.name=n,this.value=void 0,this._value=new l.A,this._gl=e,this._location=i}T.prototype.set=function(){if(!l.A.equalsArray(this.value,this._value,0)){l.A.clone(this.value,this._value);const e=l.A.toArray(this.value,w);this._gl.uniformMatrix2fv(this._location,!1,e)}};const x=new Float32Array(9);function C(e,t,n,i){this.name=n,this.value=void 0,this._value=new h.A,this._gl=e,this._location=i}C.prototype.set=function(){if(!h.A.equalsArray(this.value,this._value,0)){h.A.clone(this.value,this._value);const e=h.A.toArray(this.value,x);this._gl.uniformMatrix3fv(this._location,!1,e)}};const E=new Float32Array(16);function S(e,t,n,i){this.name=n,this.value=void 0,this._value=new u.A,this._gl=e,this._location=i}S.prototype.set=function(){if(!u.A.equalsArray(this.value,this._value,0)){u.A.clone(this.value,this._value);const e=u.A.toArray(this.value,E);this._gl.uniformMatrix4fv(this._location,!1,e)}};const D=function(e,t,n,i){switch(t.type){case e.FLOAT:return new p(e,t,n,i);case e.FLOAT_VEC2:return new m(e,t,n,i);case e.FLOAT_VEC3:return new f(e,t,n,i);case e.FLOAT_VEC4:return new A(e,t,n,i);case e.SAMPLER_2D:case e.SAMPLER_3D:case e.SAMPLER_CUBE:case e.UNSIGNED_INT_SAMPLER_2D:return new _(e,t,n,i);case e.INT:case e.BOOL:return new g(e,t,n,i);case e.INT_VEC2:case e.BOOL_VEC2:return new y(e,t,n,i);case e.INT_VEC3:case e.BOOL_VEC3:return new v(e,t,n,i);case e.INT_VEC4:case e.BOOL_VEC4:return new b(e,t,n,i);case e.FLOAT_MAT2:return new T(e,t,n,i);case e.FLOAT_MAT3:return new C(e,t,n,i);case e.FLOAT_MAT4:return new S(e,t,n,i);default:throw new d.A(`Unrecognized uniform type: ${t.type} for uniform "${n}".`)}}},757146:(e,t,n)=>{"use strict";n.d(t,{A:()=>C});var i=n(434067),o=n(267980),r=n(626809),a=n(41476),s=n(491446),c=n(605971),l=n(463298),h=n(331185),u=n(584164),d=n(123245);function p(e,t,n,i){const o=i.length;this.name=n,this.value=new Array(o),this._value=new Float32Array(o),this._gl=e,this._location=i[0]}function m(e,t,n,i){const o=i.length;this.name=n,this.value=new Array(o),this._value=new Float32Array(2*o),this._gl=e,this._location=i[0]}function f(e,t,n,i){const o=i.length;this.name=n,this.value=new Array(o),this._value=new Float32Array(3*o),this._gl=e,this._location=i[0]}function A(e,t,n,i){const o=i.length;this.name=n,this.value=new Array(o),this._value=new Float32Array(4*o),this._gl=e,this._location=i[0]}function _(e,t,n,i){const o=i.length;this.name=n,this.value=new Array(o),this._value=new Float32Array(o),this._gl=e,this._locations=i,this.textureUnitIndex=void 0}function g(e,t,n,i){const o=i.length;this.name=n,this.value=new Array(o),this._value=new Int32Array(o),this._gl=e,this._location=i[0]}function y(e,t,n,i){const o=i.length;this.name=n,this.value=new Array(o),this._value=new Int32Array(2*o),this._gl=e,this._location=i[0]}function v(e,t,n,i){const o=i.length;this.name=n,this.value=new Array(o),this._value=new Int32Array(3*o),this._gl=e,this._location=i[0]}function b(e,t,n,i){const o=i.length;this.name=n,this.value=new Array(o),this._value=new Int32Array(4*o),this._gl=e,this._location=i[0]}function w(e,t,n,i){const o=i.length;this.name=n,this.value=new Array(o),this._value=new Float32Array(4*o),this._gl=e,this._location=i[0]}function T(e,t,n,i){const o=i.length;this.name=n,this.value=new Array(o),this._value=new Float32Array(9*o),this._gl=e,this._location=i[0]}function x(e,t,n,i){const o=i.length;this.name=n,this.value=new Array(o),this._value=new Float32Array(16*o),this._gl=e,this._location=i[0]}p.prototype.set=function(){const e=this.value,t=e.length,n=this._value;let i=!1;for(let o=0;o<t;++o){const t=e[o];t!==n[o]&&(n[o]=t,i=!0)}i&&this._gl.uniform1fv(this._location,n)},m.prototype.set=function(){const e=this.value,t=e.length,n=this._value;let o=!1,r=0;for(let a=0;a<t;++a){const t=e[a];i.A.equalsArray(t,n,r)||(i.A.pack(t,n,r),o=!0),r+=2}o&&this._gl.uniform2fv(this._location,n)},f.prototype.set=function(){const e=this.value,t=e.length,n=this._value;let i=!1,r=0;for(let a=0;a<t;++a){const t=e[a];if((0,s.A)(t.red))t.red===n[r]&&t.green===n[r+1]&&t.blue===n[r+2]||(n[r]=t.red,n[r+1]=t.green,n[r+2]=t.blue,i=!0);else{if(!(0,s.A)(t.x))throw new c.A("Invalid vec3 value.");o.A.equalsArray(t,n,r)||(o.A.pack(t,n,r),i=!0)}r+=3}i&&this._gl.uniform3fv(this._location,n)},A.prototype.set=function(){const e=this.value,t=e.length,n=this._value;let i=!1,o=0;for(let l=0;l<t;++l){const t=e[l];if((0,s.A)(t.red))a.A.equalsArray(t,n,o)||(a.A.pack(t,n,o),i=!0);else{if(!(0,s.A)(t.x))throw new c.A("Invalid vec4 value.");r.A.equalsArray(t,n,o)||(r.A.pack(t,n,o),i=!0)}o+=4}i&&this._gl.uniform4fv(this._location,n)},_.prototype.set=function(){const e=this._gl,t=e.TEXTURE0+this.textureUnitIndex,n=this.value,i=n.length;for(let o=0;o<i;++o){const i=n[o];e.activeTexture(t+o),e.bindTexture(i._target,i._texture)}},_.prototype._setSampler=function(e){this.textureUnitIndex=e;const t=this._locations,n=t.length;for(let i=0;i<n;++i){const n=e+i;this._gl.uniform1i(t[i],n)}return e+n},g.prototype.set=function(){const e=this.value,t=e.length,n=this._value;let i=!1;for(let o=0;o<t;++o){const t=e[o];t!==n[o]&&(n[o]=t,i=!0)}i&&this._gl.uniform1iv(this._location,n)},y.prototype.set=function(){const e=this.value,t=e.length,n=this._value;let o=!1,r=0;for(let a=0;a<t;++a){const t=e[a];i.A.equalsArray(t,n,r)||(i.A.pack(t,n,r),o=!0),r+=2}o&&this._gl.uniform2iv(this._location,n)},v.prototype.set=function(){const e=this.value,t=e.length,n=this._value;let i=!1,r=0;for(let a=0;a<t;++a){const t=e[a];o.A.equalsArray(t,n,r)||(o.A.pack(t,n,r),i=!0),r+=3}i&&this._gl.uniform3iv(this._location,n)},b.prototype.set=function(){const e=this.value,t=e.length,n=this._value;let i=!1,o=0;for(let a=0;a<t;++a){const t=e[a];r.A.equalsArray(t,n,o)||(r.A.pack(t,n,o),i=!0),o+=4}i&&this._gl.uniform4iv(this._location,n)},w.prototype.set=function(){const e=this.value,t=e.length,n=this._value;let i=!1,o=0;for(let r=0;r<t;++r){const t=e[r];l.A.equalsArray(t,n,o)||(l.A.pack(t,n,o),i=!0),o+=4}i&&this._gl.uniformMatrix2fv(this._location,!1,n)},T.prototype.set=function(){const e=this.value,t=e.length,n=this._value;let i=!1,o=0;for(let r=0;r<t;++r){const t=e[r];h.A.equalsArray(t,n,o)||(h.A.pack(t,n,o),i=!0),o+=9}i&&this._gl.uniformMatrix3fv(this._location,!1,n)},x.prototype.set=function(){const e=this.value,t=e.length,n=this._value;let i=!1,o=0;for(let r=0;r<t;++r){const t=e[r];u.A.equalsArray(t,n,o)||(u.A.pack(t,n,o),i=!0),o+=16}i&&this._gl.uniformMatrix4fv(this._location,!1,n)};const C=function(e,t,n,i){switch(t.type){case e.FLOAT:return new p(e,t,n,i);case e.FLOAT_VEC2:return new m(e,t,n,i);case e.FLOAT_VEC3:return new f(e,t,n,i);case e.FLOAT_VEC4:return new A(e,t,n,i);case e.SAMPLER_2D:case e.SAMPLER_3D:case e.SAMPLER_CUBE:return new _(e,t,n,i);case e.INT:case e.BOOL:return new g(e,t,n,i);case e.INT_VEC2:case e.BOOL_VEC2:return new y(e,t,n,i);case e.INT_VEC3:case e.BOOL_VEC3:return new v(e,t,n,i);case e.INT_VEC4:case e.BOOL_VEC4:return new b(e,t,n,i);case e.FLOAT_MAT2:return new w(e,t,n,i);case e.FLOAT_MAT3:return new T(e,t,n,i);case e.FLOAT_MAT4:return new x(e,t,n,i);default:throw new d.A(`Unrecognized uniform type: ${t.type} for uniform "${n}".`)}}},790868:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i=function(e,t){let n=e;return n=n.replaceAll("version 300 es",""),n=n.replaceAll(/(texture\()/g,"texture2D("),t?(n=n.replaceAll(/\n\s*(in)\s+(vec\d|mat\d|float)/g,"\nvarying $2"),/out_FragData_(\d+)/.test(n)&&(n=`#extension GL_EXT_draw_buffers : enable\n${n}`,n=n.replaceAll(/layout\s+\(location\s*=\s*\d+\)\s*out\s+vec4\s+out_FragData_\d+;/g,""),n=n.replaceAll(/out_FragData_(\d+)/g,"gl_FragData[$1]")),n=n.replaceAll(/layout\s+\(location\s*=\s*0\)\s*out\s+vec4\s+out_FragColor;/g,""),n=n.replaceAll(/out_FragColor/g,"gl_FragColor"),n=n.replaceAll(/out_FragColor\[(\d+)\]/g,"gl_FragColor[$1]"),/gl_FragDepth/.test(n)&&(n=`#extension GL_EXT_frag_depth : enable\n${n}`,n=n.replaceAll(/gl_FragDepth/g,"gl_FragDepthEXT")),n=`#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod : enable\n#endif\n${n}`,n=`#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n${n}`):(n=n.replaceAll(/(in)\s+(vec\d|mat\d|float)/g,"attribute $2"),n=n.replaceAll(/(out)\s+(vec\d|mat\d|float)\s+([\w]+);/g,"varying $2 $3;")),n=`#version 100\n${n}`,n}},240863:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i=function e(t){if("object"!=typeof t||null===t)return t;let n;const i=Object.keys(t);for(let o=0;o<i.length;o++)n=i[o],t.hasOwnProperty(n)&&"_applyFunctions"!==n&&(t[n]=e(t[n]));return Object.freeze(t)}},207828:(e,t,n)=>{"use strict";n.d(t,{A:()=>h});var i=n(376758),o=n(430346),r=n(915325),a=n(491446),s=n(200646),c=n(527083);function l(e){e=e??r.A.EMPTY_OBJECT,this.material=e.material,this.translucent=e.translucent??!0,this._vertexShaderSource=e.vertexShaderSource,this._fragmentShaderSource=e.fragmentShaderSource,this._renderState=e.renderState,this._closed=e.closed??!1}Object.defineProperties(l.prototype,{vertexShaderSource:{get:function(){return this._vertexShaderSource}},fragmentShaderSource:{get:function(){return this._fragmentShaderSource}},renderState:{get:function(){return this._renderState}},closed:{get:function(){return this._closed}}}),l.prototype.getFragmentShaderSource=function(){const e=[];return this.flat&&e.push("#define FLAT"),this.faceForward&&e.push("#define FACE_FORWARD"),(0,a.A)(this.material)&&e.push(this.material.shaderSource),e.push(this.fragmentShaderSource),e.join("\n")},l.prototype.isTranslucent=function(){return(0,a.A)(this.material)&&this.material.isTranslucent()||!(0,a.A)(this.material)&&this.translucent},l.prototype.getRenderState=function(){const e=this.isTranslucent(),t=(0,i.A)(this.renderState,!1);return e?(t.depthMask=!1,t.blending=s.A.ALPHA_BLEND):t.depthMask=!0,t},l.getDefaultRenderState=function(e,t,n){let i={depthTest:{enabled:!0}};return e&&(i.depthMask=!1,i.blending=s.A.ALPHA_BLEND),t&&(i.cull={enabled:!0,face:c.A.BACK}),(0,a.A)(n)&&(i=(0,o.A)(n,i,!0)),i};const h=l},730839:(e,t,n)=>{"use strict";n.d(t,{A:()=>d});var i=n(434067),o=n(267980),r=n(626809),a=n(369031),s=n(605971),c=n(463298),l=n(331185),h=n(584164);const u={SCALAR:"SCALAR",VEC2:"VEC2",VEC3:"VEC3",VEC4:"VEC4",MAT2:"MAT2",MAT3:"MAT3",MAT4:"MAT4",getMathType:function(e){switch(e){case u.SCALAR:return Number;case u.VEC2:return i.A;case u.VEC3:return o.A;case u.VEC4:return r.A;case u.MAT2:return c.A;case u.MAT3:return l.A;case u.MAT4:return h.A;default:throw new s.A("attributeType is not a valid value.")}},getNumberOfComponents:function(e){switch(e){case u.SCALAR:return 1;case u.VEC2:return 2;case u.VEC3:return 3;case u.VEC4:case u.MAT2:return 4;case u.MAT3:return 9;case u.MAT4:return 16;default:throw new s.A("attributeType is not a valid value.")}},getAttributeLocationCount:function(e){switch(e){case u.SCALAR:case u.VEC2:case u.VEC3:case u.VEC4:return 1;case u.MAT2:return 2;case u.MAT3:return 3;case u.MAT4:return 4;default:throw new s.A("attributeType is not a valid value.")}},getGlslType:function(e){switch(a.A.typeOf.string("attributeType",e),e){case u.SCALAR:return"float";case u.VEC2:return"vec2";case u.VEC3:return"vec3";case u.VEC4:return"vec4";case u.MAT2:return"mat2";case u.MAT3:return"mat3";case u.MAT4:return"mat4";default:throw new s.A("attributeType is not a valid value.")}}},d=Object.freeze(u)},425438:(e,t,n)=>{"use strict";n.d(t,{A:()=>T});var i=n(434067),o=n(267980),r=n(626809),a=n(430346),s=n(571804),c=n(491446),l=n(677354),h=n(605971),u=n(276904),d=n(430332),p=n(57775),m=n(654799),f=n(616e3);function A(e,t,n){if(!(0,c.A)(e))throw new h.A("context is required");if(!(0,c.A)(t))throw new h.A("attributes is required");if(!(0,c.A)(n))throw new h.A("numberOfInstances is required");if(this._attributes=t,this._numberOfInstances=n,0===t.length)return;const o=function(e){let t=!1;const n=e.length;for(let i=0;i<n;++i)if(e[i].componentDatatype!==s.A.UNSIGNED_BYTE){t=!0;break}return t?p.A.FLOAT:p.A.UNSIGNED_BYTE}(t),a=e.floatingPointTexture,l=o===p.A.FLOAT&&!a,u=function(e,t){const n=new Array(e.length);let i=0;const o=e.length;for(let r=0;r<o;++r){const o=e[r].componentDatatype;n[r]=i,o!==s.A.UNSIGNED_BYTE&&t?i+=4:++i}return n}(t,l),m=function(e,t,n){const i=e.length,o=e[i-1];return t[i-1].componentDatatype!==s.A.UNSIGNED_BYTE&&n?o+4:o+1}(u,t,l),f=Math.floor(d.A.maximumTextureSize/m),A=Math.min(n,f),_=m*A,g=Math.ceil(n/A),y=1/_,v=.5*y,b=1/g,w=.5*b;this._textureDimensions=new i.A(_,g),this._textureStep=new r.A(y,v,b,w),this._pixelDatatype=l?p.A.UNSIGNED_BYTE:o,this._packFloats=l,this._offsets=u,this._stride=m,this._texture=void 0;const T=4*_*g;this._batchValues=o!==p.A.FLOAT||l?new Uint8Array(T):new Float32Array(T),this._batchValuesDirty=!1}function _(e,t){const n=e[t].componentsPerAttribute;return 2===n?i.A:3===n?o.A:4===n?r.A:Number}Object.defineProperties(A.prototype,{attributes:{get:function(){return this._attributes}},numberOfInstances:{get:function(){return this._numberOfInstances}}});const g=new r.A,y=new r.A;A.prototype.getBatchedAttribute=function(e,t,n){if(e<0||e>=this._numberOfInstances)throw new h.A("instanceIndex is out of range.");if(t<0||t>=this._attributes.length)throw new h.A("attributeIndex is out of range");const i=this._attributes,o=this._offsets[t],a=4*this._stride*e+4*o;let s;s=this._packFloats&&i[t].componentDatatype!==p.A.UNSIGNED_BYTE?function(e,t,n){let i=r.A.unpack(e,t,g);const o=r.A.unpackFloat(i);i=r.A.unpack(e,t+4,g);const a=r.A.unpackFloat(i);i=r.A.unpack(e,t+8,g);const s=r.A.unpackFloat(i);i=r.A.unpack(e,t+12,g);const c=r.A.unpackFloat(i);return r.A.fromElements(o,a,s,c,n)}(this._batchValues,a,y):r.A.unpack(this._batchValues,a,y);const l=_(i,t);return(0,c.A)(l.fromCartesian4)?l.fromCartesian4(s,n):(0,c.A)(l.clone)?l.clone(s,n):s.x};const v=[void 0,void 0,new i.A,new o.A,new r.A],b=new r.A;function w(e,t){const n=e._attributes[t],i=n.componentsPerAttribute,o=n.functionName,r=function(e){return 1===e?"float":`vec${e}`}(i),a=function(e){return 1===e?".x":2===e?".xy":3===e?".xyz":""}(i);let c=`${r} ${o}(float batchId) \n{ \n    vec2 st = computeSt(batchId); \n    st.x += batchTextureStep.x * float(${e._offsets[t]}); \n`;return e._packFloats&&n.componentDatatype!==p.A.UNSIGNED_BYTE?c+="vec4 textureValue; \ntextureValue.x = czm_unpackFloat(texture(batchTexture, st)); \ntextureValue.y = czm_unpackFloat(texture(batchTexture, st + vec2(batchTextureStep.x, 0.0))); \ntextureValue.z = czm_unpackFloat(texture(batchTexture, st + vec2(batchTextureStep.x * 2.0, 0.0))); \ntextureValue.w = czm_unpackFloat(texture(batchTexture, st + vec2(batchTextureStep.x * 3.0, 0.0))); \n":c+="    vec4 textureValue = texture(batchTexture, st); \n",c+=`    ${r} value = textureValue${a}; \n`,e._pixelDatatype!==p.A.UNSIGNED_BYTE||n.componentDatatype!==s.A.UNSIGNED_BYTE||n.normalize?e._pixelDatatype===p.A.FLOAT&&n.componentDatatype===s.A.UNSIGNED_BYTE&&n.normalize&&(c+="value /= 255.0; \n"):c+="value *= 255.0; \n",c+="    return value; \n} \n",c}A.prototype.setBatchedAttribute=function(e,t,n){if(e<0||e>=this._numberOfInstances)throw new h.A("instanceIndex is out of range.");if(t<0||t>=this._attributes.length)throw new h.A("attributeIndex is out of range");if(!(0,c.A)(n))throw new h.A("value is required.");const i=this._attributes,o=v[i[t].componentsPerAttribute],a=this.getBatchedAttribute(e,t,o),s=_(this._attributes,t);if((0,c.A)(s.equals)?s.equals(a,n):a===n)return;const l=b;l.x=(0,c.A)(n.x)?n.x:n,l.y=(0,c.A)(n.y)?n.y:0,l.z=(0,c.A)(n.z)?n.z:0,l.w=(0,c.A)(n.w)?n.w:0;const u=this._offsets[t],d=4*this._stride*e+4*u;this._packFloats&&i[t].componentDatatype!==p.A.UNSIGNED_BYTE?function(e,t,n){let i=r.A.packFloat(e.x,g);r.A.pack(i,t,n),i=r.A.packFloat(e.y,i),r.A.pack(i,t,n+4),i=r.A.packFloat(e.z,i),r.A.pack(i,t,n+8),i=r.A.packFloat(e.w,i),r.A.pack(i,t,n+12)}(l,this._batchValues,d):r.A.pack(l,this._batchValues,d),this._batchValuesDirty=!0},A.prototype.update=function(e){(0,c.A)(this._texture)&&!this._batchValuesDirty||0===this._attributes.length||(this._batchValuesDirty=!1,(0,c.A)(this._texture)||function(e,t){const n=e._textureDimensions;e._texture=new f.A({context:t,pixelFormat:u.A.RGBA,pixelDatatype:e._pixelDatatype,width:n.x,height:n.y,sampler:m.A.NEAREST,flipY:!1})}(this,e.context),function(e){const t=e._textureDimensions;e._texture.copyFrom({source:{width:t.x,height:t.y,arrayBufferView:e._batchValues}})}(this))},A.prototype.getUniformMapCallback=function(){const e=this;return function(t){if(0===e._attributes.length)return t;const n={batchTexture:function(){return e._texture},batchTextureDimensions:function(){return e._textureDimensions},batchTextureStep:function(){return e._textureStep}};return(0,a.A)(t,n)}},A.prototype.getVertexShaderCallback=function(){const e=this._attributes;if(0===e.length)return function(e){return e};let t="uniform highp sampler2D batchTexture; \n";t+=`${function(e){const t=e._stride;return 1===e._textureDimensions.y?`uniform vec4 batchTextureStep; \nvec2 computeSt(float batchId) \n{ \n    float stepX = batchTextureStep.x; \n    float centerX = batchTextureStep.y; \n    float numberOfAttributes = float(${t}); \n    return vec2(centerX + (batchId * numberOfAttributes * stepX), 0.5); \n} \n`:`uniform vec4 batchTextureStep; \nuniform vec2 batchTextureDimensions; \nvec2 computeSt(float batchId) \n{ \n    float stepX = batchTextureStep.x; \n    float centerX = batchTextureStep.y; \n    float stepY = batchTextureStep.z; \n    float centerY = batchTextureStep.w; \n    float numberOfAttributes = float(${t}); \n    float xId = mod(batchId * numberOfAttributes, batchTextureDimensions.x); \n    float yId = floor(batchId * numberOfAttributes / batchTextureDimensions.x); \n    return vec2(centerX + (xId * stepX), centerY + (yId * stepY)); \n} \n`}(this)}\n`;const n=e.length;for(let e=0;e<n;++e)t+=w(this,e);return function(e){const n=e.indexOf("void main"),i=e.substring(0,n),o=e.substring(n);return`${i}\n${t}\n${o}`}},A.prototype.isDestroyed=function(){return!1},A.prototype.destroy=function(){return this._texture=this._texture&&this._texture.destroy(),(0,l.A)(this)};const T=A},124547:(e,t,n)=>{"use strict";n.d(t,{A:()=>Z});var i=n(647934),o=n(434067),r=n(267980),a=n(626809),s=n(336946),c=n(369031),l=n(41476),h=n(673874),u=n(915325),d=n(491446),p=n(605971),m=n(853331),f=n(610750),A=n(584164),_=n(290176),g=n(744603),y=n(208836),v=n(63316),b=n(337632),w=n(62467),T=n(78173),x=n(742558),C=n(913419);function E(e,t){if(e=e??u.A.EMPTY_OBJECT,(0,d.A)(e.disableDepthTestDistance)&&e.disableDepthTestDistance<0)throw new p.A("disableDepthTestDistance must be greater than or equal to 0.0.");let n=e.translucencyByDistance,i=e.pixelOffsetScaleByDistance,a=e.scaleByDistance,s=e.distanceDisplayCondition;if((0,d.A)(n)){if(n.far<=n.near)throw new p.A("translucencyByDistance.far must be greater than translucencyByDistance.near.");n=_.A.clone(n)}if((0,d.A)(i)){if(i.far<=i.near)throw new p.A("pixelOffsetScaleByDistance.far must be greater than pixelOffsetScaleByDistance.near.");i=_.A.clone(i)}if((0,d.A)(a)){if(a.far<=a.near)throw new p.A("scaleByDistance.far must be greater than scaleByDistance.near.");a=_.A.clone(a)}if((0,d.A)(s)){if(s.far<=s.near)throw new p.A("distanceDisplayCondition.far must be greater than distanceDisplayCondition.near.");s=m.A.clone(s)}this._show=e.show??!0,this._position=r.A.clone(e.position??r.A.ZERO),this._actualPosition=r.A.clone(this._position),this._pixelOffset=o.A.clone(e.pixelOffset??o.A.ZERO),this._translate=new o.A(0,0),this._eyeOffset=r.A.clone(e.eyeOffset??r.A.ZERO),this._heightReference=e.heightReference??v.Ay.NONE,this._verticalOrigin=e.verticalOrigin??x.A.CENTER,this._horizontalOrigin=e.horizontalOrigin??b.A.CENTER,this._scale=e.scale??1,this._color=l.A.clone(e.color??l.A.WHITE),this._rotation=e.rotation??0,this._alignedAxis=r.A.clone(e.alignedAxis??r.A.ZERO),this._width=e.width,this._height=e.height,this._scaleByDistance=a,this._translucencyByDistance=n,this._pixelOffsetScaleByDistance=i,this._sizeInMeters=e.sizeInMeters??!1,this._distanceDisplayCondition=s,this._disableDepthTestDistance=e.disableDepthTestDistance,this._id=e.id,this._collection=e.collection??t,this._pickId=void 0,this._pickPrimitive=e._pickPrimitive??this,this._billboardCollection=t,this._dirty=!1,this._index=-1,this._batchIndex=void 0,this._imageTexture=new y.A(t),this._imageWidth=void 0,this._imageHeight=void 0,this._labelDimensions=void 0,this._labelHorizontalOrigin=void 0,this._labelTranslate=void 0;const c=e.image;let f=e.imageId;(0,d.A)(c)&&((0,d.A)(f)||(f="string"==typeof c?c:(0,d.A)(c.src)?c.src:(0,h.A)()),this._imageTexture.loadImage(f,c)),(0,d.A)(e.imageSubRegion)&&this._imageTexture.addImageSubRegion(f,e.imageSubRegion),this._actualClampedPosition=void 0,this._removeCallbackFunc=void 0,this._mode=w.A.SCENE3D,this._clusterShow=!0,this._outlineColor=l.A.clone(e.outlineColor??l.A.BLACK),this._outlineWidth=e.outlineWidth??0,this._updateClamping(),this._splitDirection=e.splitDirection??C.A.NONE}const S=E.SHOW_INDEX=0,D=E.POSITION_INDEX=1,O=E.PIXEL_OFFSET_INDEX=2,z=E.EYE_OFFSET_INDEX=3,I=E.HORIZONTAL_ORIGIN_INDEX=4,P=E.VERTICAL_ORIGIN_INDEX=5,R=E.SCALE_INDEX=6,N=E.IMAGE_INDEX_INDEX=7,L=E.COLOR_INDEX=8,M=E.ROTATION_INDEX=9,F=E.ALIGNED_AXIS_INDEX=10,B=E.SCALE_BY_DISTANCE_INDEX=11,k=E.TRANSLUCENCY_BY_DISTANCE_INDEX=12,V=E.PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX=13,G=E.DISTANCE_DISPLAY_CONDITION=14,H=E.DISABLE_DEPTH_DISTANCE=15;E.TEXTURE_COORDINATE_BOUNDS=16;const U=E.SDF_INDEX=17,W=E.SPLIT_DIRECTION_INDEX=18;function q(e,t){const n=e._billboardCollection;(0,d.A)(n)&&(n._updateBillboard(e,t),e._dirty=!0)}E.NUMBER_OF_PROPERTIES=19,Object.defineProperties(E.prototype,{show:{get:function(){return this._show},set:function(e){c.A.typeOf.bool("value",e),this._show!==e&&(this._show=e,q(this,S))}},position:{get:function(){return this._position},set:function(e){c.A.typeOf.object("value",e);const t=this._position;r.A.equals(t,e)||(r.A.clone(e,t),r.A.clone(e,this._actualPosition),this._updateClamping(),q(this,D))}},heightReference:{get:function(){return this._heightReference},set:function(e){c.A.typeOf.number("value",e),e!==this._heightReference&&(this._heightReference=e,this._updateClamping(),q(this,D))}},pixelOffset:{get:function(){return this._pixelOffset},set:function(e){c.A.typeOf.object("value",e);const t=this._pixelOffset;o.A.equals(t,e)||(o.A.clone(e,t),q(this,O))}},scaleByDistance:{get:function(){return this._scaleByDistance},set:function(e){if((0,d.A)(e)&&(c.A.typeOf.object("value",e),e.far<=e.near))throw new p.A("far distance must be greater than near distance.");const t=this._scaleByDistance;_.A.equals(t,e)||(this._scaleByDistance=_.A.clone(e,t),q(this,B))}},translucencyByDistance:{get:function(){return this._translucencyByDistance},set:function(e){if((0,d.A)(e)&&(c.A.typeOf.object("value",e),e.far<=e.near))throw new p.A("far distance must be greater than near distance.");const t=this._translucencyByDistance;_.A.equals(t,e)||(this._translucencyByDistance=_.A.clone(e,t),q(this,k))}},pixelOffsetScaleByDistance:{get:function(){return this._pixelOffsetScaleByDistance},set:function(e){if((0,d.A)(e)&&(c.A.typeOf.object("value",e),e.far<=e.near))throw new p.A("far distance must be greater than near distance.");const t=this._pixelOffsetScaleByDistance;_.A.equals(t,e)||(this._pixelOffsetScaleByDistance=_.A.clone(e,t),q(this,V))}},eyeOffset:{get:function(){return this._eyeOffset},set:function(e){c.A.typeOf.object("value",e);const t=this._eyeOffset;r.A.equals(t,e)||(r.A.clone(e,t),q(this,z))}},horizontalOrigin:{get:function(){return this._horizontalOrigin},set:function(e){c.A.typeOf.number("value",e),this._horizontalOrigin!==e&&(this._horizontalOrigin=e,q(this,I))}},verticalOrigin:{get:function(){return this._verticalOrigin},set:function(e){c.A.typeOf.number("value",e),this._verticalOrigin!==e&&(this._verticalOrigin=e,q(this,P))}},scale:{get:function(){return this._scale},set:function(e){c.A.typeOf.number("value",e),this._scale!==e&&(this._scale=e,q(this,R))}},color:{get:function(){return this._color},set:function(e){c.A.typeOf.object("value",e);const t=this._color;l.A.equals(t,e)||(l.A.clone(e,t),q(this,L))}},rotation:{get:function(){return this._rotation},set:function(e){c.A.typeOf.number("value",e),this._rotation!==e&&(this._rotation=e,q(this,M))}},alignedAxis:{get:function(){return this._alignedAxis},set:function(e){c.A.typeOf.object("value",e);const t=this._alignedAxis;r.A.equals(t,e)||(r.A.clone(e,t),q(this,F))}},width:{get:function(){return this._width??this._imageTexture.width},set:function(e){(0,d.A)(e)&&c.A.typeOf.number("width",e),this._width!==e&&(this._width=e,q(this,N))}},height:{get:function(){return this._height??this._imageTexture.height},set:function(e){(0,d.A)(e)&&c.A.typeOf.number("height",e),this._height!==e&&(this._height=e,q(this,N))}},sizeInMeters:{get:function(){return this._sizeInMeters},set:function(e){c.A.typeOf.bool("value",e),this._sizeInMeters!==e&&(this._sizeInMeters=e,q(this,L))}},distanceDisplayCondition:{get:function(){return this._distanceDisplayCondition},set:function(e){if(!m.A.equals(e,this._distanceDisplayCondition)){if((0,d.A)(e)&&(c.A.typeOf.object("value",e),e.far<=e.near))throw new p.A("far distance must be greater than near distance.");this._distanceDisplayCondition=m.A.clone(e,this._distanceDisplayCondition),q(this,G)}}},disableDepthTestDistance:{get:function(){return this._disableDepthTestDistance},set:function(e){if((0,d.A)(e)&&(c.A.typeOf.number("value",e),e<0))throw new p.A("disableDepthTestDistance must be greater than or equal to 0.0.");this._disableDepthTestDistance!==e&&(this._disableDepthTestDistance=e,q(this,H))}},id:{get:function(){return this._id},set:function(e){this._id=e,(0,d.A)(this._pickId)&&(this._pickId.object.id=e)}},pickPrimitive:{get:function(){return this._pickPrimitive},set:function(e){this._pickPrimitive=e,(0,d.A)(this._pickId)&&(this._pickId.object.primitive=e)}},pickId:{get:function(){return this._pickId}},image:{get:function(){return this._imageTexture.id},set:function(e){if(!(0,d.A)(e))return void this._imageTexture.unload();let t;t="string"==typeof e?e:e instanceof g.A?e._url:(0,d.A)(e.src)?e.src:(0,h.A)(),this._imageTexture.loadImage(t,e)}},ready:{get:function(){return this._imageTexture.ready}},loadError:{get:function(){return this._imageTexture.loadError}},textureDirty:{get:function(){return this._imageTexture.dirty},set:function(e){this._imageTexture.dirty=e}},_clampedPosition:{get:function(){return this._actualClampedPosition},set:function(e){this._actualClampedPosition=r.A.clone(e,this._actualClampedPosition),q(this,D)}},clusterShow:{get:function(){return this._clusterShow},set:function(e){this._clusterShow!==e&&(this._clusterShow=e,q(this,S))}},outlineColor:{get:function(){return this._outlineColor},set:function(e){if(!(0,d.A)(e))throw new p.A("value is required.");const t=this._outlineColor;l.A.equals(t,e)||(l.A.clone(e,t),q(this,U))}},outlineWidth:{get:function(){return this._outlineWidth},set:function(e){this._outlineWidth!==e&&(this._outlineWidth=e,q(this,U))}},splitDirection:{get:function(){return this._splitDirection},set:function(e){this._splitDirection!==e&&(this._splitDirection=e,q(this,W))}}}),E.prototype.getPickId=function(e){return(0,d.A)(this._pickId)||(this._pickId=e.createPickId({primitive:this._pickPrimitive,collection:this._collection,id:this._id})),this._pickId},E.prototype._updateClamping=function(){E._updateClamping(this._billboardCollection,this)};const j=new s.A;E._updateClamping=function(e,t){if(!(0,d.A)(e)||!(0,d.A)(e._scene)){if(t._heightReference!==v.Ay.NONE)throw new p.A("Height reference is not supported without a scene.");return}const n=e._scene,i=n.ellipsoid??f.A.default,o=n.frameState.mode,r=o!==t._mode;if(t._mode=o,(t._heightReference===v.Ay.NONE||r)&&(0,d.A)(t._removeCallbackFunc)&&(t._removeCallbackFunc(),t._removeCallbackFunc=void 0,t._clampedPosition=void 0),t._heightReference===v.Ay.NONE||!(0,d.A)(t._position))return;(0,d.A)(t._removeCallbackFunc)&&t._removeCallbackFunc();const a=i.cartesianToCartographic(t._position);if(!(0,d.A)(a))return void(t._actualClampedPosition=void 0);function c(e){const n=i.cartographicToCartesian(e,t._clampedPosition);(0,v.Lq)(t._heightReference)&&(t._mode===w.A.SCENE3D?(e.height+=a.height,i.cartographicToCartesian(e,n)):n.x+=a.height),t._clampedPosition=n}t._removeCallbackFunc=n.updateHeight(a,c,t._heightReference),s.A.clone(a,j);const l=n.getHeight(a,t._heightReference);(0,d.A)(l)&&(j.height=l),c(j)},E.prototype.computeTextureCoordinates=function(e){return this._imageTexture.computeTextureCoordinates(e)},E.prototype.setImage=function(e,t){c.A.typeOf.string("id",e),c.A.defined("image",t),this._imageTexture.loadImage(e,t)},E.prototype.setImageTexture=function(e){c.A.defined("billboardTexture",e),y.A.clone(e,this._imageTexture)},E.prototype.setImageSubRegion=function(e,t){c.A.typeOf.string("id",e),c.A.defined("subRegion",t),this._imageTexture.addImageSubRegion(e,t)},E.prototype._setTranslate=function(e){if(!(0,d.A)(e))throw new p.A("value is required.");const t=this._translate;o.A.equals(t,e)||(o.A.clone(e,t),q(this,O))},E.prototype._getActualPosition=function(){return(0,d.A)(this._clampedPosition)?this._clampedPosition:this._actualPosition},E.prototype._setActualPosition=function(e){(0,d.A)(this._clampedPosition)||r.A.clone(e,this._actualPosition),q(this,D)};const Y=new a.A;E._computeActualPosition=function(e,t,n,i){return(0,d.A)(e._clampedPosition)?(n.mode!==e._mode&&e._updateClamping(),e._clampedPosition):n.mode===w.A.SCENE3D?t:(A.A.multiplyByPoint(i,t,Y),T.A.computeActualEllipsoidPosition(n,Y))};const X=new r.A;E._computeScreenSpacePosition=function(e,t,n,i,r,a){const s=A.A.multiplyByPoint(e,t,X),c=T.A.worldWithEyeOffsetToWindowCoordinates(r,s,n,a);if((0,d.A)(c))return o.A.add(c,i,c),c};const $=new o.A(0,0);E.prototype.computeScreenSpacePosition=function(e,t){const n=this._billboardCollection;if((0,d.A)(t)||(t=new o.A),!(0,d.A)(n))throw new p.A("Billboard must be in a collection.  Was it removed?");if(!(0,d.A)(e))throw new p.A("scene is required.");o.A.clone(this._pixelOffset,$),o.A.add($,this._translate,$);let i=n.modelMatrix,r=this._position;if((0,d.A)(this._clampedPosition)&&(r=this._clampedPosition,e.mode!==w.A.SCENE3D)){const t=e.mapProjection,n=t.ellipsoid,o=t.unproject(r,j);r=n.cartographicToCartesian(o,X),i=A.A.IDENTITY}return E._computeScreenSpacePosition(i,r,this._eyeOffset,$,e,t)},E.getScreenSpaceBoundingBox=function(e,t,n){let o=e.width,r=e.height;const a=e.scale;o*=a,r*=a;let s=t.x;e.horizontalOrigin===b.A.RIGHT?s-=o:e.horizontalOrigin===b.A.CENTER&&(s-=.5*o);let c=t.y;return e.verticalOrigin===x.A.BOTTOM||e.verticalOrigin===x.A.BASELINE?c-=r:e.verticalOrigin===x.A.CENTER&&(c-=.5*r),(0,d.A)(n)||(n=new i.A),n.x=s,n.y=c,n.width=o,n.height=r,n},E.prototype.equals=function(e){return this===e||(0,d.A)(e)&&this._id===e._id&&r.A.equals(this._position,e._position)&&this.image===e.image&&this._show===e._show&&this._scale===e._scale&&this._verticalOrigin===e._verticalOrigin&&this._horizontalOrigin===e._horizontalOrigin&&this._heightReference===e._heightReference&&l.A.equals(this._color,e._color)&&o.A.equals(this._pixelOffset,e._pixelOffset)&&o.A.equals(this._translate,e._translate)&&r.A.equals(this._eyeOffset,e._eyeOffset)&&_.A.equals(this._scaleByDistance,e._scaleByDistance)&&_.A.equals(this._translucencyByDistance,e._translucencyByDistance)&&_.A.equals(this._pixelOffsetScaleByDistance,e._pixelOffsetScaleByDistance)&&m.A.equals(this._distanceDisplayCondition,e._distanceDisplayCondition)&&this._disableDepthTestDistance===e._disableDepthTestDistance&&this._splitDirection===e._splitDirection},E.prototype._destroy=function(){(0,d.A)(this._customData)&&(this._billboardCollection._scene.globe._surface.removeTileCustomData(this._customData),this._customData=void 0),(0,d.A)(this._removeCallbackFunc)&&(this._removeCallbackFunc(),this._removeCallbackFunc=void 0),this.image=void 0,this._pickId=this._pickId&&this._pickId.destroy(),this._billboardCollection=void 0};const Z=E},770103:(e,t,n)=>{"use strict";n.d(t,{A:()=>Fe});var i=n(961645),o=n(647934),r=n(660662),a=n(434067),s=n(267980),c=n(369031),l=n(41476),h=n(571804),u=n(915325),d=n(491446),p=n(677354),m=n(816422),f=n(874915),A=n(367817),_=n(584164),g=n(352581),y=n(641613),v=n(442790),b=n(430332),w=n(377496),T=n(760866),x=n(40118),C=n(302836),E=n(342875),S=n(193470),D=n(952738),O=n(412562),z=n(124547),I=n(200646),P=n(416882),R=n(63316),N=n(337632),L=n(62467),M=n(589834),F=n(66589),B=n(742558);const k=z.A.SHOW_INDEX,V=z.A.POSITION_INDEX,G=z.A.PIXEL_OFFSET_INDEX,H=z.A.EYE_OFFSET_INDEX,U=z.A.HORIZONTAL_ORIGIN_INDEX,W=z.A.VERTICAL_ORIGIN_INDEX,q=z.A.SCALE_INDEX,j=z.A.IMAGE_INDEX_INDEX,Y=z.A.COLOR_INDEX,X=z.A.ROTATION_INDEX,$=z.A.ALIGNED_AXIS_INDEX,Z=z.A.SCALE_BY_DISTANCE_INDEX,K=z.A.TRANSLUCENCY_BY_DISTANCE_INDEX,Q=z.A.PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX,J=z.A.DISTANCE_DISPLAY_CONDITION,ee=z.A.DISABLE_DEPTH_DISTANCE,te=z.A.TEXTURE_COORDINATE_BOUNDS,ne=z.A.SDF_INDEX,ie=z.A.SPLIT_DIRECTION_INDEX,oe=z.A.NUMBER_OF_PROPERTIES;let re;const ae={positionHighAndScale:0,positionLowAndRotation:1,compressedAttribute0:2,compressedAttribute1:3,compressedAttribute2:4,eyeOffset:5,scaleByDistance:6,pixelOffsetScaleByDistance:7,compressedAttribute3:8,textureCoordinateBoundsOrLabelTranslate:9,a_batchId:10,sdf:11,splitDirection:12},se={direction:0,positionHighAndScale:1,positionLowAndRotation:2,compressedAttribute0:3,compressedAttribute1:4,compressedAttribute2:5,eyeOffset:6,scaleByDistance:7,pixelOffsetScaleByDistance:8,compressedAttribute3:9,textureCoordinateBoundsOrLabelTranslate:10,a_batchId:11,sdf:12,splitDirection:13};function ce(e){e=e??u.A.EMPTY_OBJECT,this._scene=e.scene,this._batchTable=e.batchTable;let t=e.textureAtlas;(0,d.A)(t)||(t=new F.A),this._textureAtlas=t,this._textureAtlasGUID=t.guid,this._destroyTextureAtlas=!0,this._billboardTextureCache=new Map,this._sp=void 0,this._spTranslucent=void 0,this._rsOpaque=void 0,this._rsTranslucent=void 0,this._vaf=void 0,this._billboards=[],this._billboardsToUpdate=[],this._billboardsToUpdateIndex=0,this._billboardsRemoved=!1,this._createVertexArray=!1,this._shaderRotation=!1,this._compiledShaderRotation=!1,this._shaderAlignedAxis=!1,this._compiledShaderAlignedAxis=!1,this._shaderScaleByDistance=!1,this._compiledShaderScaleByDistance=!1,this._shaderTranslucencyByDistance=!1,this._compiledShaderTranslucencyByDistance=!1,this._shaderPixelOffsetScaleByDistance=!1,this._compiledShaderPixelOffsetScaleByDistance=!1,this._shaderDistanceDisplayCondition=!1,this._compiledShaderDistanceDisplayCondition=!1,this._shaderDisableDepthDistance=!1,this._compiledShaderDisableDepthDistance=!1,this._shaderClampToGround=!1,this._compiledShaderClampToGround=!1,this._propertiesChanged=new Uint32Array(oe),this._maxSize=0,this._maxEyeOffset=0,this._maxScale=1,this._maxPixelOffset=0,this._allHorizontalCenter=!0,this._allVerticalCenter=!0,this._allSizedInMeters=!0,this._baseVolume=new r.A,this._baseVolumeWC=new r.A,this._baseVolume2D=new r.A,this._boundingVolume=new r.A,this._boundingVolumeDirty=!1,this._colorCommands=[],this._allBillboardsReady=!1,this.show=e.show??!0,this.modelMatrix=_.A.clone(e.modelMatrix??_.A.IDENTITY),this._modelMatrix=_.A.clone(_.A.IDENTITY),this.debugShowBoundingVolume=e.debugShowBoundingVolume??!1,this.debugShowTextureAtlas=e.debugShowTextureAtlas??!1,this.blendOption=e.blendOption??P.A.OPAQUE_AND_TRANSLUCENT,this._blendOption=void 0,this._mode=L.A.SCENE3D,this._buffersUsage=[v.A.STATIC_DRAW,v.A.STATIC_DRAW,v.A.STATIC_DRAW,v.A.STATIC_DRAW,v.A.STATIC_DRAW,v.A.STATIC_DRAW,v.A.STATIC_DRAW,v.A.STATIC_DRAW,v.A.STATIC_DRAW,v.A.STATIC_DRAW,v.A.STATIC_DRAW,v.A.STATIC_DRAW,v.A.STATIC_DRAW,v.A.STATIC_DRAW,v.A.STATIC_DRAW,v.A.STATIC_DRAW,v.A.STATIC_DRAW],this._highlightColor=l.A.clone(l.A.WHITE),this._uniforms={u_atlas:()=>this.textureAtlas.texture,u_highlightColor:()=>this._highlightColor};const n=this._scene;(0,d.A)(n)&&(0,d.A)(n.terrainProviderChanged)&&(this._removeCallbackFunc=n.terrainProviderChanged.addEventListener(function(){const e=this._billboards,t=e.length;for(let n=0;n<t;++n)(0,d.A)(e[n])&&e[n]._updateClamping()},this))}function le(e){const t=e.length;for(let n=0;n<t;++n)e[n]&&e[n]._destroy()}function he(e){if(e._billboardsRemoved){e._billboardsRemoved=!1;const t=[],n=e._billboards,i=n.length;for(let e=0,o=0;e<i;++e){const i=n[e];(0,d.A)(i)&&(i._index=o++,t.push(i))}e._billboards=t}}let ue;function de(e){let t=e.cache.billboardCollection_indexBufferBatched;if((0,d.A)(t))return t;const n=new Uint16Array(98298);for(let e=0,t=0;e<98298;e+=6,t+=4)n[e]=t,n[e+1]=t+1,n[e+2]=t+2,n[e+3]=t+0,n[e+4]=t+2,n[e+5]=t+3;return t=y.A.createIndexBuffer({context:e,typedArray:n,usage:v.A.STATIC_DRAW,indexDatatype:f.A.UNSIGNED_SHORT}),t.vertexArrayDestroyable=!1,e.cache.billboardCollection_indexBufferBatched=t,t}function pe(e){let t=e.cache.billboardCollection_indexBufferInstanced;return(0,d.A)(t)||(t=y.A.createIndexBuffer({context:e,typedArray:new Uint16Array([0,1,2,0,2,3]),usage:v.A.STATIC_DRAW,indexDatatype:f.A.UNSIGNED_SHORT}),t.vertexArrayDestroyable=!1,e.cache.billboardCollection_indexBufferInstanced=t),t}function me(e){let t=e.cache.billboardCollection_vertexBufferInstanced;return(0,d.A)(t)||(t=y.A.createVertexBuffer({context:e,typedArray:new Float32Array([0,0,1,0,1,1,0,1]),usage:v.A.STATIC_DRAW}),t.vertexArrayDestroyable=!1,e.cache.billboardCollection_vertexBufferInstanced=t),t}Object.defineProperties(ce.prototype,{length:{get:function(){return he(this),this._billboards.length}},textureAtlas:{get:function(){return this._textureAtlas},set:function(e){c.A.defined("textureAtlas",e),this._textureAtlas!==e&&(this._textureAtlas=this._destroyTextureAtlas&&this._textureAtlas&&this._textureAtlas.destroy(),this._textureAtlas=e)}},destroyTextureAtlas:{get:function(){return this._destroyTextureAtlas},set:function(e){this._destroyTextureAtlas=e}},sizeInBytes:{get:function(){return this._textureAtlas.sizeInBytes}},ready:{get:function(){return this._allBillboardsReady}},billboardTextureCache:{get:function(){return this._billboardTextureCache}}}),ce.prototype.add=function(e){const t=new z.A(e,this);return t._index=this._billboards.length,this._billboards.push(t),this._createVertexArray=!0,t},ce.prototype.remove=function(e){return!!this.contains(e)&&(this._billboards[e._index]=void 0,this._billboardsRemoved=!0,this._createVertexArray=!0,e._destroy(),!0)},ce.prototype.removeAll=function(){le(this._billboards),this._billboards=[],this._billboardsToUpdate=[],this._billboardsToUpdateIndex=0,this._billboardsRemoved=!1,this._createVertexArray=!0},ce.prototype._updateBillboard=function(e,t){e._dirty||(this._billboardsToUpdate[this._billboardsToUpdateIndex++]=e),++this._propertiesChanged[t]},ce.prototype.contains=function(e){return(0,d.A)(e)&&e._billboardCollection===this},ce.prototype.get=function(e){return c.A.typeOf.number("index",e),he(this),this._billboards[e]},ce.prototype.computeNewBuffersUsage=function(){const e=this._buffersUsage;let t=!1;const n=this._propertiesChanged;for(let i=0;i<oe;++i){const o=0===n[i]?v.A.STATIC_DRAW:v.A.STREAM_DRAW;t=t||e[i]!==o,e[i]=o}return t};const fe=new m.A;function Ae(e,t,n,i){let o;const a=n[re.positionHighAndScale],s=n[re.positionLowAndRotation],c=i._getActualPosition();e._mode===L.A.SCENE3D&&(r.A.expand(e._baseVolume,c,e._baseVolume),e._boundingVolumeDirty=!0),m.A.fromCartesian(c,fe);const l=i.scale,h=i.rotation;0!==h&&(e._shaderRotation=!0),e._maxScale=Math.max(e._maxScale,l);const u=fe.high,d=fe.low;e._instanced?(o=i._index,a(o,u.x,u.y,u.z,l),s(o,d.x,d.y,d.z,h)):(o=4*i._index,a(o+0,u.x,u.y,u.z,l),a(o+1,u.x,u.y,u.z,l),a(o+2,u.x,u.y,u.z,l),a(o+3,u.x,u.y,u.z,l),s(o+0,d.x,d.y,d.z,h),s(o+1,d.x,d.y,d.z,h),s(o+2,d.x,d.y,d.z,h),s(o+3,d.x,d.y,d.z,h))}const _e=new a.A,ge=32768,ye=65536,ve=4096,be=256,we=1/256,Te=new o.A;function xe(e,t,n,o){let r;const a=n[re.compressedAttribute0],s=o.pixelOffset,c=s.x,l=s.y,h=o._translate,u=h.x,d=h.y;e._maxPixelOffset=Math.max(e._maxPixelOffset,Math.abs(c+u),Math.abs(-l+d));const p=o.horizontalOrigin;let m=o._verticalOrigin,f=o.show&&o.clusterShow;0===o.color.alpha&&(f=!1),m===B.A.BASELINE&&(m=B.A.BOTTOM),e._allHorizontalCenter=e._allHorizontalCenter&&p===N.A.CENTER,e._allVerticalCenter=e._allVerticalCenter&&m===B.A.CENTER;let _=0,g=0,y=0,v=0;if(o.ready){const e=o.computeTextureCoordinates(Te);_=e.x,g=e.y,y=e.width,v=e.height}const b=_+y,w=g+v;let T=128*Math.floor(A.A.clamp(c,-32768,ge)+ge);T+=32*(p+1),T+=8*(m+1),T+=4*(f?1:0);let x=Math.floor(A.A.clamp(l,-32768,ge)+ge)*be,C=Math.floor(A.A.clamp(u,-32768,ge)+ge)*be;const E=(A.A.clamp(d,-32768,ge)+ge)*we,S=Math.floor(E);x+=S,C+=Math.floor((E-S)*be),_e.x=_,_e.y=g;const D=i.A.compressTextureCoordinates(_e);_e.x=b;const O=i.A.compressTextureCoordinates(_e);_e.y=w;const z=i.A.compressTextureCoordinates(_e);_e.x=_;const I=i.A.compressTextureCoordinates(_e);e._instanced?(r=o._index,a(r,T,x,C,D)):(r=4*o._index,a(r+0,T+0,x,C,D),a(r+1,T+2,x,C,O),a(r+2,T+3,x,C,z),a(r+3,T+1,x,C,I))}function Ce(e,t,n,o){let r;const a=n[re.compressedAttribute1],c=o.alignedAxis;s.A.equals(c,s.A.ZERO)||(e._shaderAlignedAxis=!0);let l=0,h=1,u=1,p=1;const m=o.translucencyByDistance;(0,d.A)(m)&&(l=m.near,h=m.nearValue,u=m.far,p=m.farValue,1===h&&1===p||(e._shaderTranslucencyByDistance=!0));const f=Math.round(o.width??0);e._maxSize=Math.max(e._maxSize,f);let _=A.A.clamp(f,0,ye),g=0;Math.abs(s.A.magnitudeSquared(c)-1)<A.A.EPSILON6&&(g=i.A.octEncodeFloat(c)),h=A.A.clamp(h,0,1),h=1===h?255:255*h|0,_=_*be+h,p=A.A.clamp(p,0,1),p=1===p?255:255*p|0,g=g*be+p,e._instanced?(r=o._index,a(r,_,g,l,u)):(r=4*o._index,a(r+0,_,g,l,u),a(r+1,_,g,l,u),a(r+2,_,g,l,u),a(r+3,_,g,l,u))}function Ee(e,t,n,i){let o;const r=n[re.compressedAttribute2],a=i.color,c=(0,d.A)(e._batchTable)?l.A.WHITE:i.getPickId(t.context).color,h=i.sizeInMeters?1:0,u=Math.abs(s.A.magnitudeSquared(i.alignedAxis)-1)<A.A.EPSILON6?1:0;e._allSizedInMeters=e._allSizedInMeters&&1===h;const p=i.height??0;e._maxSize=Math.max(e._maxSize,p);let m=i._labelHorizontalOrigin??-2;m+=2;const f=4*p+m;let _=l.A.floatToByte(a.red),g=l.A.floatToByte(a.green),y=l.A.floatToByte(a.blue);const v=_*ye+g*be+y;_=l.A.floatToByte(c.red),g=l.A.floatToByte(c.green),y=l.A.floatToByte(c.blue);const b=_*ye+g*be+y;let w=l.A.floatToByte(a.alpha)*ye+l.A.floatToByte(c.alpha)*be;w+=2*h+u,e._instanced?(o=i._index,r(o,v,b,w,f)):(o=4*i._index,r(o+0,v,b,w,f),r(o+1,v,b,w,f),r(o+2,v,b,w,f),r(o+3,v,b,w,f))}function Se(e,t,n,o){let r;const a=n[re.eyeOffset],s=o.eyeOffset;let c=s.z;if(o._heightReference!==R.Ay.NONE&&(c*=1.005),e._maxEyeOffset=Math.max(e._maxEyeOffset,Math.abs(s.x),Math.abs(s.y),Math.abs(c)),e._instanced){if(_e.x=0,_e.y=0,o.ready){const e=o.computeTextureCoordinates(Te);_e.x=e.width,_e.y=e.height}const e=i.A.compressTextureCoordinates(_e);r=o._index,a(r,s.x,s.y,c,e)}else r=4*o._index,a(r+0,s.x,s.y,c,0),a(r+1,s.x,s.y,c,0),a(r+2,s.x,s.y,c,0),a(r+3,s.x,s.y,c,0)}function De(e,t,n,i){let o;const r=n[re.scaleByDistance];let a=0,s=1,c=1,l=1;const h=i.scaleByDistance;(0,d.A)(h)&&(a=h.near,s=h.nearValue,c=h.far,l=h.farValue,1===s&&1===l||(e._shaderScaleByDistance=!0)),e._instanced?(o=i._index,r(o,a,s,c,l)):(o=4*i._index,r(o+0,a,s,c,l),r(o+1,a,s,c,l),r(o+2,a,s,c,l),r(o+3,a,s,c,l))}function Oe(e,t,n,i){let o;const r=n[re.pixelOffsetScaleByDistance];let a=0,s=1,c=1,l=1;const h=i.pixelOffsetScaleByDistance;(0,d.A)(h)&&(a=h.near,s=h.nearValue,c=h.far,l=h.farValue,1===s&&1===l||(e._shaderPixelOffsetScaleByDistance=!0)),e._instanced?(o=i._index,r(o,a,s,c,l)):(o=4*i._index,r(o+0,a,s,c,l),r(o+1,a,s,c,l),r(o+2,a,s,c,l),r(o+3,a,s,c,l))}function ze(e,t,n,i){let o;const r=n[re.compressedAttribute3];let a=0,s=Number.MAX_VALUE;const c=i.distanceDisplayCondition;(0,d.A)(c)&&(a=c.near,s=c.far,a*=a,s*=s,e._shaderDistanceDisplayCondition=!0);let l=i.disableDepthTestDistance;const h=(0,R.w_)(i.heightReference)&&t.context.depthTexture;let u,p;(0,d.A)(l)||(l=h?5e3:0),l*=l,(h||l>0)&&(e._shaderDisableDepthDistance=!0,l===Number.POSITIVE_INFINITY&&(l=-1)),(0,d.A)(i._labelDimensions)?(p=i._labelDimensions.x,u=i._labelDimensions.y):(p=i.width??0,u=i.height??0);const m=Math.floor(A.A.clamp(p,0,ve)),f=Math.floor(A.A.clamp(u,0,ve)),_=m*ve+f;e._instanced?(o=i._index,r(o,a,s,l,_)):(o=4*i._index,r(o+0,a,s,l,_),r(o+1,a,s,l,_),r(o+2,a,s,l,_),r(o+3,a,s,l,_))}function Ie(e,t,n,i){if((0,R.w_)(i.heightReference)){const n=e._scene,i=t.context,o=t.globeTranslucencyState.translucent,r=(0,d.A)(n.globe)&&n.globe.depthTestAgainstTerrain;e._shaderClampToGround=i.depthTexture&&!o&&r}let o;const r=n[re.textureCoordinateBoundsOrLabelTranslate];if(b.A.maximumVertexTextureImageUnits>0){let t=0,n=0;return(0,d.A)(i._labelTranslate)&&(t=i._labelTranslate.x,n=i._labelTranslate.y),void(e._instanced?(o=i._index,r(o,t,n,0,0)):(o=4*i._index,r(o+0,t,n,0,0),r(o+1,t,n,0,0),r(o+2,t,n,0,0),r(o+3,t,n,0,0)))}let a=0,s=0,c=0,l=0;if(i.ready){const e=i.computeTextureCoordinates(Te);a=e.x,s=e.y,c=e.width,l=e.height}const h=a+c,u=s+l;e._instanced?(o=i._index,r(o,a,s,h,u)):(o=4*i._index,r(o+0,a,s,h,u),r(o+1,a,s,h,u),r(o+2,a,s,h,u),r(o+3,a,s,h,u))}function Pe(e,t,n,i){if(!e._sdf)return;let o;const r=n[re.sdf],a=i.outlineColor,s=i.outlineWidth,c=l.A.floatToByte(a.red),h=l.A.floatToByte(a.green),u=l.A.floatToByte(a.blue),d=c*ye+h*be+u,p=s/M.A.RADIUS,m=l.A.floatToByte(a.alpha)*ye+l.A.floatToByte(p)*be;e._instanced?(o=i._index,r(o,d,m)):(o=4*i._index,r(o+0,d+0,m),r(o+1,d+2,m),r(o+2,d+3,m),r(o+3,d+1,m))}function Re(e,t,n,i){const o=n[re.splitDirection];let r=0;const a=i.splitDirection;let s;(0,d.A)(a)&&(r=a),e._instanced?(s=i._index,o(s,r)):(s=4*i._index,o(s+0,r),o(s+1,r),o(s+2,r),o(s+3,r))}function Ne(e,t,n,i){Ae(e,0,n,i),xe(e,0,n,i),Ce(e,0,n,i),Ee(e,t,n,i),Se(e,0,n,i),De(e,0,n,i),Oe(e,0,n,i),ze(e,t,n,i),Ie(e,t,n,i),function(e,t,n,i){if(!(0,d.A)(e._batchTable))return;const o=n[re.a_batchId],r=i._batchIndex;let a;e._instanced?(a=i._index,o(a,r)):(a=4*i._index,o(a+0,r),o(a+1,r),o(a+2,r),o(a+3,r))}(e,0,n,i),Pe(e,0,n,i),Re(e,0,n,i)}function Le(e,t,n,i,o,a){let s;i.mode===L.A.SCENE3D?(s=e._baseVolume,e._boundingVolumeDirty=!0):s=e._baseVolume2D;const c=[];for(let e=0;e<n;++e){const n=t[e],l=n.position,h=z.A._computeActualPosition(n,l,i,o);(0,d.A)(h)&&(n._setActualPosition(h),a?c.push(h):r.A.expand(s,h,s))}a&&r.A.fromPoints(c,s)}const Me=[];ce.prototype.update=function(e){if(he(this),!this.show)return;const t=e.context;this._instanced=t.instancedArrays,re=this._instanced?se:ae,ue=this._instanced?pe:de;let n=this._billboards,i=n.length,o=!0;for(let e=0;e<i;++e){const t=n[e];(0,d.A)(t.loadError)&&(console.error(`Error loading image for billboard: ${t.loadError}`),t.image=void 0),t.textureDirty&&this._updateBillboard(t,j),t.show&&(o=o&&t.ready)}const a=this._textureAtlas;if(e.afterRender.push(()=>{if(!this.isDestroyed())return a.update(e.context)}),!(0,d.A)(a.texture))return;!function(e,t){const n=t.mode,i=e._billboards,o=e._billboardsToUpdate,r=e._modelMatrix;e._createVertexArray||e._mode!==n||n!==L.A.SCENE3D&&!_.A.equals(r,e.modelMatrix)?(e._mode=n,_.A.clone(e.modelMatrix,r),e._createVertexArray=!0,n!==L.A.SCENE3D&&n!==L.A.SCENE2D&&n!==L.A.COLUMBUS_VIEW||Le(e,i,i.length,t,r,!0)):n===L.A.MORPHING?Le(e,i,i.length,t,r,!0):n!==L.A.SCENE2D&&n!==L.A.COLUMBUS_VIEW||Le(e,o,e._billboardsToUpdateIndex,t,r,!1)}(this,e),n=this._billboards,i=n.length;const s=this._billboardsToUpdate,c=this._billboardsToUpdateIndex,l=this._propertiesChanged,u=a.guid,p=this._createVertexArray||this._textureAtlasGUID!==u;let m;this._textureAtlasGUID=u;const f=e.passes,A=f.pick;if(p||!A&&this.computeNewBuffersUsage()){this._createVertexArray=!1;for(let e=0;e<oe;++e)l[e]=0;if(this._vaf=this._vaf&&this._vaf.destroy(),i>0){this._vaf=function(e,t,n,i,o,r){const a=[{index:re.positionHighAndScale,componentsPerAttribute:4,componentDatatype:h.A.FLOAT,usage:n[V]},{index:re.positionLowAndRotation,componentsPerAttribute:4,componentDatatype:h.A.FLOAT,usage:n[V]},{index:re.compressedAttribute0,componentsPerAttribute:4,componentDatatype:h.A.FLOAT,usage:n[G]},{index:re.compressedAttribute1,componentsPerAttribute:4,componentDatatype:h.A.FLOAT,usage:n[K]},{index:re.compressedAttribute2,componentsPerAttribute:4,componentDatatype:h.A.FLOAT,usage:n[Y]},{index:re.eyeOffset,componentsPerAttribute:4,componentDatatype:h.A.FLOAT,usage:n[H]},{index:re.scaleByDistance,componentsPerAttribute:4,componentDatatype:h.A.FLOAT,usage:n[Z]},{index:re.pixelOffsetScaleByDistance,componentsPerAttribute:4,componentDatatype:h.A.FLOAT,usage:n[Q]},{index:re.compressedAttribute3,componentsPerAttribute:4,componentDatatype:h.A.FLOAT,usage:n[J]},{index:re.textureCoordinateBoundsOrLabelTranslate,componentsPerAttribute:4,componentDatatype:h.A.FLOAT,usage:n[te]},{index:re.splitDirection,componentsPerAttribute:1,componentDatatype:h.A.FLOAT,usage:n[ie]}];i&&a.push({index:re.direction,componentsPerAttribute:2,componentDatatype:h.A.FLOAT,vertexBuffer:me(e)}),(0,d.A)(o)&&a.push({index:re.a_batchId,componentsPerAttribute:1,componentDatatype:h.A.FLOAT,bufferUsage:v.A.STATIC_DRAW}),r&&a.push({index:re.sdf,componentsPerAttribute:2,componentDatatype:h.A.FLOAT,usage:n[ne]});const s=i?t:4*t;return new S.A(e,a,s,i)}(t,i,this._buffersUsage,this._instanced,this._batchTable,this._sdf),m=this._vaf.writers;for(let t=0;t<i;++t){const n=this._billboards[t];n._dirty=!1,n.textureDirty=!1,Ne(this,e,m,n)}this._vaf.commit(ue(t))}this._billboardsToUpdateIndex=0}else if(c>0){const n=Me;n.length=0,(l[V]||l[X]||l[q])&&n.push(Ae),(l[j]||l[G]||l[U]||l[W]||l[k])&&(n.push(xe),this._instanced&&n.push(Se)),(l[j]||l[$]||l[K])&&(n.push(Ce),n.push(Ee)),(l[j]||l[Y])&&n.push(Ee),(l[j]||l[H])&&n.push(Se),l[Z]&&n.push(De),l[Q]&&n.push(Oe),(l[J]||l[ee]||l[j]||l[V])&&n.push(ze),(l[j]||l[V])&&n.push(Ie),l[ne]&&n.push(Pe),l[ie]&&n.push(Re);const o=n.length;if(m=this._vaf.writers,c/i>.1){for(let t=0;t<c;++t){const i=s[t];i._dirty=!1,i.textureDirty=!1;for(let t=0;t<o;++t)n[t](this,e,m,i)}this._vaf.commit(ue(t))}else{for(let t=0;t<c;++t){const i=s[t];i._dirty=!1,i.textureDirty=!1;for(let t=0;t<o;++t)n[t](this,e,m,i);this._instanced?this._vaf.subCommit(i._index,1):this._vaf.subCommit(4*i._index,4)}this._vaf.endSubCommits()}this._billboardsToUpdateIndex=0}if(c>1.5*i&&(s.length=i),!(0,d.A)(this._vaf)||!(0,d.A)(this._vaf.va))return;let y;this._boundingVolumeDirty&&(this._boundingVolumeDirty=!1,r.A.transform(this._baseVolume,this.modelMatrix,this._baseVolumeWC));let z=_.A.IDENTITY;e.mode===L.A.SCENE3D?(z=this.modelMatrix,y=r.A.clone(this._baseVolumeWC,this._boundingVolume)):y=r.A.clone(this._baseVolume2D,this._boundingVolume),function(e,t,n){let i=1;e._allSizedInMeters&&0===e._maxPixelOffset||(i=t.camera.getPixelSize(n,t.context.drawingBufferWidth,t.context.drawingBufferHeight));let o=i*e._maxScale*e._maxSize*2;e._allHorizontalCenter&&e._allVerticalCenter&&(o*=.5);const r=i*e._maxPixelOffset+e._maxEyeOffset;n.radius+=o+r}(this,e,y);const R=this._blendOption!==this.blendOption;if(this._blendOption=this.blendOption,R){this._blendOption===P.A.OPAQUE||this._blendOption===P.A.OPAQUE_AND_TRANSLUCENT?this._rsOpaque=x.A.fromCache({depthTest:{enabled:!0,func:g.A.LESS},depthMask:!0}):this._rsOpaque=void 0;const e=this._blendOption===P.A.TRANSLUCENT;this._blendOption===P.A.TRANSLUCENT||this._blendOption===P.A.OPAQUE_AND_TRANSLUCENT?this._rsTranslucent=x.A.fromCache({depthTest:{enabled:!0,func:e?g.A.LEQUAL:g.A.LESS},depthMask:e,blending:I.A.ALPHA_BLEND}):this._rsTranslucent=void 0}let N,F,B,ce,le;this._shaderDisableDepthDistance=this._shaderDisableDepthDistance||0!==e.minimumDisableDepthTestDistance;const fe=b.A.maximumVertexTextureImageUnits>0;if(R||this._shaderRotation!==this._compiledShaderRotation||this._shaderAlignedAxis!==this._compiledShaderAlignedAxis||this._shaderScaleByDistance!==this._compiledShaderScaleByDistance||this._shaderTranslucencyByDistance!==this._compiledShaderTranslucencyByDistance||this._shaderPixelOffsetScaleByDistance!==this._compiledShaderPixelOffsetScaleByDistance||this._shaderDistanceDisplayCondition!==this._compiledShaderDistanceDisplayCondition||this._shaderDisableDepthDistance!==this._compiledShaderDisableDepthDistance||this._shaderClampToGround!==this._compiledShaderClampToGround||this._sdf!==this._compiledSDF){N=O.A,F=D.A,le=[],(0,d.A)(this._batchTable)&&(le.push("VECTOR_TILE"),N=this._batchTable.getVertexShaderCallback(!1,"a_batchId",void 0)(N),F=this._batchTable.getFragmentShaderCallback(!1,void 0)(F)),B=new E.A({defines:le,sources:[N]}),this._instanced&&B.defines.push("INSTANCED"),this._shaderRotation&&B.defines.push("ROTATION"),this._shaderAlignedAxis&&B.defines.push("ALIGNED_AXIS"),this._shaderScaleByDistance&&B.defines.push("EYE_DISTANCE_SCALING"),this._shaderTranslucencyByDistance&&B.defines.push("EYE_DISTANCE_TRANSLUCENCY"),this._shaderPixelOffsetScaleByDistance&&B.defines.push("EYE_DISTANCE_PIXEL_OFFSET"),this._shaderDistanceDisplayCondition&&B.defines.push("DISTANCE_DISPLAY_CONDITION"),this._shaderDisableDepthDistance&&B.defines.push("DISABLE_DEPTH_DISTANCE"),this._shaderClampToGround&&(fe?B.defines.push("VERTEX_DEPTH_CHECK"):B.defines.push("FRAGMENT_DEPTH_CHECK"));const e=1-M.A.CUTOFF;this._sdf&&B.defines.push("SDF");const n=(0,d.A)(this._batchTable)?"VECTOR_TILE":"";this._blendOption===P.A.OPAQUE_AND_TRANSLUCENT&&(ce=new E.A({defines:["OPAQUE",n],sources:[F]}),this._shaderClampToGround&&(fe?ce.defines.push("VERTEX_DEPTH_CHECK"):ce.defines.push("FRAGMENT_DEPTH_CHECK")),this._sdf&&(ce.defines.push("SDF"),ce.defines.push(`SDF_EDGE ${e}`)),this._sp=C.A.replaceCache({context:t,shaderProgram:this._sp,vertexShaderSource:B,fragmentShaderSource:ce,attributeLocations:re}),ce=new E.A({defines:["TRANSLUCENT",n],sources:[F]}),this._shaderClampToGround&&(fe?ce.defines.push("VERTEX_DEPTH_CHECK"):ce.defines.push("FRAGMENT_DEPTH_CHECK")),this._sdf&&(ce.defines.push("SDF"),ce.defines.push(`SDF_EDGE ${e}`)),this._spTranslucent=C.A.replaceCache({context:t,shaderProgram:this._spTranslucent,vertexShaderSource:B,fragmentShaderSource:ce,attributeLocations:re})),this._blendOption===P.A.OPAQUE&&(ce=new E.A({defines:[n],sources:[F]}),this._shaderClampToGround&&(fe?ce.defines.push("VERTEX_DEPTH_CHECK"):ce.defines.push("FRAGMENT_DEPTH_CHECK")),this._sdf&&(ce.defines.push("SDF"),ce.defines.push(`SDF_EDGE ${e}`)),this._sp=C.A.replaceCache({context:t,shaderProgram:this._sp,vertexShaderSource:B,fragmentShaderSource:ce,attributeLocations:re})),this._blendOption===P.A.TRANSLUCENT&&(ce=new E.A({defines:[n],sources:[F]}),this._shaderClampToGround&&(fe?ce.defines.push("VERTEX_DEPTH_CHECK"):ce.defines.push("FRAGMENT_DEPTH_CHECK")),this._sdf&&(ce.defines.push("SDF"),ce.defines.push(`SDF_EDGE ${e}`)),this._spTranslucent=C.A.replaceCache({context:t,shaderProgram:this._spTranslucent,vertexShaderSource:B,fragmentShaderSource:ce,attributeLocations:re})),this._compiledShaderRotation=this._shaderRotation,this._compiledShaderAlignedAxis=this._shaderAlignedAxis,this._compiledShaderScaleByDistance=this._shaderScaleByDistance,this._compiledShaderTranslucencyByDistance=this._shaderTranslucencyByDistance,this._compiledShaderPixelOffsetScaleByDistance=this._shaderPixelOffsetScaleByDistance,this._compiledShaderDistanceDisplayCondition=this._shaderDistanceDisplayCondition,this._compiledShaderDisableDepthDistance=this._shaderDisableDepthDistance,this._compiledShaderClampToGround=this._shaderClampToGround,this._compiledSDF=this._sdf}const _e=e.commandList;if(f.render||f.pick){const t=this._colorCommands,n=this._blendOption===P.A.OPAQUE,o=this._blendOption===P.A.OPAQUE_AND_TRANSLUCENT,r=this._vaf.va,a=r.length;let s,c=this._uniforms;(0,d.A)(this._batchTable)?(c=this._batchTable.getUniformMapCallback()(c),s=this._batchTable.getPickId()):s="v_pickColor",t.length=a;const l=o?2*a:a;for(let e=0;e<l;++e){let a=t[e];(0,d.A)(a)||(a=t[e]=new w.A);const l=n||o&&e%2==0;a.pass=l||!o?T.A.OPAQUE:T.A.TRANSLUCENT,a.owner=this;const h=o?Math.floor(e/2):e;a.boundingVolume=y,a.modelMatrix=z,a.count=r[h].indicesCount,a.shaderProgram=l?this._sp:this._spTranslucent,a.uniformMap=c,a.vertexArray=r[h].va,a.renderState=l?this._rsOpaque:this._rsTranslucent,a.debugShowBoundingVolume=this.debugShowBoundingVolume,a.pickId=s,this._instanced&&(a.count=6,a.instanceCount=i),_e.push(a)}this.debugShowTextureAtlas&&((0,d.A)(this.debugCommand)||(this.debugCommand=function(e,t){const n=t.createViewportQuadCommand("uniform sampler2D billboard_texture; \nin vec2 v_textureCoordinates; \nvoid main() \n{ \n    out_FragColor = texture(billboard_texture, v_textureCoordinates); \n} \n",{uniformMap:{billboard_texture:function(){return e.textureAtlas.texture}}});return n.pass=T.A.OVERLAY,n}(this,e.context)),_e.push(this.debugCommand))}this._allBillboardsReady=o},ce.prototype.isDestroyed=function(){return!1},ce.prototype.destroy=function(){return(0,d.A)(this._removeCallbackFunc)&&(this._removeCallbackFunc(),this._removeCallbackFunc=void 0),this._textureAtlas=this._destroyTextureAtlas&&this._textureAtlas&&this._textureAtlas.destroy(),this._sp=this._sp&&this._sp.destroy(),this._spTranslucent=this._spTranslucent&&this._spTranslucent.destroy(),this._vaf=this._vaf&&this._vaf.destroy(),le(this._billboards),(0,p.A)(this)};const Fe=ce},734814:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i=Object.freeze({NONE:0,LOADING:2,LOADED:3,ERROR:4,FAILED:5})},208836:(e,t,n)=>{"use strict";n.d(t,{A:()=>s});var i=n(369031),o=n(491446),r=n(734814);function a(e){i.A.defined("billboardCollection",e),this._billboardCollection=e,this._id=void 0,this._loadState=r.A.NONE,this._loadError=void 0,this._index=-1,this._width=void 0,this._height=void 0,this._hasSubregion=!1,this.dirty=!1}Object.defineProperties(a.prototype,{loadError:{get:function(){return this._loadError}},loadState:{get:function(){return this._loadState}},ready:{get:function(){return this._loadState===r.A.LOADED}},hasImage:{get:function(){return this._loadState!==r.A.NONE}},id:{get:function(){return this._id}},width:{get:function(){return this._width}},height:{get:function(){return this._height}}}),a.prototype.unload=async function(){this._loadState!==r.A.NONE&&(this._id=void 0,this._loadError=void 0,this._loadState=r.A.NONE,this._index=-1,this._width=void 0,this._height=void 0,this.dirty=!0)},a.prototype.loadImage=async function(e,t){if(this._id===e)return;const n=this._billboardCollection,i=n.billboardTextureCache;let s,c=i.get(e);if((0,o.A)(c)&&t.loadState===r.A.LOADING||t.loadState===r.A.LOADED)return void a.clone(c,this);(0,o.A)(c)||(c=new a(n),i.set(e,c)),c._id=this._id=e,c._loadState=this._loadState=r.A.LOADING,c._loadError=this._loadError=void 0;const l=this._billboardCollection.textureAtlas;try{s=await l.addImage(e,t)}catch(t){if(c._loadState=r.A.ERROR,c._loadError=t,this._id!==e)return;return this._loadState=r.A.ERROR,void(this._loadError=t)}if(!(0,o.A)(s)||-1===s){if(c._loadState=r.A.FAILED,c._index=-1,this._id!==e)return;return this._loadState=r.A.FAILED,void(this._index=-1)}c._index=s,c._loadState=r.A.LOADED;const h=l.rectangles[s];c._width=h.width,c._height=h.height,this._id===e&&(this._index=s,this._loadState=r.A.LOADED,this._width=h.width,this._height=h.height,this.dirty=!0)},a.prototype.addImageSubRegion=async function(e,t){let n;this._id=e,this._loadState=r.A.LOADING,this._loadError=void 0,this._hasSubregion=!0;const i=this._billboardCollection.textureAtlas;try{n=await i.addImageSubRegion(e,t)}catch(e){return this._loadState=r.A.ERROR,void(this._loadError=e)}if(!(0,o.A)(n)||-1===n)return this._loadState=r.A.FAILED,this._index=-1,this._width=void 0,void(this._height=void 0);this._width=t.width,this._height=t.height,this._index=n,this._loadState=r.A.LOADED,this.dirty=!0},a.prototype.computeTextureCoordinates=function(e){return this._billboardCollection.textureAtlas.computeTextureCoordinates(this._index,e)},a.clone=function(e,t){if(t._id=e._id,t._loadState=e._loadState,t._loadError=void 0,t._index=e._index,t._width=e._width,t._height=e._height,t._hasSubregion=e._hasSubregion,!e.ready)return(async()=>{const n=e._id,i=e._billboardCollection.textureAtlas;await i._indexPromiseById.get(n),t._id===n&&(e._hasSubregion&&await Promise.resolve(),t._id=n,t._loadState=e._loadState,t._loadError=e._loadError,t._index=e._index,t._width=e._width,t._height=e._height,t.dirty=!0)})(),t;t.dirty=!0};const s=a},620297:(e,t,n)=>{"use strict";n.d(t,{A:()=>r});var i=n(352581);const o={ADD:i.A.FUNC_ADD,SUBTRACT:i.A.FUNC_SUBTRACT,REVERSE_SUBTRACT:i.A.FUNC_REVERSE_SUBTRACT,MIN:i.A.MIN,MAX:i.A.MAX},r=Object.freeze(o)},443383:(e,t,n)=>{"use strict";n.d(t,{A:()=>r});var i=n(352581);const o={ZERO:i.A.ZERO,ONE:i.A.ONE,SOURCE_COLOR:i.A.SRC_COLOR,ONE_MINUS_SOURCE_COLOR:i.A.ONE_MINUS_SRC_COLOR,DESTINATION_COLOR:i.A.DST_COLOR,ONE_MINUS_DESTINATION_COLOR:i.A.ONE_MINUS_DST_COLOR,SOURCE_ALPHA:i.A.SRC_ALPHA,ONE_MINUS_SOURCE_ALPHA:i.A.ONE_MINUS_SRC_ALPHA,DESTINATION_ALPHA:i.A.DST_ALPHA,ONE_MINUS_DESTINATION_ALPHA:i.A.ONE_MINUS_DST_ALPHA,CONSTANT_COLOR:i.A.CONSTANT_COLOR,ONE_MINUS_CONSTANT_COLOR:i.A.ONE_MINUS_CONSTANT_COLOR,CONSTANT_ALPHA:i.A.CONSTANT_ALPHA,ONE_MINUS_CONSTANT_ALPHA:i.A.ONE_MINUS_CONSTANT_ALPHA,SOURCE_ALPHA_SATURATE:i.A.SRC_ALPHA_SATURATE},r=Object.freeze(o)},416882:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i=Object.freeze({OPAQUE:0,TRANSLUCENT:1,OPAQUE_AND_TRANSLUCENT:2})},200646:(e,t,n)=>{"use strict";n.d(t,{A:()=>a});var i=n(620297),o=n(443383);const r={DISABLED:Object.freeze({enabled:!1}),ALPHA_BLEND:Object.freeze({enabled:!0,equationRgb:i.A.ADD,equationAlpha:i.A.ADD,functionSourceRgb:o.A.SOURCE_ALPHA,functionSourceAlpha:o.A.ONE,functionDestinationRgb:o.A.ONE_MINUS_SOURCE_ALPHA,functionDestinationAlpha:o.A.ONE_MINUS_SOURCE_ALPHA}),PRE_MULTIPLIED_ALPHA_BLEND:Object.freeze({enabled:!0,equationRgb:i.A.ADD,equationAlpha:i.A.ADD,functionSourceRgb:o.A.ONE,functionSourceAlpha:o.A.ONE,functionDestinationRgb:o.A.ONE_MINUS_SOURCE_ALPHA,functionDestinationAlpha:o.A.ONE_MINUS_SOURCE_ALPHA}),ADDITIVE_BLEND:Object.freeze({enabled:!0,equationRgb:i.A.ADD,equationAlpha:i.A.ADD,functionSourceRgb:o.A.SOURCE_ALPHA,functionSourceAlpha:o.A.ONE,functionDestinationRgb:o.A.ONE,functionDestinationAlpha:o.A.ONE})},a=Object.freeze(r)},627853:(e,t,n)=>{"use strict";n.d(t,{A:()=>N});var i=n(433235),o=n(430346),r=n(915325),a=n(491446),s=n(677354),c=n(605971),l=n(75200),h=n(377496),u=n(760866),d=n(40118),p=n(302836),m=n(342875),f=n(753543),A=n(488961),_=n(200646),g=n(71578),y=n(523721),v=n(612123),b=n(842153),w=n(62467),T=n(395250),x=n(938987),C=n(896464),E=n(138151);function S(e){const t=(e=e??r.A.EMPTY_OBJECT).geometryInstances;this.geometryInstances=t,this.show=e.show??!0,this.classificationType=e.classificationType??g.A.BOTH,this.debugShowBoundingVolume=e.debugShowBoundingVolume??!1,this.debugShowShadowVolume=e.debugShowShadowVolume??!1,this._debugShowShadowVolume=!1,this._extruded=e._extruded??!1,this._uniformMap=e._uniformMap,this._sp=void 0,this._spStencil=void 0,this._spPick=void 0,this._spColor=void 0,this._spPick2D=void 0,this._spColor2D=void 0,this._rsStencilDepthPass=void 0,this._rsStencilDepthPass3DTiles=void 0,this._rsColorPass=void 0,this._rsPickPass=void 0,this._commandsIgnoreShow=[],this._ready=!1,this._primitive=void 0,this._pickPrimitive=e._pickPrimitive,this._hasSphericalExtentsAttribute=!1,this._hasPlanarExtentsAttributes=!1,this._hasPerColorAttribute=!1,this.appearance=e.appearance,this._createBoundingVolumeFunction=e._createBoundingVolumeFunction,this._updateAndQueueCommandsFunction=e._updateAndQueueCommandsFunction,this._usePickOffsets=!1,this._primitiveOptions={geometryInstances:void 0,appearance:void 0,vertexCacheOptimize:e.vertexCacheOptimize??!1,interleave:e.interleave??!1,releaseGeometryInstances:e.releaseGeometryInstances??!0,allowPicking:e.allowPicking??!0,asynchronous:e.asynchronous??!0,compressVertices:e.compressVertices??!0,_createBoundingVolumeFunction:void 0,_createRenderStatesFunction:void 0,_createShaderProgramFunction:void 0,_createCommandsFunction:void 0,_updateAndQueueCommandsFunction:void 0,_createPickOffsets:!0}}function D(e,t){const n=t?C.A.EQUAL:C.A.ALWAYS;return{colorMask:{red:!1,green:!1,blue:!1,alpha:!1},stencilTest:{enabled:e,frontFunction:n,frontOperation:{fail:E.A.KEEP,zFail:E.A.DECREMENT_WRAP,zPass:E.A.KEEP},backFunction:n,backOperation:{fail:E.A.KEEP,zFail:E.A.INCREMENT_WRAP,zPass:E.A.KEEP},reference:x.A.CESIUM_3D_TILE_MASK,mask:x.A.CESIUM_3D_TILE_MASK},stencilMask:x.A.CLASSIFICATION_MASK,depthTest:{enabled:!0,func:y.A.LESS_OR_EQUAL},depthMask:!1}}function O(e){return{stencilTest:{enabled:e,frontFunction:C.A.NOT_EQUAL,frontOperation:{fail:E.A.ZERO,zFail:E.A.ZERO,zPass:E.A.ZERO},backFunction:C.A.NOT_EQUAL,backOperation:{fail:E.A.ZERO,zFail:E.A.ZERO,zPass:E.A.ZERO},reference:0,mask:x.A.CLASSIFICATION_MASK},stencilMask:x.A.CLASSIFICATION_MASK,depthTest:{enabled:!1},depthMask:!1,blending:_.A.PRE_MULTIPLIED_ALPHA_BLEND}}Object.defineProperties(S.prototype,{vertexCacheOptimize:{get:function(){return this._primitiveOptions.vertexCacheOptimize}},interleave:{get:function(){return this._primitiveOptions.interleave}},releaseGeometryInstances:{get:function(){return this._primitiveOptions.releaseGeometryInstances}},allowPicking:{get:function(){return this._primitiveOptions.allowPicking}},asynchronous:{get:function(){return this._primitiveOptions.asynchronous}},compressVertices:{get:function(){return this._primitiveOptions.compressVertices}},ready:{get:function(){return this._ready}},_needs2DShader:{get:function(){return this._hasPlanarExtentsAttributes||this._hasSphericalExtentsAttribute}}}),S.isSupported=function(e){return e.context.stencilBuffer};const z={stencilTest:{enabled:!0,frontFunction:C.A.NOT_EQUAL,frontOperation:{fail:E.A.ZERO,zFail:E.A.ZERO,zPass:E.A.ZERO},backFunction:C.A.NOT_EQUAL,backOperation:{fail:E.A.ZERO,zFail:E.A.ZERO,zPass:E.A.ZERO},reference:0,mask:x.A.CLASSIFICATION_MASK},stencilMask:x.A.CLASSIFICATION_MASK,depthTest:{enabled:!1},depthMask:!1};function I(e,t){return Math.floor(e%t/2)}function P(e,t,n,i,o,r){e.modelMatrix=n,e.boundingVolume=o,e.cull=i,e.debugShowBoundingVolume=r,t.commandList.push(e)}function R(e,t,n,i,o){e.modelMatrix=n,e.boundingVolume=o,e.cull=i,t.commandList.push(e)}S.prototype.update=function(e){if(!(0,a.A)(this._primitive)&&!(0,a.A)(this.geometryInstances))return;let t=this.appearance;(0,a.A)(t)&&(0,a.A)(t.material)&&t.material.update(e.context);const n=this,r=this._primitiveOptions;if(!(0,a.A)(this._primitive)){const e=Array.isArray(this.geometryInstances)?this.geometryInstances:[this.geometryInstances],s=e.length;let _,y,x,C,E=!1,S=!0,N=!1,L=!1;for(s>0&&(x=e[0].attributes,N=T.A.hasAttributesForSphericalExtents(x),L=T.A.hasAttributesForTextureCoordinatePlanes(x),C=x.color),_=0;_<s;_++){y=e[_];const t=y.attributes.color;if((0,a.A)(t))E=!0;else if(E)throw new c.A("All GeometryInstances must have color attributes to use per-instance color.");S=S&&(0,a.A)(t)&&i.A.equals(C,t)}if(!S&&!N&&!L)throw new c.A("All GeometryInstances must have the same color attribute except via GroundPrimitives");if(E&&!(0,a.A)(t)&&(t=new v.A({flat:!0}),this.appearance=t),!E&&t instanceof v.A)throw new c.A("PerInstanceColorAppearance requires color GeometryInstanceAttributes on all GeometryInstances");if((0,a.A)(t.material)&&!N&&!L)throw new c.A("Materials on ClassificationPrimitives are not supported except via GroundPrimitives");this._usePickOffsets=!N&&!L,this._hasSphericalExtentsAttribute=N,this._hasPlanarExtentsAttributes=L,this._hasPerColorAttribute=E;const M=new Array(s);for(_=0;_<s;++_)y=e[_],M[_]=new l.A({geometry:y.geometry,attributes:y.attributes,modelMatrix:y.modelMatrix,id:y.id,pickPrimitive:this._pickPrimitive??n});r.appearance=t,r.geometryInstances=M,(0,a.A)(this._createBoundingVolumeFunction)&&(r._createBoundingVolumeFunction=function(e,t){n._createBoundingVolumeFunction(e,t)}),r._createRenderStatesFunction=function(e,t,i,o){!function(e){if((0,a.A)(e._rsStencilDepthPass))return;const t=!e.debugShowShadowVolume;e._rsStencilDepthPass=d.A.fromCache(D(t,!1)),e._rsStencilDepthPass3DTiles=d.A.fromCache(D(t,!0)),e._rsColorPass=d.A.fromCache(O(t)),e._rsPickPass=d.A.fromCache(z)}(n)},r._createShaderProgramFunction=function(e,t,i){!function(e,t){const n=t.context,i=e._primitive;let o=f.A;o=e._primitive._batchTable.getVertexShaderCallback()(o),o=b.A._appendDistanceDisplayConditionToShader(i,o),o=b.A._modifyShaderPosition(e,o,t.scene3DOnly),o=b.A._updateColorAttribute(i,o);const r=e._hasPlanarExtentsAttributes,s=r||e._hasSphericalExtentsAttribute;e._extruded&&(o=function(e,t){if(!e.compressVertices)return t;if(-1!==t.search(/in\s+vec3\s+extrudeDirection;/g)){const e="compressedAttributes",n=`in vec2 ${e};`,i="vec3 extrudeDirection;\n",o=`    extrudeDirection = czm_octDecode(${e}, 65535.0);\n`;let r=t;return r=r.replace(/in\s+vec3\s+extrudeDirection;/g,""),r=m.A.replaceMain(r,"czm_non_compressed_main"),[n,i,r,`void main() \n{ \n${o}    czm_non_compressed_main(); \n}`].join("\n")}}(i,o));const c=e._extruded?"EXTRUDED_GEOMETRY":"";let l=new m.A({defines:[c],sources:[o]});const h=new m.A({sources:[A.A]}),u=e._primitive._attributeLocations,d=new T.A(s,r,e.appearance);if(e._spStencil=p.A.replaceCache({context:n,shaderProgram:e._spStencil,vertexShaderSource:l,fragmentShaderSource:h,attributeLocations:u}),e._primitive.allowPicking){let r=m.A.createPickVertexShaderSource(o);r=b.A._appendShowToShader(i,r),r=b.A._updatePickColorAttribute(r);const l=d.createPickFragmentShader(!1),h=d.createPickVertexShader([c],r,!1,t.mapProjection);if(e._spPick=p.A.replaceCache({context:n,shaderProgram:e._spPick,vertexShaderSource:h,fragmentShaderSource:l,attributeLocations:u}),s){let i=n.shaderCache.getDerivedShaderProgram(e._spPick,"2dPick");if(!(0,a.A)(i)){const o=d.createPickFragmentShader(!0),a=d.createPickVertexShader([c],r,!0,t.mapProjection);i=n.shaderCache.createDerivedShaderProgram(e._spPick,"2dPick",{vertexShaderSource:a,fragmentShaderSource:o,attributeLocations:u})}e._spPick2D=i}}else e._spPick=p.A.fromCache({context:n,vertexShaderSource:l,fragmentShaderSource:h,attributeLocations:u});o=b.A._appendShowToShader(i,o),l=new m.A({defines:[c],sources:[o]}),e._sp=p.A.replaceCache({context:n,shaderProgram:e._sp,vertexShaderSource:l,fragmentShaderSource:h,attributeLocations:u});const _=d.createFragmentShader(!1),g=d.createVertexShader([c],o,!1,t.mapProjection);if(e._spColor=p.A.replaceCache({context:n,shaderProgram:e._spColor,vertexShaderSource:g,fragmentShaderSource:_,attributeLocations:u}),s){let i=n.shaderCache.getDerivedShaderProgram(e._spColor,"2dColor");if(!(0,a.A)(i)){const r=d.createFragmentShader(!0),a=d.createVertexShader([c],o,!0,t.mapProjection);i=n.shaderCache.createDerivedShaderProgram(e._spColor,"2dColor",{vertexShaderSource:a,fragmentShaderSource:r,attributeLocations:u})}e._spColor2D=i}}(n,t)},r._createCommandsFunction=function(e,t,i,r,s,c,l){!function(e,t,n,i,r,s,c){!function(e,t){const n=e._primitive;let i,r,s,c=2*n._va.length;t.length=c;let l=0,d=n._batchTable.getUniformMapCallback()(e._uniformMap);const p=e._needs2DShader;for(i=0;i<c;i+=2){const c=n._va[l++];r=t[i],(0,a.A)(r)||(r=t[i]=new h.A({owner:e,primitiveType:n._primitiveType})),r.vertexArray=c,r.renderState=e._rsStencilDepthPass,r.shaderProgram=e._sp,r.uniformMap=d,r.pass=u.A.TERRAIN_CLASSIFICATION,s=h.A.shallowClone(r,r.derivedCommands.tileset),s.renderState=e._rsStencilDepthPass3DTiles,s.pass=u.A.CESIUM_3D_TILE_CLASSIFICATION,r.derivedCommands.tileset=s,r=t[i+1],(0,a.A)(r)||(r=t[i+1]=new h.A({owner:e,primitiveType:n._primitiveType})),r.vertexArray=c,r.renderState=e._rsColorPass,r.shaderProgram=e._spColor,r.pass=u.A.TERRAIN_CLASSIFICATION;const m=e.appearance.material;if((0,a.A)(m)&&(d=(0,o.A)(d,m._uniforms)),r.uniformMap=d,s=h.A.shallowClone(r,r.derivedCommands.tileset),s.pass=u.A.CESIUM_3D_TILE_CLASSIFICATION,r.derivedCommands.tileset=s,p){let t=h.A.shallowClone(r,r.derivedCommands.appearance2D);t.shaderProgram=e._spColor2D,r.derivedCommands.appearance2D=t,t=h.A.shallowClone(s,s.derivedCommands.appearance2D),t.shaderProgram=e._spColor2D,s.derivedCommands.appearance2D=t}}const m=e._commandsIgnoreShow,f=e._spStencil;let A=0;c=m.length=c/2;for(let e=0;e<c;++e){const n=m[e]=h.A.shallowClone(t[A],m[e]);n.shaderProgram=f,n.pass=u.A.CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW,A+=2}}(e,s),function(e,t){const n=e._usePickOffsets,i=e._primitive;let o,r,s,c,l,d=2*i._va.length,p=0;n&&(o=i._pickOffsets,d=2*o.length),t.length=d;let m=0;const f=i._batchTable.getUniformMapCallback()(e._uniformMap),A=e._needs2DShader;for(s=0;s<d;s+=2){let d=i._va[m++];if(n&&(r=o[p++],d=i._va[r.index]),c=t[s],(0,a.A)(c)||(c=t[s]=new h.A({owner:e,primitiveType:i._primitiveType,pickOnly:!0})),c.vertexArray=d,c.renderState=e._rsStencilDepthPass,c.shaderProgram=e._sp,c.uniformMap=f,c.pass=u.A.TERRAIN_CLASSIFICATION,n&&(c.offset=r.offset,c.count=r.count),l=h.A.shallowClone(c,c.derivedCommands.tileset),l.renderState=e._rsStencilDepthPass3DTiles,l.pass=u.A.CESIUM_3D_TILE_CLASSIFICATION,c.derivedCommands.tileset=l,c=t[s+1],(0,a.A)(c)||(c=t[s+1]=new h.A({owner:e,primitiveType:i._primitiveType,pickOnly:!0})),c.vertexArray=d,c.renderState=e._rsPickPass,c.shaderProgram=e._spPick,c.uniformMap=f,c.pass=u.A.TERRAIN_CLASSIFICATION,n&&(c.offset=r.offset,c.count=r.count),l=h.A.shallowClone(c,c.derivedCommands.tileset),l.pass=u.A.CESIUM_3D_TILE_CLASSIFICATION,c.derivedCommands.tileset=l,A){let t=h.A.shallowClone(c,c.derivedCommands.pick2D);t.shaderProgram=e._spPick2D,c.derivedCommands.pick2D=t,t=h.A.shallowClone(l,l.derivedCommands.pick2D),t.shaderProgram=e._spPick2D,l.derivedCommands.pick2D=t}}}(e,c)}(n,0,0,0,0,c,l)},(0,a.A)(this._updateAndQueueCommandsFunction)?r._updateAndQueueCommandsFunction=function(e,t,i,o,r,a,s,c){n._updateAndQueueCommandsFunction(e,t,i,o,r,a,s,c)}:r._updateAndQueueCommandsFunction=function(e,t,i,o,r,s,c,l){!function(e,t,n,i,o,r,s){const c=e._primitive;let l;b.A._updateBoundingVolumes(c,t,o),t.mode===w.A.SCENE3D?l=c._boundingSphereWC:t.mode===w.A.COLUMBUS_VIEW?l=c._boundingSphereCV:t.mode===w.A.SCENE2D&&(0,a.A)(c._boundingSphere2D)?l=c._boundingSphere2D:(0,a.A)(c._boundingSphereMorph)&&(l=c._boundingSphereMorph);const h=e.classificationType,u=h!==g.A.CESIUM_3D_TILE,d=h!==g.A.TERRAIN,p=t.passes;let m,f,A;if(p.render){const i=n.length;for(m=0;m<i;++m)f=l[I(m,i)],u&&(A=n[m],P(A,t,o,r,f,s)),d&&(A=n[m].derivedCommands.tileset,P(A,t,o,r,f,s));if(t.invertClassification){const n=e._commandsIgnoreShow,i=n.length;for(m=0;m<i;++m)f=l[m],A=n[m],P(A,t,o,r,f,s)}}if(p.pick){const e=i.length,n=c._pickOffsets;for(m=0;m<e;++m)f=l[n[I(m,e)].index],u&&(A=i[m],R(A,t,o,r,f)),d&&(A=i[m].derivedCommands.tileset,R(A,t,o,r,f))}}(n,t,i,o,r,s,c)},this._primitive=new b.A(r)}if(this.debugShowShadowVolume&&!this._debugShowShadowVolume&&this._ready?(this._debugShowShadowVolume=!0,this._rsStencilDepthPass=d.A.fromCache(D(!1,!1)),this._rsStencilDepthPass3DTiles=d.A.fromCache(D(!1,!0)),this._rsColorPass=d.A.fromCache(O(!1))):!this.debugShowShadowVolume&&this._debugShowShadowVolume&&(this._debugShowShadowVolume=!1,this._rsStencilDepthPass=d.A.fromCache(D(!0,!1)),this._rsStencilDepthPass3DTiles=d.A.fromCache(D(!0,!0)),this._rsColorPass=d.A.fromCache(O(!0))),this._primitive.appearance!==t){if(!this._hasSphericalExtentsAttribute&&!this._hasPlanarExtentsAttributes&&(0,a.A)(t.material))throw new c.A("Materials on ClassificationPrimitives are not supported except via GroundPrimitive");if(!this._hasPerColorAttribute&&t instanceof v.A)throw new c.A("PerInstanceColorAppearance requires color GeometryInstanceAttribute");this._primitive.appearance=t}this._primitive.show=this.show,this._primitive.debugShowBoundingVolume=this.debugShowBoundingVolume,this._primitive.update(e),e.afterRender.push(()=>{(0,a.A)(this._primitive)&&this._primitive.ready&&(this._ready=!0,this.releaseGeometryInstances&&(this.geometryInstances=void 0))})},S.prototype.getGeometryInstanceAttributes=function(e){if(!(0,a.A)(this._primitive))throw new c.A("must call update before calling getGeometryInstanceAttributes");return this._primitive.getGeometryInstanceAttributes(e)},S.prototype.isDestroyed=function(){return!1},S.prototype.destroy=function(){return this._primitive=this._primitive&&this._primitive.destroy(),this._sp=this._sp&&this._sp.destroy(),this._spPick=this._spPick&&this._spPick.destroy(),this._spColor=this._spColor&&this._spColor.destroy(),this._spPick2D=void 0,this._spColor2D=void 0,(0,s.A)(this)};const N=S},71578:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i=Object.freeze({TERRAIN:0,CESIUM_3D_TILE:1,BOTH:2,NUMBER_OF_CLASSIFICATION_TYPES:3})},527083:(e,t,n)=>{"use strict";n.d(t,{A:()=>r});var i=n(352581);const o={FRONT:i.A.FRONT,BACK:i.A.BACK,FRONT_AND_BACK:i.A.FRONT_AND_BACK},r=Object.freeze(o)},523721:(e,t,n)=>{"use strict";n.d(t,{A:()=>r});var i=n(352581);const o={NEVER:i.A.NEVER,LESS:i.A.LESS,EQUAL:i.A.EQUAL,LESS_OR_EQUAL:i.A.LEQUAL,GREATER:i.A.GREATER,NOT_EQUAL:i.A.NOTEQUAL,GREATER_OR_EQUAL:i.A.GEQUAL,ALWAYS:i.A.ALWAYS},r=Object.freeze(o)},433052:(e,t,n)=>{"use strict";n.d(t,{A:()=>N});var i=n(564886),o=n(571804),r=n(915325),a=n(491446),s=n(677354),c=n(605971),l=n(75200),h=n(494938),u=n(974904),d=n(377496),p=n(760866),m=n(40118),f=n(302836),A=n(342875),_=n(749513),g=n(632577),y=n(700241),v=n(575513),b=n(200646),w=n(71578),T=n(527083),x=n(234957),C=n(920757),E=n(842153),S=n(62467),D=n(938987),O=n(896464),z=n(138151);function I(e){e=e??r.A.EMPTY_OBJECT,this.geometryInstances=e.geometryInstances,this._hasPerInstanceColors=!0;let t=e.appearance;(0,a.A)(t)||(t=new C.A),this.appearance=t,this.show=e.show??!0,this.classificationType=e.classificationType??w.A.BOTH,this.debugShowBoundingVolume=e.debugShowBoundingVolume??!1,this._debugShowShadowVolume=e.debugShowShadowVolume??!1,this._primitiveOptions={geometryInstances:void 0,appearance:void 0,vertexCacheOptimize:!1,interleave:e.interleave??!1,releaseGeometryInstances:e.releaseGeometryInstances??!0,allowPicking:e.allowPicking??!0,asynchronous:e.asynchronous??!0,compressVertices:!1,_createShaderProgramFunction:void 0,_createCommandsFunction:void 0,_updateAndQueueCommandsFunction:void 0},this._zIndex=void 0,this._ready=!1,this._primitive=void 0,this._sp=void 0,this._sp2D=void 0,this._spMorph=void 0,this._renderState=P(!1),this._renderState3DTiles=P(!0),this._renderStateMorph=m.A.fromCache({cull:{enabled:!0,face:T.A.FRONT},depthTest:{enabled:!0},blending:b.A.PRE_MULTIPLIED_ALPHA_BLEND,depthMask:!1})}function P(e){return m.A.fromCache({cull:{enabled:!0},blending:b.A.PRE_MULTIPLIED_ALPHA_BLEND,depthMask:!1,stencilTest:{enabled:e,frontFunction:O.A.EQUAL,frontOperation:{fail:z.A.KEEP,zFail:z.A.KEEP,zPass:z.A.KEEP},backFunction:O.A.EQUAL,backOperation:{fail:z.A.KEEP,zFail:z.A.KEEP,zPass:z.A.KEEP},reference:D.A.CESIUM_3D_TILE_MASK,mask:D.A.CESIUM_3D_TILE_MASK}})}function R(e,t,n,i,o,r,a){n.mode===S.A.MORPHING?t=t.derivedCommands.colorMorph:n.mode!==S.A.SCENE3D&&(t=t.derivedCommands.color2D),t.modelMatrix=i,t.boundingVolume=r,t.cull=o,t.debugShowBoundingVolume=a,n.commandList.push(t)}Object.defineProperties(I.prototype,{interleave:{get:function(){return this._primitiveOptions.interleave}},releaseGeometryInstances:{get:function(){return this._primitiveOptions.releaseGeometryInstances}},allowPicking:{get:function(){return this._primitiveOptions.allowPicking}},asynchronous:{get:function(){return this._primitiveOptions.asynchronous}},ready:{get:function(){return this._ready}},debugShowShadowVolume:{get:function(){return this._debugShowShadowVolume}}}),I.initializeTerrainHeights=function(){return i.A.initialize()},I.prototype.update=function(e){if(!(0,a.A)(this._primitive)&&!(0,a.A)(this.geometryInstances))return;if(!i.A.initialized){if(!this.asynchronous)throw new c.A("For synchronous GroundPolylinePrimitives, you must call GroundPolylinePrimitives.initializeTerrainHeights() and wait for the returned promise to resolve.");return void I.initializeTerrainHeights()}let t;const n=this,r=this._primitiveOptions;if(!(0,a.A)(this._primitive)){const s=Array.isArray(this.geometryInstances)?this.geometryInstances:[this.geometryInstances],c=s.length,m=new Array(c);let b;for(t=0;t<c;++t)if(b=s[t].attributes,!(0,a.A)(b)||!(0,a.A)(b.color)){this._hasPerInstanceColors=!1;break}for(t=0;t<c;++t){const i=s[t];b={};const r=i.attributes;for(const e in r)r.hasOwnProperty(e)&&(b[e]=r[e]);(0,a.A)(b.width)||(b.width=new h.A({componentDatatype:o.A.UNSIGNED_BYTE,componentsPerAttribute:1,value:[i.geometry.width]})),i.geometry._scene3DOnly=e.scene3DOnly,u.A.setProjectionAndEllipsoid(i.geometry,e.mapProjection),m[t]=new l.A({geometry:i.geometry,attributes:b,id:i.id,pickPrimitive:n})}r.geometryInstances=m,r.appearance=this.appearance,r._createShaderProgramFunction=function(e,t,o){!function(e,t,n){const o=t.context,r=e._primitive,s=r._attributeLocations;let c=r._batchTable.getVertexShaderCallback()(v.A);c=E.A._appendShowToShader(r,c),c=E.A._appendDistanceDisplayConditionToShader(r,c),c=E.A._modifyShaderPosition(e,c,t.scene3DOnly);let l=r._batchTable.getVertexShaderCallback()(y.A);l=E.A._appendShowToShader(r,l),l=E.A._appendDistanceDisplayConditionToShader(r,l),l=E.A._modifyShaderPosition(e,l,t.scene3DOnly);let h=r._batchTable.getVertexShaderCallback()(_.A);const u=[`GLOBE_MINIMUM_ALTITUDE ${t.mapProjection.ellipsoid.minimumRadius.toFixed(1)}`];let d="",p="";(0,a.A)(n.material)?(p=(0,a.A)(n.material)?n.material.shaderSource:"",-1!==p.search(/in\s+float\s+v_polylineAngle;/g)&&u.push("ANGLE_VARYING"),-1!==p.search(/in\s+float\s+v_width;/g)&&u.push("WIDTH_VARYING")):d="PER_INSTANCE_COLOR",u.push(d);const m=e.debugShowShadowVolume?["DEBUG_SHOW_VOLUME",d]:[d],b=new A.A({defines:u,sources:[c]}),w=new A.A({defines:m,sources:[p,h]});e._sp=f.A.replaceCache({context:o,shaderProgram:r._sp,vertexShaderSource:b,fragmentShaderSource:w,attributeLocations:s});let T=o.shaderCache.getDerivedShaderProgram(e._sp,"2dColor");if(!(0,a.A)(T)){const t=new A.A({defines:u.concat(["COLUMBUS_VIEW_2D"]),sources:[c]});T=o.shaderCache.createDerivedShaderProgram(e._sp,"2dColor",{context:o,shaderProgram:e._sp2D,vertexShaderSource:t,fragmentShaderSource:w,attributeLocations:s})}e._sp2D=T;let x=o.shaderCache.getDerivedShaderProgram(e._sp,"MorphColor");if(!(0,a.A)(x)){const t=new A.A({defines:u.concat([`MAX_TERRAIN_HEIGHT ${i.A._defaultMaxTerrainHeight.toFixed(1)}`]),sources:[l]});h=r._batchTable.getVertexShaderCallback()(g.A);const n=new A.A({defines:m,sources:[p,h]});x=o.shaderCache.createDerivedShaderProgram(e._sp,"MorphColor",{context:o,shaderProgram:e._spMorph,vertexShaderSource:t,fragmentShaderSource:n,attributeLocations:s})}e._spMorph=x}(n,t,o)},r._createCommandsFunction=function(e,t,i,o,r,s,c){!function(e,t,n,i,o,r){const s=e._primitive,c=s._va.length;o.length=c,r.length=c;const l=t instanceof x.A?{}:n._uniforms,h=s._batchTable.getUniformMapCallback()(l);for(let t=0;t<c;t++){const n=s._va[t];let i=o[t];(0,a.A)(i)||(i=o[t]=new d.A({owner:e,primitiveType:s._primitiveType})),i.vertexArray=n,i.renderState=e._renderState,i.shaderProgram=e._sp,i.uniformMap=h,i.pass=p.A.TERRAIN_CLASSIFICATION,i.pickId="czm_batchTable_pickColor(v_endPlaneNormalEcAndBatchId.w)";const r=d.A.shallowClone(i,i.derivedCommands.tileset);r.renderState=e._renderState3DTiles,r.pass=p.A.CESIUM_3D_TILE_CLASSIFICATION,i.derivedCommands.tileset=r;const c=d.A.shallowClone(i,i.derivedCommands.color2D);c.shaderProgram=e._sp2D,i.derivedCommands.color2D=c;const l=d.A.shallowClone(r,r.derivedCommands.color2D);l.shaderProgram=e._sp2D,r.derivedCommands.color2D=l;const u=d.A.shallowClone(i,i.derivedCommands.colorMorph);u.renderState=e._renderStateMorph,u.shaderProgram=e._spMorph,u.pickId="czm_batchTable_pickColor(v_batchId)",i.derivedCommands.colorMorph=u}}(n,t,i,0,s,c)},r._updateAndQueueCommandsFunction=function(e,t,i,o,r,s,c,l){!function(e,t,n,i,o,r,s){const c=e._primitive;let l;E.A._updateBoundingVolumes(c,t,o),t.mode===S.A.SCENE3D?l=c._boundingSphereWC:t.mode===S.A.COLUMBUS_VIEW?l=c._boundingSphereCV:t.mode===S.A.SCENE2D&&(0,a.A)(c._boundingSphere2D)?l=c._boundingSphere2D:(0,a.A)(c._boundingSphereMorph)&&(l=c._boundingSphereMorph);const h=t.mode===S.A.MORPHING,u=e.classificationType,d=u!==w.A.CESIUM_3D_TILE,p=u!==w.A.TERRAIN&&!h;let m;const f=t.passes;if(f.render||f.pick&&c.allowPicking){const e=n.length;for(let i=0;i<e;++i){const e=l[i];d&&(m=n[i],R(0,m,t,o,r,e,s)),p&&(m=n[i].derivedCommands.tileset,R(0,m,t,o,r,e,s))}}}(n,t,i,0,r,s,c)},this._primitive=new E.A(r)}if(this.appearance instanceof x.A&&!this._hasPerInstanceColors)throw new c.A("All GeometryInstances must have color attributes to use PolylineColorAppearance with GroundPolylinePrimitive.");this._primitive.appearance=this.appearance,this._primitive.show=this.show,this._primitive.debugShowBoundingVolume=this.debugShowBoundingVolume,this._primitive.update(e),e.afterRender.push(()=>{!this._ready&&(0,a.A)(this._primitive)&&this._primitive.ready&&(this._ready=!0,this.releaseGeometryInstances&&(this.geometryInstances=void 0))})},I.prototype.getGeometryInstanceAttributes=function(e){if(!(0,a.A)(this._primitive))throw new c.A("must call update before calling getGeometryInstanceAttributes");return this._primitive.getGeometryInstanceAttributes(e)},I.isSupported=function(e){return e.frameState.context.depthTexture},I.prototype.isDestroyed=function(){return!1},I.prototype.destroy=function(){return this._primitive=this._primitive&&this._primitive.destroy(),this._sp=this._sp&&this._sp.destroy(),this._sp2D=void 0,this._spMorph=void 0,(0,s.A)(this)};const N=I},623e3:(e,t,n)=>{"use strict";n.d(t,{A:()=>N});var i=n(564886),o=n(660662),r=n(267980),a=n(336946),s=n(369031),c=n(915325),l=n(491446),h=n(677354),u=n(605971),d=n(75200),p=n(832698),m=n(697422),f=n(717339),A=n(627853),_=n(71578),g=n(612123),y=n(62467),v=n(395250);const b={u_globeMinimumAltitude:function(){return 55e3}};function w(e){let t=(e=e??c.A.EMPTY_OBJECT).appearance;const n=e.geometryInstances;if(!(0,l.A)(t)&&(0,l.A)(n)){const e=Array.isArray(n)?n:[n],i=e.length;for(let n=0;n<i;n++){const i=e[n].attributes;if((0,l.A)(i)&&(0,l.A)(i.color)){t=new g.A({flat:!0});break}}}this.appearance=t,this.geometryInstances=e.geometryInstances,this.show=e.show??!0,this.classificationType=e.classificationType??_.A.BOTH,this.debugShowBoundingVolume=e.debugShowBoundingVolume??!1,this.debugShowShadowVolume=e.debugShowShadowVolume??!1,this._boundingVolumes=[],this._boundingVolumes2D=[],this._ready=!1,this._primitive=void 0,this._maxHeight=void 0,this._minHeight=void 0,this._maxTerrainHeight=i.A._defaultMaxTerrainHeight,this._minTerrainHeight=i.A._defaultMinTerrainHeight,this._boundingSpheresKeys=[],this._boundingSpheres=[],this._useFragmentCulling=!1,this._zIndex=void 0,this._classificationPrimitiveOptions={geometryInstances:void 0,appearance:void 0,vertexCacheOptimize:e.vertexCacheOptimize??!1,interleave:e.interleave??!1,releaseGeometryInstances:e.releaseGeometryInstances??!0,allowPicking:e.allowPicking??!0,asynchronous:e.asynchronous??!0,compressVertices:e.compressVertices??!0,_createBoundingVolumeFunction:void 0,_updateAndQueueCommandsFunction:void 0,_pickPrimitive:this,_extruded:!0,_uniformMap:b}}function T(e){return function(t,n){const i=n.maximumRadius,o=i/Math.cos(.5*t)-i;return e._maxHeight+o}}function x(e){return function(t,n){return e._minHeight}}Object.defineProperties(w.prototype,{vertexCacheOptimize:{get:function(){return this._classificationPrimitiveOptions.vertexCacheOptimize}},interleave:{get:function(){return this._classificationPrimitiveOptions.interleave}},releaseGeometryInstances:{get:function(){return this._classificationPrimitiveOptions.releaseGeometryInstances}},allowPicking:{get:function(){return this._classificationPrimitiveOptions.allowPicking}},asynchronous:{get:function(){return this._classificationPrimitiveOptions.asynchronous}},compressVertices:{get:function(){return this._classificationPrimitiveOptions.compressVertices}},ready:{get:function(){return this._ready}}}),w.isSupported=A.A.isSupported;const C=new r.A,E=new r.A,S=new r.A,D=new a.A,O=new m.A;function z(e,t){const n=e.mapProjection.ellipsoid;if(!(0,l.A)(t.attributes)||!(0,l.A)(t.attributes.position3DHigh))return(0,l.A)(t.rectangle)?t.rectangle:void 0;const i=t.attributes.position3DHigh.values,o=t.attributes.position3DLow.values,a=i.length;let s=Number.POSITIVE_INFINITY,c=Number.POSITIVE_INFINITY,h=Number.NEGATIVE_INFINITY,u=Number.NEGATIVE_INFINITY;for(let e=0;e<a;e+=3){const t=r.A.unpack(i,e,C),a=r.A.unpack(o,e,E),l=r.A.add(t,a,S),d=n.cartesianToCartographic(l,D),p=d.latitude,m=d.longitude;s=Math.min(s,p),c=Math.min(c,m),h=Math.max(h,p),u=Math.max(u,m)}const d=O;return d.north=h,d.south=s,d.east=u,d.west=c,d}function I(e,t){return Math.floor(e%t/2)}function P(e,t,n,i,o,r,a){const s=e._primitive;n.mode!==y.A.SCENE3D&&t.shaderProgram===s._spColor&&s._needs2DShader&&(t=t.derivedCommands.appearance2D),t.owner=e,t.modelMatrix=i,t.boundingVolume=r,t.cull=o,t.debugShowBoundingVolume=a,n.commandList.push(t)}function R(e,t,n,i,o,r){const a=e._primitive;n.mode!==y.A.SCENE3D&&t.shaderProgram===a._spPick&&a._needs2DShader&&(t=t.derivedCommands.pick2D),t.owner=e,t.modelMatrix=i,t.boundingVolume=r,t.cull=o,n.commandList.push(t)}w.initializeTerrainHeights=function(){return i.A.initialize()},w.prototype.update=function(e){if(!(0,l.A)(this._primitive)&&!(0,l.A)(this.geometryInstances))return;if(!i.A.initialized){if(!this.asynchronous)throw new u.A("For synchronous GroundPrimitives, you must call GroundPrimitive.initializeTerrainHeights() and wait for the returned promise to resolve.");return void w.initializeTerrainHeights()}const t=this,n=this._classificationPrimitiveOptions;if(!(0,l.A)(this._primitive)){const a=e.mapProjection.ellipsoid;let s,c,h;const g=Array.isArray(this.geometryInstances)?this.geometryInstances:[this.geometryInstances],b=g.length,C=new Array(b);let E,S;for(E=0;E<b;++E){s=g[E],c=s.geometry;const t=z(e,c);(0,l.A)(S)?(0,l.A)(t)&&m.A.union(S,t,S):S=m.A.clone(t);const n=s.id;if((0,l.A)(n)&&(0,l.A)(t)){const e=i.A.getBoundingSphere(t,a);this._boundingSpheresKeys.push(n),this._boundingSpheres.push(e)}if(h=c.constructor,!(0,l.A)(h)||!(0,l.A)(h.createShadowVolume))throw new u.A("Not all of the geometry instances have GroundPrimitive support.")}!function(e,t,n){const o=i.A.getMinimumMaximumHeights(t,n);e._minTerrainHeight=o.minimumTerrainHeight,e._maxTerrainHeight=o.maximumTerrainHeight}(this,S,a);const D=e.verticalExaggeration,O=e.verticalExaggerationRelativeHeight;this._minHeight=f.A.getHeight(this._minTerrainHeight,D,O),this._maxHeight=f.A.getHeight(this._maxTerrainHeight,D,O);const N=w._supportsMaterials(e.context);if(this._useFragmentCulling=N,N){let t,n=!0;for(E=0;E<b;++E)if(s=g[E],c=s.geometry,S=z(e,c),v.A.shouldUseSphericalCoordinates(S)){n=!1;break}for(E=0;E<b;++E){s=g[E],c=s.geometry,h=c.constructor;const i=z(e,c),o=c.textureCoordinateRotationPoints;t=n?v.A.getPlanarTextureCoordinateAttributes(i,o,a,e.mapProjection,this._maxHeight):v.A.getSphericalExtentGeometryInstanceAttributes(i,o,a,e.mapProjection);const r=s.attributes;for(const e in r)r.hasOwnProperty(e)&&(t[e]=r[e]);C[E]=new d.A({geometry:h.createShadowVolume(c,x(this),T(this)),attributes:t,id:s.id})}}else for(E=0;E<b;++E)s=g[E],c=s.geometry,h=c.constructor,C[E]=new d.A({geometry:h.createShadowVolume(c,x(this),T(this)),attributes:s.attributes,id:s.id});n.geometryInstances=C,n.appearance=this.appearance,n._createBoundingVolumeFunction=function(e,n){!function(e,t,n){const i=t.mapProjection.ellipsoid,a=z(t,n),s=p.A.fromRectangle(a,e._minHeight,e._maxHeight,i);if(e._boundingVolumes.push(s),!t.scene3DOnly){const n=t.mapProjection,i=o.A.fromRectangleWithHeights2D(a,n,e._maxHeight,e._minHeight);r.A.fromElements(i.center.z,i.center.x,i.center.y,i.center),e._boundingVolumes2D.push(i)}}(t,e,n)},n._updateAndQueueCommandsFunction=function(e,n,i,o,r,a,s,c){!function(e,t,n,i,o,r,a){let s;s=t.mode===y.A.SCENE3D?e._boundingVolumes:e._boundingVolumes2D;const c=e.classificationType,l=c!==_.A.CESIUM_3D_TILE,h=c!==_.A.TERRAIN,u=t.passes,d=e._primitive;let p,m,f;if(u.render){const i=n.length;for(p=0;p<i;++p)m=s[I(p,i)],l&&(f=n[p],P(e,f,t,o,r,m,a)),h&&(f=n[p].derivedCommands.tileset,P(e,f,t,o,r,m,a));if(t.invertClassification){const n=d._commandsIgnoreShow,i=n.length;for(p=0;p<i;++p)m=s[p],f=n[p],P(e,f,t,o,r,m,a)}}if(u.pick){const n=i.length;let a;for(e._useFragmentCulling||(a=d._primitive._pickOffsets),p=0;p<n;++p)m=s[I(p,n)],e._useFragmentCulling||(m=s[a[I(p,n)].index]),l&&(f=i[p],R(e,f,t,o,r,m)),h&&(f=i[p].derivedCommands.tileset,R(e,f,t,o,r,m))}}(t,n,i,o,r,a,s)},this._primitive=new A.A(n)}this._primitive.appearance=this.appearance,this._primitive.show=this.show,this._primitive.debugShowShadowVolume=this.debugShowShadowVolume,this._primitive.debugShowBoundingVolume=this.debugShowBoundingVolume,this._primitive.update(e),e.afterRender.push(()=>{!this._ready&&(0,l.A)(this._primitive)&&this._primitive.ready&&(this._ready=!0,this.releaseGeometryInstances&&(this.geometryInstances=void 0))})},w.prototype.getBoundingSphere=function(e){const t=this._boundingSpheresKeys.indexOf(e);if(-1!==t)return this._boundingSpheres[t]},w.prototype.getGeometryInstanceAttributes=function(e){if(!(0,l.A)(this._primitive))throw new u.A("must call update before calling getGeometryInstanceAttributes");return this._primitive.getGeometryInstanceAttributes(e)},w.prototype.isDestroyed=function(){return!1},w.prototype.destroy=function(){return this._primitive=this._primitive&&this._primitive.destroy(),(0,h.A)(this)},w._supportsMaterials=function(e){return e.depthTexture},w.supportsMaterials=function(e){return s.A.typeOf.object("scene",e),w._supportsMaterials(e.frameState.context)};const N=w},63316:(e,t,n)=>{"use strict";n.d(t,{Ay:()=>o,Lq:()=>a,w_:()=>r});const i={NONE:0,CLAMP_TO_GROUND:1,RELATIVE_TO_GROUND:2,CLAMP_TO_TERRAIN:3,RELATIVE_TO_TERRAIN:4,CLAMP_TO_3D_TILE:5,RELATIVE_TO_3D_TILE:6},o=Object.freeze(i);function r(e){return e===i.CLAMP_TO_GROUND||e===i.CLAMP_TO_3D_TILE||e===i.CLAMP_TO_TERRAIN}function a(e){return e===i.RELATIVE_TO_GROUND||e===i.RELATIVE_TO_3D_TILE||e===i.RELATIVE_TO_TERRAIN}},337632:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i=Object.freeze({CENTER:0,LEFT:1,RIGHT:-1})},566798:(e,t,n)=>{"use strict";n.d(t,{A:()=>R});var i=n(647934),o=n(434067),r=n(267980),a=n(41476),s=n(915325),c=n(491446),l=n(605971),h=n(853331),u=n(290176),d=n(124547),p=n(63316),m=n(337632),f=n(15817),A=n(589834),_=n(742558);const g={};let y=0;const v=new a.A(.165,.165,.165,.8),b=new o.A(7,5),w=Object.freeze({LTR:0,RTL:1,WEAK:2,BRACKETS:3});function T(e){e._rebindAllGlyphs||e._repositionAllGlyphs||e._labelCollection._labelsToUpdate.push(e),e._rebindAllGlyphs=!0}function x(e){e._rebindAllGlyphs||e._repositionAllGlyphs||e._labelCollection._labelsToUpdate.push(e),e._repositionAllGlyphs=!0}function C(e,t){return document.defaultView.getComputedStyle(e,null).getPropertyValue(t)}function E(e){let t=g[e._font];if(!(0,c.A)(t)){const n=document.createElement("div");n.style.position="absolute",n.style.opacity=0,n.style.font=e._font,document.body.appendChild(n);let i=parseFloat(C(n,"line-height"));isNaN(i)&&(i=void 0),t={family:C(n,"font-family"),size:C(n,"font-size").replace("px",""),style:C(n,"font-style"),weight:C(n,"font-weight"),lineHeight:i},document.body.removeChild(n),y<256&&(g[e._font]=t,y++)}e._fontFamily=t.family,e._fontSize=t.size,e._fontStyle=t.style,e._fontWeight=t.weight,e._lineHeight=t.lineHeight}function S(e,t){if(e=e??s.A.EMPTY_OBJECT,(0,c.A)(e.disableDepthTestDistance)&&e.disableDepthTestDistance<0)throw new l.A("disableDepthTestDistance must be greater than 0.0.");let n=e.translucencyByDistance,i=e.pixelOffsetScaleByDistance,d=e.scaleByDistance,A=e.distanceDisplayCondition;if((0,c.A)(n)){if(n.far<=n.near)throw new l.A("translucencyByDistance.far must be greater than translucencyByDistance.near.");n=u.A.clone(n)}if((0,c.A)(i)){if(i.far<=i.near)throw new l.A("pixelOffsetScaleByDistance.far must be greater than pixelOffsetScaleByDistance.near.");i=u.A.clone(i)}if((0,c.A)(d)){if(d.far<=d.near)throw new l.A("scaleByDistance.far must be greater than scaleByDistance.near.");d=u.A.clone(d)}if((0,c.A)(A)){if(A.far<=A.near)throw new l.A("distanceDisplayCondition.far must be greater than distanceDisplayCondition.near.");A=h.A.clone(A)}this._renderedText=void 0,this._text=void 0,this._show=e.show??!0,this._font=e.font??"30px sans-serif",this._fillColor=a.A.clone(e.fillColor??a.A.WHITE),this._outlineColor=a.A.clone(e.outlineColor??a.A.BLACK),this._outlineWidth=e.outlineWidth??1,this._showBackground=e.showBackground??!1,this._backgroundColor=a.A.clone(e.backgroundColor??v),this._backgroundPadding=o.A.clone(e.backgroundPadding??b),this._style=e.style??f.A.FILL,this._verticalOrigin=e.verticalOrigin??_.A.BASELINE,this._horizontalOrigin=e.horizontalOrigin??m.A.LEFT,this._pixelOffset=o.A.clone(e.pixelOffset??o.A.ZERO),this._eyeOffset=r.A.clone(e.eyeOffset??r.A.ZERO),this._position=r.A.clone(e.position??r.A.ZERO),this._scale=e.scale??1,this._id=e.id,this._translucencyByDistance=n,this._pixelOffsetScaleByDistance=i,this._scaleByDistance=d,this._heightReference=e.heightReference??p.Ay.NONE,this._distanceDisplayCondition=A,this._disableDepthTestDistance=e.disableDepthTestDistance,this._labelCollection=t,this._glyphs=[],this._backgroundBillboard=void 0,this._batchIndex=void 0,this._rebindAllGlyphs=!0,this._repositionAllGlyphs=!0,this._actualClampedPosition=void 0,this._removeCallbackFunc=void 0,this._mode=void 0,this._clusterShow=!0,this.text=e.text??"",this._relativeSize=1,E(this),this._updateClamping()}function D(e,t){const n=/[a-zA-Z0-9]/,i=/[()[\]{}<>]/,o=[];let r="",a=w.LTR,s="";const c=e.length;for(let l=0;l<c;++l){const c=e.charAt(l);s=t.test(c)?w.RTL:n.test(c)?w.LTR:i.test(c)?w.BRACKETS:w.WEAK,0===l&&(a=s),a===s&&s!==w.BRACKETS?r+=c:(""!==r&&o.push({Type:a,Word:r}),a=s,r=c)}return o.push({Type:s,Word:r}),o}function O(e){return e.split("").reverse().join("")}function z(e,t,n){return e.slice(0,t)+n+e.slice(t)}function I(e){switch(e){case"(":return")";case")":return"(";case"[":return"]";case"]":return"[";case"{":return"}";case"}":return"{";case"<":return">";case">":return"<"}}Object.defineProperties(S.prototype,{show:{get:function(){return this._show},set:function(e){if(!(0,c.A)(e))throw new l.A("value is required.");if(this._show!==e){this._show=e;const t=this._glyphs;for(let n=0,i=t.length;n<i;n++){const i=t[n].billboard;(0,c.A)(i)&&(i.show=e)}const n=this._backgroundBillboard;(0,c.A)(n)&&(n.show=e)}}},position:{get:function(){return this._position},set:function(e){if(!(0,c.A)(e))throw new l.A("value is required.");const t=this._position;if(!r.A.equals(t,e)){r.A.clone(e,t);const n=this._glyphs;for(let t=0,i=n.length;t<i;t++){const i=n[t].billboard;(0,c.A)(i)&&(i.position=e)}const i=this._backgroundBillboard;(0,c.A)(i)&&(i.position=e),this._updateClamping()}}},heightReference:{get:function(){return this._heightReference},set:function(e){if(!(0,c.A)(e))throw new l.A("value is required.");if(e!==this._heightReference){this._heightReference=e;const t=this._glyphs;for(let n=0,i=t.length;n<i;n++){const i=t[n].billboard;(0,c.A)(i)&&(i.heightReference=e)}const n=this._backgroundBillboard;(0,c.A)(n)&&(n.heightReference=e),x(this),this._updateClamping()}}},text:{get:function(){return this._text},set:function(e){if(!(0,c.A)(e))throw new l.A("value is required.");if(this._text!==e){this._text=e;const t=S.filterUnsupportedCharacters(e);this._renderedText=S.enableRightToLeftDetection?function(e){const t=e.split("\n");let n="";for(let e=0;e<t.length;e++){const i=t[e],o=P.test(i.charAt(0)),r=D(i,P);let a=0,s="";for(let e=0;e<r.length;++e){const t=r[e],n=t.Type===w.BRACKETS?I(t.Word):O(t.Word);o?t.Type===w.RTL?(s=n+s,a=0):t.Type===w.LTR?(s=z(s,a,t.Word),a+=t.Word.length):t.Type!==w.WEAK&&t.Type!==w.BRACKETS||(t.Type===w.WEAK&&r[e-1].Type===w.BRACKETS?s=n+s:r[e-1].Type===w.RTL?(s=n+s,a=0):r.length>e+1?r[e+1].Type===w.RTL?(s=n+s,a=0):(s=z(s,a,t.Word),a+=t.Word.length):s=z(s,0,n)):t.Type===w.RTL?s=z(s,a,n):t.Type===w.LTR?(s+=t.Word,a=s.length):t.Type!==w.WEAK&&t.Type!==w.BRACKETS||(e>0&&r[e-1].Type===w.RTL?r.length>e+1?r[e+1].Type===w.RTL?s=z(s,a,n):(s+=t.Word,a=s.length):s+=t.Word:(s+=t.Word,a=s.length))}n+=s,e<t.length-1&&(n+="\n")}return n}(t):t,T(this)}}},font:{get:function(){return this._font},set:function(e){if(!(0,c.A)(e))throw new l.A("value is required.");this._font!==e&&(this._font=e,T(this),E(this))}},fillColor:{get:function(){return this._fillColor},set:function(e){if(!(0,c.A)(e))throw new l.A("value is required.");const t=this._fillColor;a.A.equals(t,e)||(a.A.clone(e,t),T(this))}},outlineColor:{get:function(){return this._outlineColor},set:function(e){if(!(0,c.A)(e))throw new l.A("value is required.");const t=this._outlineColor;a.A.equals(t,e)||(a.A.clone(e,t),T(this))}},outlineWidth:{get:function(){return this._outlineWidth},set:function(e){if(!(0,c.A)(e))throw new l.A("value is required.");this._outlineWidth!==e&&(this._outlineWidth=e,T(this))}},showBackground:{get:function(){return this._showBackground},set:function(e){if(!(0,c.A)(e))throw new l.A("value is required.");this._showBackground!==e&&(this._showBackground=e,T(this))}},backgroundColor:{get:function(){return this._backgroundColor},set:function(e){if(!(0,c.A)(e))throw new l.A("value is required.");const t=this._backgroundColor;if(!a.A.equals(t,e)){a.A.clone(e,t);const n=this._backgroundBillboard;(0,c.A)(n)&&(n.color=t)}}},backgroundPadding:{get:function(){return this._backgroundPadding},set:function(e){if(!(0,c.A)(e))throw new l.A("value is required.");const t=this._backgroundPadding;o.A.equals(t,e)||(o.A.clone(e,t),x(this))}},style:{get:function(){return this._style},set:function(e){if(!(0,c.A)(e))throw new l.A("value is required.");this._style!==e&&(this._style=e,T(this))}},pixelOffset:{get:function(){return this._pixelOffset},set:function(e){if(!(0,c.A)(e))throw new l.A("value is required.");const t=this._pixelOffset;if(!o.A.equals(t,e)){o.A.clone(e,t);const n=this._glyphs;for(let t=0,i=n.length;t<i;t++){const i=n[t];(0,c.A)(i.billboard)&&(i.billboard.pixelOffset=e)}const i=this._backgroundBillboard;(0,c.A)(i)&&(i.pixelOffset=e)}}},translucencyByDistance:{get:function(){return this._translucencyByDistance},set:function(e){if((0,c.A)(e)&&e.far<=e.near)throw new l.A("far distance must be greater than near distance.");const t=this._translucencyByDistance;if(!u.A.equals(t,e)){this._translucencyByDistance=u.A.clone(e,t);const n=this._glyphs;for(let t=0,i=n.length;t<i;t++){const i=n[t];(0,c.A)(i.billboard)&&(i.billboard.translucencyByDistance=e)}const i=this._backgroundBillboard;(0,c.A)(i)&&(i.translucencyByDistance=e)}}},pixelOffsetScaleByDistance:{get:function(){return this._pixelOffsetScaleByDistance},set:function(e){if((0,c.A)(e)&&e.far<=e.near)throw new l.A("far distance must be greater than near distance.");const t=this._pixelOffsetScaleByDistance;if(!u.A.equals(t,e)){this._pixelOffsetScaleByDistance=u.A.clone(e,t);const n=this._glyphs;for(let t=0,i=n.length;t<i;t++){const i=n[t];(0,c.A)(i.billboard)&&(i.billboard.pixelOffsetScaleByDistance=e)}const i=this._backgroundBillboard;(0,c.A)(i)&&(i.pixelOffsetScaleByDistance=e)}}},scaleByDistance:{get:function(){return this._scaleByDistance},set:function(e){if((0,c.A)(e)&&e.far<=e.near)throw new l.A("far distance must be greater than near distance.");const t=this._scaleByDistance;if(!u.A.equals(t,e)){this._scaleByDistance=u.A.clone(e,t);const n=this._glyphs;for(let t=0,i=n.length;t<i;t++){const i=n[t];(0,c.A)(i.billboard)&&(i.billboard.scaleByDistance=e)}const i=this._backgroundBillboard;(0,c.A)(i)&&(i.scaleByDistance=e)}}},eyeOffset:{get:function(){return this._eyeOffset},set:function(e){if(!(0,c.A)(e))throw new l.A("value is required.");const t=this._eyeOffset;if(!r.A.equals(t,e)){r.A.clone(e,t);const n=this._glyphs;for(let t=0,i=n.length;t<i;t++){const i=n[t];(0,c.A)(i.billboard)&&(i.billboard.eyeOffset=e)}const i=this._backgroundBillboard;(0,c.A)(i)&&(i.eyeOffset=e)}}},horizontalOrigin:{get:function(){return this._horizontalOrigin},set:function(e){if(!(0,c.A)(e))throw new l.A("value is required.");this._horizontalOrigin!==e&&(this._horizontalOrigin=e,x(this))}},verticalOrigin:{get:function(){return this._verticalOrigin},set:function(e){if(!(0,c.A)(e))throw new l.A("value is required.");if(this._verticalOrigin!==e){this._verticalOrigin=e;const t=this._glyphs;for(let n=0,i=t.length;n<i;n++){const i=t[n];(0,c.A)(i.billboard)&&(i.billboard.verticalOrigin=e)}const n=this._backgroundBillboard;(0,c.A)(n)&&(n.verticalOrigin=e),x(this)}}},scale:{get:function(){return this._scale},set:function(e){if(!(0,c.A)(e))throw new l.A("value is required.");if(this._scale!==e){this._scale=e;const t=this._glyphs;for(let n=0,i=t.length;n<i;n++){const i=t[n];(0,c.A)(i.billboard)&&(i.billboard.scale=e*this._relativeSize)}const n=this._backgroundBillboard;(0,c.A)(n)&&(n.scale=e*this._relativeSize),x(this)}}},totalScale:{get:function(){return this._scale*this._relativeSize}},distanceDisplayCondition:{get:function(){return this._distanceDisplayCondition},set:function(e){if((0,c.A)(e)&&e.far<=e.near)throw new l.A("far must be greater than near");if(!h.A.equals(e,this._distanceDisplayCondition)){this._distanceDisplayCondition=h.A.clone(e,this._distanceDisplayCondition);const t=this._glyphs;for(let n=0,i=t.length;n<i;n++){const i=t[n];(0,c.A)(i.billboard)&&(i.billboard.distanceDisplayCondition=e)}const n=this._backgroundBillboard;(0,c.A)(n)&&(n.distanceDisplayCondition=e)}}},disableDepthTestDistance:{get:function(){return this._disableDepthTestDistance},set:function(e){if(this._disableDepthTestDistance!==e){if((0,c.A)(e)&&e<0)throw new l.A("disableDepthTestDistance must be greater than 0.0.");this._disableDepthTestDistance=e;const t=this._glyphs;for(let n=0,i=t.length;n<i;n++){const i=t[n];(0,c.A)(i.billboard)&&(i.billboard.disableDepthTestDistance=e)}const n=this._backgroundBillboard;(0,c.A)(n)&&(n.disableDepthTestDistance=e)}}},id:{get:function(){return this._id},set:function(e){if(this._id!==e){this._id=e;const t=this._glyphs;for(let n=0,i=t.length;n<i;n++){const i=t[n];(0,c.A)(i.billboard)&&(i.billboard.id=e)}const n=this._backgroundBillboard;(0,c.A)(n)&&(n.id=e)}}},pickId:{get:function(){if(0!==this._glyphs.length&&(0,c.A)(this._glyphs[0].billboard))return this._glyphs[0].billboard.pickId}},_clampedPosition:{get:function(){return this._actualClampedPosition},set:function(e){this._actualClampedPosition=r.A.clone(e,this._actualClampedPosition);const t=this._glyphs;for(let n=0,i=t.length;n<i;n++){const i=t[n];(0,c.A)(i.billboard)&&(i.billboard._clampedPosition=e)}const n=this._backgroundBillboard;(0,c.A)(n)&&(n._clampedPosition=e)}},clusterShow:{get:function(){return this._clusterShow},set:function(e){if(this._clusterShow!==e){this._clusterShow=e;const t=this._glyphs;for(let n=0,i=t.length;n<i;n++){const i=t[n];(0,c.A)(i.billboard)&&(i.billboard.clusterShow=e)}const n=this._backgroundBillboard;(0,c.A)(n)&&(n.clusterShow=e)}}}}),S.prototype._updateClamping=function(){d.A._updateClamping(this._labelCollection,this)},S.prototype.computeScreenSpacePosition=function(e,t){if(!(0,c.A)(e))throw new l.A("scene is required.");(0,c.A)(t)||(t=new o.A);const n=this._labelCollection.modelMatrix,i=(0,c.A)(this._actualClampedPosition)?this._actualClampedPosition:this._position;return d.A._computeScreenSpacePosition(n,i,this._eyeOffset,this._pixelOffset,e,t)},S.getScreenSpaceBoundingBox=function(e,t,n){let o=0,r=0,a=0,s=0;const l=e.totalScale,h=e._backgroundBillboard;if((0,c.A)(h))o=t.x+h._translate.x,r=t.y-h._translate.y,a=h.width*l,s=h.height*l,e.verticalOrigin===_.A.BOTTOM||e.verticalOrigin===_.A.BASELINE?r-=s:e.verticalOrigin===_.A.CENTER&&(r-=.5*s);else{o=Number.POSITIVE_INFINITY,r=Number.POSITIVE_INFINITY;let n=0,i=0;const h=e._glyphs,u=h.length;for(let a=0;a<u;++a){const s=h[a],u=s.billboard;if(!(0,c.A)(u))continue;const d=t.x+u._translate.x;let p=t.y-u._translate.y;const m=s.dimensions.width*l,f=s.dimensions.height*l;e.verticalOrigin===_.A.BOTTOM||e.verticalOrigin===_.A.BASELINE?p-=f:e.verticalOrigin===_.A.CENTER&&(p-=.5*f),e._verticalOrigin===_.A.TOP?p+=A.A.PADDING*l:e._verticalOrigin!==_.A.BOTTOM&&e._verticalOrigin!==_.A.BASELINE||(p-=A.A.PADDING*l),o=Math.min(o,d),r=Math.min(r,p),n=Math.max(n,d+m),i=Math.max(i,p+f)}a=n-o,s=i-r}return(0,c.A)(n)||(n=new i.A),n.x=o,n.y=r,n.width=a,n.height=s,n},S.filterUnsupportedCharacters=function(e){const t=new RegExp(/[\u0000-\u0008\u000E-\u001F\u00ad\u202a-\u206f\u200b-\u200f]/,"g");return e.replace(t,"")},S.prototype.equals=function(e){return this===e||(0,c.A)(e)&&this._show===e._show&&this._scale===e._scale&&this._outlineWidth===e._outlineWidth&&this._showBackground===e._showBackground&&this._style===e._style&&this._verticalOrigin===e._verticalOrigin&&this._horizontalOrigin===e._horizontalOrigin&&this._heightReference===e._heightReference&&this._renderedText===e._renderedText&&this._font===e._font&&r.A.equals(this._position,e._position)&&a.A.equals(this._fillColor,e._fillColor)&&a.A.equals(this._outlineColor,e._outlineColor)&&a.A.equals(this._backgroundColor,e._backgroundColor)&&o.A.equals(this._backgroundPadding,e._backgroundPadding)&&o.A.equals(this._pixelOffset,e._pixelOffset)&&r.A.equals(this._eyeOffset,e._eyeOffset)&&u.A.equals(this._translucencyByDistance,e._translucencyByDistance)&&u.A.equals(this._pixelOffsetScaleByDistance,e._pixelOffsetScaleByDistance)&&u.A.equals(this._scaleByDistance,e._scaleByDistance)&&h.A.equals(this._distanceDisplayCondition,e._distanceDisplayCondition)&&this._disableDepthTestDistance===e._disableDepthTestDistance&&this._id===e._id},S.prototype.isDestroyed=function(){return!1},S.enableRightToLeftDetection=!1;const P=new RegExp("[----]"),R=S},465674:(e,t,n)=>{"use strict";n.d(t,{A:()=>V});var i=n(647934),o=n(434067),r=n(41476),a=n(915325),s=n(491446),c=n(677354),l=n(605971),h=n(584164),u=n(517638),d=n(527288),p=n(770103),m=n(208836),f=n(416882),A=n(63316),_=n(337632),g=n(566798),y=n(15817),v=n(589834),b=n(66589),w=n(742558),T=n(62052);function x(){this.dimensions=void 0,this.billboardTexture=void 0,this.billboard=void 0}const C="ID_WHITE_PIXEL",E=new o.A(4,4),S=new i.A(1,1,1,1),D={};function O(e,t,n,i,o,a){return D.font=t,D.fillColor=n,D.strokeColor=i,D.strokeWidth=o,D.padding=v.A.PADDING,D.fill=a===y.A.FILL||a===y.A.FILL_AND_OUTLINE,D.stroke=a===y.A.OUTLINE||a===y.A.FILL_AND_OUTLINE,D.backgroundColor=r.A.BLACK,(0,u.A)(e,D)}function z(e,t){const n=t.billboard;(0,s.A)(n)&&(n.show=!1,(0,s.A)(n._removeCallbackFunc)&&(n._removeCallbackFunc(),n._removeCallbackFunc=void 0),e._spareBillboards.push(n),t.billboard=void 0)}const I=new T,P=/\s/;function R(e,t){const n=t._renderedText,i=I.splitGraphemes(n),a=i.length,c=t._glyphs,l=c.length;if(t._relativeSize=t._fontSize/v.A.FONT_SIZE,a<l)for(let t=a;t<l;++t)z(e,c[t]);c.length=a;const h=t.show&&t._showBackground&&n.split("\n").join("").length>0;let u=t._backgroundBillboard;const p=e._backgroundBillboardCollection;h?((0,s.A)(u)||(u=function(e,t){const n=t._backgroundBillboardTexture;if(!n.hasImage){const e=document.createElement("canvas");e.width=E.x,e.height=E.y;const t=e.getContext("2d");t.fillStyle="#fff",t.fillRect(0,0,e.width,e.height),n.loadImage(C,e),n.addImageSubRegion(C,S)}const i=e.add({collection:t});return i.setImageTexture(n),i}(p,e),t._backgroundBillboard=u),u.color=t._backgroundColor,u.show=t._show,u.position=t._position,u.eyeOffset=t._eyeOffset,u.pixelOffset=t._pixelOffset,u.horizontalOrigin=_.A.LEFT,u.verticalOrigin=t._verticalOrigin,u.heightReference=t._heightReference,u.scale=t.totalScale,u.pickPrimitive=t,u.id=t._id,u.translucencyByDistance=t._translucencyByDistance,u.pixelOffsetScaleByDistance=t._pixelOffsetScaleByDistance,u.scaleByDistance=t._scaleByDistance,u.distanceDisplayCondition=t._distanceDisplayCondition,u.disableDepthTestDistance=t._disableDepthTestDistance,u.clusterShow=t.clusterShow):(0,s.A)(u)&&(p.remove(u),t._backgroundBillboard=u=void 0);const f=e._glyphBillboardCollection,A=f.billboardTextureCache,g=e._textDimensionsCache;for(let n=0;n<a;++n){const a=i[n],l=t._verticalOrigin,h=JSON.stringify([a,t._fontFamily,t._fontStyle,t._fontWeight,+l]);let u=g[h],p=A.get(h);if(!(0,s.A)(p)||!(0,s.A)(u)){p=new m.A(f),A.set(h,p);const e=O(a,`${t._fontStyle} ${t._fontWeight} ${v.A.FONT_SIZE}px ${t._fontFamily}`,r.A.WHITE,r.A.WHITE,0,y.A.FILL);if(u=e.dimensions,g[h]=u,e.width>0&&e.height>0&&!P.test(a)){const t=d(e,{cutoff:v.A.CUTOFF,radius:v.A.RADIUS}),n=e.getContext("2d"),i=e.width,o=e.height,r=n.getImageData(0,0,i,o);for(let e=0;e<i;e++)for(let n=0;n<o;n++){const o=n*i+e,a=255*t[o],s=4*o;r.data[s+0]=a,r.data[s+1]=a,r.data[s+2]=a,r.data[s+3]=a}n.putImageData(r,0,0),p.loadImage(h,e)}}let b=c[n];if((0,s.A)(b)||(b=new x,b.dimensions=u,b.billboardTexture=p,c[n]=b),b.billboardTexture.id!==h&&(b.billboardTexture=p,b.dimensions=u),!p.hasImage){z(e,b);continue}let w=b.billboard;const T=e._spareBillboards;(0,s.A)(w)||(T.length>0?w=T.pop():(w=f.add({collection:e}),w._labelDimensions=new o.A,w._labelTranslate=new o.A),b.billboard=w),w.setImageTexture(p),w.show=t._show,w.position=t._position,w.eyeOffset=t._eyeOffset,w.pixelOffset=t._pixelOffset,w.horizontalOrigin=_.A.LEFT,w.verticalOrigin=t._verticalOrigin,w.heightReference=t._heightReference,w.scale=t.totalScale,w.pickPrimitive=t,w.id=t._id,w.translucencyByDistance=t._translucencyByDistance,w.pixelOffsetScaleByDistance=t._pixelOffsetScaleByDistance,w.scaleByDistance=t._scaleByDistance,w.distanceDisplayCondition=t._distanceDisplayCondition,w.disableDepthTestDistance=t._disableDepthTestDistance,w._batchIndex=t._batchIndex,w.outlineColor=t.outlineColor,t.style===y.A.FILL_AND_OUTLINE?(w.color=t._fillColor,w.outlineWidth=t.outlineWidth):t.style===y.A.FILL?(w.color=t._fillColor,w.outlineWidth=0):t.style===y.A.OUTLINE&&(w.color=r.A.TRANSPARENT,w.outlineWidth=t.outlineWidth)}t._repositionAllGlyphs=!0}function N(e,t,n){return t===_.A.CENTER?-e/2:t===_.A.RIGHT?-(e+n.x):n.x}const L=new o.A,M=new o.A;function F(e){const t=e._glyphs,n=e._renderedText;let i=0,r=0;const a=[];let c=Number.NEGATIVE_INFINITY,l=0,h=1;const u=t.length,d=e._backgroundBillboard,p=o.A.clone((0,s.A)(d)?e._backgroundPadding:o.A.ZERO,M);p.x/=e._relativeSize,p.y/=e._relativeSize;for(let e=0;e<u;++e){if("\n"===n.charAt(e)){a.push(i),++h,i=0;continue}const o=t[e].dimensions;(0,s.A)(o)&&(l=Math.max(l,o.height-o.descent),c=Math.max(c,o.descent),i+=o.width-o.minx,e<u-1&&(i+=t[e+1].dimensions.minx),r=Math.max(r,i))}a.push(i);const m=l+c,f=e.totalScale,g=e._horizontalOrigin,y=e._verticalOrigin;let b=0,T=a[b],x=N(T,g,p);const C=((0,s.A)(e._lineHeight)?e._lineHeight:1.2*e._fontSize)/e._relativeSize,E=C*(h-1);let S=r,D=m+E;(0,s.A)(d)&&(S+=2*p.x,D+=2*p.y,d._labelHorizontalOrigin=g),L.x=x*f,L.y=0;let O=!0,z=0;for(let e=0;e<u;++e){if("\n"===n.charAt(e)){++b,z+=C,T=a[b],x=N(T,g,p),L.x=x*f,O=!0;continue}const i=t[e],o=i.dimensions;if((0,s.A)(o)&&(y===w.A.TOP?(L.y=o.height-l-p.y,L.y+=v.A.PADDING):y===w.A.CENTER?L.y=(E+o.height-l)/2:y===w.A.BASELINE?(L.y=E,L.y-=v.A.PADDING):(L.y=E+c+p.y,L.y-=v.A.PADDING),L.y=(L.y-o.descent-z)*f,O&&(L.x-=v.A.PADDING*f,O=!1),(0,s.A)(i.billboard)&&(i.billboard._setTranslate(L),i.billboard._labelDimensions.x=S,i.billboard._labelDimensions.y=D,i.billboard._labelHorizontalOrigin=g),e<u-1)){const n=t[e+1];L.x+=(o.width-o.minx+n.dimensions.minx)*f}}if((0,s.A)(d)&&n.split("\n").join("").length>0&&(x=g===_.A.CENTER?-r/2-p.x:g===_.A.RIGHT?-(r+2*p.x):0,L.x=x*f,y===w.A.TOP?L.y=m-l-c:y===w.A.CENTER?L.y=(m-l)/2-c:y===w.A.BASELINE?L.y=-p.y-c:L.y=0,L.y=L.y*f,d.width=S,d.height=D,d._setTranslate(L),d._labelTranslate=o.A.clone(L,d._labelTranslate)),(0,A.w_)(e.heightReference))for(let e=0;e<u;++e){const n=t[e].billboard;(0,s.A)(n)&&(n._labelTranslate=o.A.clone(L,n._labelTranslate))}}function B(e,t){const n=t._glyphs;for(let t=0,i=n.length;t<i;++t)z(e,n[t]);(0,s.A)(t._backgroundBillboard)&&(e._backgroundBillboardCollection.remove(t._backgroundBillboard),t._backgroundBillboard=void 0),t._labelCollection=void 0,(0,s.A)(t._removeCallbackFunc)&&t._removeCallbackFunc(),(0,c.A)(t)}function k(e){e=e??a.A.EMPTY_OBJECT,this._scene=e.scene,this._batchTable=e.batchTable;const t=new p.A({scene:this._scene,textureAtlas:new b.A({initialSize:E})});this._backgroundBillboardCollection=t,this._backgroundBillboardTexture=new m.A(t),this._glyphBillboardCollection=new p.A({scene:this._scene,batchTable:this._batchTable}),this._glyphBillboardCollection._sdf=!0,this._spareBillboards=[],this._textDimensionsCache={},this._labels=[],this._labelsToUpdate=[],this._totalGlyphCount=0,this._highlightColor=r.A.clone(r.A.WHITE),this.show=e.show??!0,this.modelMatrix=h.A.clone(e.modelMatrix??h.A.IDENTITY),this.debugShowBoundingVolume=e.debugShowBoundingVolume??!1,this.blendOption=e.blendOption??f.A.OPAQUE_AND_TRANSLUCENT}Object.defineProperties(k.prototype,{length:{get:function(){return this._labels.length}},sizeInBytes:{get:function(){return this._glyphBillboardCollection.sizeInBytes+this._backgroundBillboardCollection.sizeInBytes}},ready:{get:function(){const e=this._backgroundBillboardCollection.get(0);return!((0,s.A)(e)&&!e.ready)&&this._glyphBillboardCollection.ready}}}),k.prototype.add=function(e){const t=new g.A(e,this);return this._labels.push(t),this._labelsToUpdate.push(t),t},k.prototype.remove=function(e){if((0,s.A)(e)&&e._labelCollection===this){const t=this._labels.indexOf(e);if(-1!==t)return this._labels.splice(t,1),B(this,e),!0}return!1},k.prototype.removeAll=function(){const e=this._labels;for(let t=0,n=e.length;t<n;++t)B(this,e[t]);e.length=0},k.prototype.contains=function(e){return(0,s.A)(e)&&e._labelCollection===this},k.prototype.get=function(e){if(!(0,s.A)(e))throw new l.A("index is required.");return this._labels[e]},k.prototype.update=function(e){if(!this.show)return;const t=this._glyphBillboardCollection,n=this._backgroundBillboardCollection;t.modelMatrix=this.modelMatrix,t.debugShowBoundingVolume=this.debugShowBoundingVolume,n.modelMatrix=this.modelMatrix,n.debugShowBoundingVolume=this.debugShowBoundingVolume;const i=this._labelsToUpdate.length;for(let e=0;e<i;++e){const t=this._labelsToUpdate[e];if(t.isDestroyed())continue;const n=t._glyphs.length;t._rebindAllGlyphs&&(R(this,t),t._rebindAllGlyphs=!1),t._repositionAllGlyphs&&(F(t),t._repositionAllGlyphs=!1);const i=t._glyphs.length-n;this._totalGlyphCount+=i}const o=n.length>0?f.A.TRANSLUCENT:this.blendOption;t.blendOption=o,n.blendOption=o,t._highlightColor=this._highlightColor,n._highlightColor=this._highlightColor,this._labelsToUpdate.length=0,n.update(e),t.update(e)},k.prototype.isDestroyed=function(){return!1},k.prototype.destroy=function(){return this.removeAll(),this._glyphBillboardCollection=this._glyphBillboardCollection.destroy(),this._backgroundBillboardCollection=this._backgroundBillboardCollection.destroy(),(0,c.A)(this)};const V=k},15817:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i=Object.freeze({FILL:0,OUTLINE:1,FILL_AND_OUTLINE:2})},608191:(e,t,n)=>{"use strict";n.d(t,{A:()=>Q});var i=n(434067),o=n(376758),r=n(41476),a=n(430346),s=n(673874),c=n(915325),l=n(491446),h=n(677354),u=n(605971),d=n(471874),p=n(463298),m=n(331185),f=n(584164),A=n(744603),_=n(346154),g=n(616e3),y=n(239942),v=n(980360),b=n(874099),w=n(360069),T=n(70966),x=n(21561),C=n(831373),E=n(375916),S=n(76846),D=n(320441),O=n(830539),z=n(227798),I=n(207131),P=n(889216),R=n(865114),N=n(654799),L=n(256773),M=n(807783),F=n(957233),B=n(78078),k=n(733185),V=n(551672);function G(e){this.type=void 0,this.shaderSource=void 0,this.materials=void 0,this.uniforms=void 0,this._uniforms=void 0,this.translucent=void 0,this._minificationFilter=e.minificationFilter??B.A.LINEAR,this._magnificationFilter=e.magnificationFilter??F.A.LINEAR,this._strict=void 0,this._template=void 0,this._count=void 0,this._texturePaths={},this._loadedImages=[],this._loadedCubeMaps=[],this._textures={},this._updateFunctions=[],this._defaultTexture=void 0,function(e,t){let n;e=e??c.A.EMPTY_OBJECT,t._strict=e.strict??!1,t._count=e.count??0,t._template=(0,o.A)(e.fabric??c.A.EMPTY_OBJECT),t._template.uniforms=(0,o.A)(t._template.uniforms??c.A.EMPTY_OBJECT),t._template.materials=(0,o.A)(t._template.materials??c.A.EMPTY_OBJECT),t.type=(0,l.A)(t._template.type)?t._template.type:(0,s.A)(),t.shaderSource="",t.materials={},t.uniforms={},t._uniforms={},t._translucentFunctions=[];const i=G._materialCache.getMaterial(t.type);if((0,l.A)(i)){const e=(0,o.A)(i.fabric,!0);t._template=(0,a.A)(t._template,e,!0),n=i.translucent}(function(e){const t=e._template,n=t.uniforms,i=t.materials,o=t.components;if((0,l.A)(o)&&(0,l.A)(t.source))throw new u.A("fabric: cannot have source and components in the same template.");H(t,q,U,!0),H(o,j,U,!0);const r=[];for(const e in i)i.hasOwnProperty(e)&&r.push(e);H(n,r,W,!1)})(t),(0,l.A)(i)||G._materialCache.addMaterial(t.type,t),function(e){const t=e._template.components,n=e._template.source;if((0,l.A)(n))e.shaderSource+=`${n}\n`;else{if(e.shaderSource+="czm_material czm_getMaterial(czm_materialInput materialInput)\n{\n",e.shaderSource+="czm_material material = czm_getDefaultMaterial(materialInput);\n",(0,l.A)(t)){const n=Object.keys(e._template.materials).length>0;for(const i in t)if(t.hasOwnProperty(i))if("diffuse"===i||"emission"===i){const o=n&&Y(t[i],e)?t[i]:`czm_gammaCorrect(${t[i]})`;e.shaderSource+=`material.${i} = ${o}; \n`}else e.shaderSource+="alpha"===i?`material.alpha = ${t.alpha}; \n`:`material.${i} = ${t[i]};\n`}e.shaderSource+="return material;\n}\n"}}(t),function(e){const t=e._template.uniforms;for(const n in t)t.hasOwnProperty(n)&&Z(e,n)}(t),function(e){const t=e._strict,n=e._template.materials;for(const i in n)if(n.hasOwnProperty(i)){const o=new G({strict:t,fabric:n[i],count:e._count});e._count=o._count,e._uniforms=(0,a.A)(e._uniforms,o._uniforms,!0),e.materials[i]=o,e._translucentFunctions=e._translucentFunctions.concat(o._translucentFunctions);const r="czm_getMaterial",s=`${r}_${e._count++}`;if(K(o,r,s),e.shaderSource=o.shaderSource+e.shaderSource,0===K(e,i,`${s}(materialInput)`)&&t)throw new u.A(`strict: shader source does not use material '${i}'.`)}}(t);const r=0===t._translucentFunctions.length||void 0;if(n=n??r,n=e.translucent??n,(0,l.A)(n))if("function"==typeof n){const e=function(){return n(t)};t._translucentFunctions.push(e)}else t._translucentFunctions.push(n)}(e,this),Object.defineProperties(this,{type:{value:this.type,writable:!1}}),(0,l.A)(G._uniformList[this.type])||(G._uniformList[this.type]=Object.keys(this._uniforms))}function H(e,t,n,i){if((0,l.A)(e))for(const o in e)if(e.hasOwnProperty(o)){const e=-1!==t.indexOf(o);(i&&!e||!i&&e)&&n(o,t)}}function U(e,t){let n=`fabric: property name '${e}' is not valid. It should be `;for(let e=0;e<t.length;e++){const i=`'${t[e]}'`;n+=e===t.length-1?`or ${i}.`:`${i}, `}throw new u.A(n)}function W(e,t){const n=`fabric: uniforms and materials cannot share the same property '${e}'`;throw new u.A(n)}G._uniformList={},G.fromType=function(e,t){if(!(0,l.A)(G._materialCache.getMaterial(e)))throw new u.A(`material with type '${e}' does not exist.`);const n=new G({fabric:{type:e}});if((0,l.A)(t))for(const e in t)t.hasOwnProperty(e)&&(n.uniforms[e]=t[e]);return n},G.prototype.isTranslucent=function(){if((0,l.A)(this.translucent))return"function"==typeof this.translucent?this.translucent():this.translucent;let e=!0;const t=this._translucentFunctions,n=t.length;for(let i=0;i<n;++i){const n=t[i];if(e="function"==typeof n?e&&n():e&&n,!e)break}return e},G.prototype.update=function(e){let t,n;this._defaultTexture=e.defaultTexture;const i=this._loadedImages;let o=i.length;for(t=0;t<o;++t){const o=i[t];n=o.id;let r,a=o.image;Array.isArray(a)&&(r=a.slice(1,a.length).map(function(e){return e.bufferView}),a=a[0]);const s=new N.A({minificationFilter:this._minificationFilter,magnificationFilter:this._magnificationFilter});let c;c=(0,l.A)(a.internalFormat)?new g.A({context:e,pixelFormat:a.internalFormat,width:a.width,height:a.height,source:{arrayBufferView:a.bufferView,mipLevels:r},sampler:s}):new g.A({context:e,source:a,sampler:s});const h=this._textures[n];(0,l.A)(h)&&h!==this._defaultTexture&&h.destroy(),this._textures[n]=c;const u=`${n}Dimensions`;if(this.uniforms.hasOwnProperty(u)){const e=this.uniforms[u];e.x=c._width,e.y=c._height}}i.length=0;const r=this._loadedCubeMaps;for(o=r.length,t=0;t<o;++t){const i=r[t];n=i.id;const o=i.images,a=new _.A({context:e,source:{positiveX:o[0],negativeX:o[1],positiveY:o[2],negativeY:o[3],positiveZ:o[4],negativeZ:o[5]},sampler:new N.A({minificationFilter:this._minificationFilter,magnificationFilter:this._magnificationFilter})});this._textures[n]=a}r.length=0;const a=this._updateFunctions;for(o=a.length,t=0;t<o;++t)a[t](this,e);const s=this.materials;for(const t in s)s.hasOwnProperty(t)&&s[t].update(e)},G.prototype.isDestroyed=function(){return!1},G.prototype.destroy=function(){const e=this._textures;for(const t in e)if(e.hasOwnProperty(t)){const n=e[t];n!==this._defaultTexture&&n.destroy()}const t=this.materials;for(const e in t)t.hasOwnProperty(e)&&t[e].destroy();return(0,h.A)(this)};const q=["type","materials","uniforms","components","source"],j=["diffuse","specular","shininess","normal","emission","alpha"];function Y(e,t){const n=t._template.materials;for(const t in n)if(n.hasOwnProperty(t)&&e.indexOf(t)>-1)return!0;return!1}const X={mat2:p.A,mat3:m.A,mat4:f.A},$=/\.ktx2$/i;function Z(e,t){const n=e._strict,i=e._template.uniforms,o=i[t],r=function(e){let t=e.type;if(!(0,l.A)(t)){const n=typeof e;if("number"===n)t="float";else if("boolean"===n)t="bool";else if("string"===n||e instanceof A.A||e instanceof HTMLCanvasElement||e instanceof HTMLImageElement||e instanceof ImageBitmap||e instanceof OffscreenCanvas)t=/^([rgba]){1,4}$/i.test(e)?"channels":e===G.DefaultCubeMapId?"samplerCube":"sampler2D";else if("object"===n)if(Array.isArray(e))4!==e.length&&9!==e.length&&16!==e.length||(t=`mat${Math.sqrt(e.length)}`);else{let n=0;for(const t in e)e.hasOwnProperty(t)&&(n+=1);n>=2&&n<=4?t=`vec${n}`:6===n&&(t="samplerCube")}}return t}(o);if(!(0,l.A)(r))throw new u.A(`fabric: uniform '${t}' has invalid type.`);let a;if("channels"===r){if(a=K(e,t,o,!1),0===a&&n)throw new u.A(`strict: shader source does not use channels '${t}'.`)}else{if("sampler2D"===r){const n=`${t}Dimensions`;(function(e,t){return K(e,t,t,void 0)})(e,n)>0&&(i[n]={type:"ivec3",x:1,y:1},Z(e,n))}if(!new RegExp(`uniform\\s+${r}\\s+${t}\\s*;`).test(e.shaderSource)){const n=`uniform ${r} ${t};`;e.shaderSource=n+e.shaderSource}const s=`${t}_${e._count++}`;if(a=K(e,t,s),1===a&&n)throw new u.A(`strict: shader source does not use uniform '${t}'.`);if(e.uniforms[t]=o,"sampler2D"===r)e._uniforms[s]=function(){return e._textures[t]},e._updateFunctions.push(function(e){let t;return function(n,i){const o=n.uniforms,r=o[e],a=t!==r,s=!(0,l.A)(r)||r===G.DefaultImageId;t=r;let c,h,u=n._textures[e];if(r instanceof HTMLVideoElement){if(r.readyState>=2){if(a&&(0,l.A)(u)&&(u!==i.defaultTexture&&u.destroy(),u=void 0),!(0,l.A)(u)||u===i.defaultTexture){const t=new N.A({minificationFilter:n._minificationFilter,magnificationFilter:n._magnificationFilter});return u=new g.A({context:i,source:r,sampler:t}),void(n._textures[e]=u)}u.copyFrom({source:r})}else(0,l.A)(u)||(n._textures[e]=i.defaultTexture);return}if(r instanceof g.A&&r!==u){n._texturePaths[e]=void 0;const t=n._textures[e];return(0,l.A)(t)&&t!==n._defaultTexture&&t.destroy(),n._textures[e]=r,c=`${e}Dimensions`,void(o.hasOwnProperty(c)&&(h=o[c],h.x=r._width,h.y=r._height))}if(a&&(0,l.A)(u)&&s&&(u!==n._defaultTexture&&u.destroy(),u=void 0),(0,l.A)(u)||(n._texturePaths[e]=void 0,u=n._textures[e]=n._defaultTexture,c=`${e}Dimensions`,o.hasOwnProperty(c)&&(h=o[c],h.x=u._width,h.y=u._height)),s)return;const p=r instanceof A.A;if(!(0,l.A)(n._texturePaths[e])||p&&r.url!==n._texturePaths[e].url||!p&&r!==n._texturePaths[e]){if("string"==typeof r||p){const t=p?r:A.A.createIfNeeded(r);let i;i=$.test(t.url)?(0,d.A)(t.url):t.fetchImage(),Promise.resolve(i).then(function(t){n._loadedImages.push({id:e,image:t})}).catch(function(){(0,l.A)(u)&&u!==n._defaultTexture&&u.destroy(),n._textures[e]=n._defaultTexture})}else(r instanceof HTMLCanvasElement||r instanceof HTMLImageElement||r instanceof ImageBitmap||r instanceof OffscreenCanvas)&&n._loadedImages.push({id:e,image:r});n._texturePaths[e]=r}}}(t));else if("samplerCube"===r)e._uniforms[s]=function(){return e._textures[t]},e._updateFunctions.push(function(e){return function(t,n){const i=t.uniforms[e];if(i instanceof _.A){const n=t._textures[e];return n!==t._defaultTexture&&n.destroy(),t._texturePaths[e]=void 0,void(t._textures[e]=i)}if((0,l.A)(t._textures[e])||(t._texturePaths[e]=void 0,t._textures[e]=n.defaultCubeMap),i===G.DefaultCubeMapId)return;const o=i.positiveX+i.negativeX+i.positiveY+i.negativeY+i.positiveZ+i.negativeZ;if(o!==t._texturePaths[e]){const n=[A.A.createIfNeeded(i.positiveX).fetchImage(),A.A.createIfNeeded(i.negativeX).fetchImage(),A.A.createIfNeeded(i.positiveY).fetchImage(),A.A.createIfNeeded(i.negativeY).fetchImage(),A.A.createIfNeeded(i.positiveZ).fetchImage(),A.A.createIfNeeded(i.negativeZ).fetchImage()];Promise.all(n).then(function(n){t._loadedCubeMaps.push({id:e,images:n})}),t._texturePaths[e]=o}}}(t));else if(-1!==r.indexOf("mat")){const n=new X[r];e._uniforms[s]=function(){return X[r].fromColumnMajorArray(e.uniforms[t],n)}}else e._uniforms[s]=function(){return e.uniforms[t]}}}function K(e,t,n,i){i=i??!0;let o=0;const r=new RegExp(`([\\w${i?".":""}])?`+t+"([\\w])?","g");return e.shaderSource=e.shaderSource.replace(r,function(e,t,i){return t||i?e:(o+=1,n)}),o}G._materialCache={_materials:{},addMaterial:function(e,t){this._materials[e]=t},getMaterial:function(e){return this._materials[e]}},G.DefaultImageId="czm_defaultImage",G.DefaultCubeMapId="czm_defaultCubeMap",G.ColorType="Color",G._materialCache.addMaterial(G.ColorType,{fabric:{type:G.ColorType,uniforms:{color:new r.A(1,0,0,.5)},components:{diffuse:"color.rgb",alpha:"color.a"}},translucent:function(e){return e.uniforms.color.alpha<1}}),G.ImageType="Image",G._materialCache.addMaterial(G.ImageType,{fabric:{type:G.ImageType,uniforms:{image:G.DefaultImageId,repeat:new i.A(1,1),color:new r.A(1,1,1,1)},components:{diffuse:"texture(image, fract(repeat * materialInput.st)).rgb * color.rgb",alpha:"texture(image, fract(repeat * materialInput.st)).a * color.a"}},translucent:function(e){return e.uniforms.color.alpha<1}}),G.DiffuseMapType="DiffuseMap",G._materialCache.addMaterial(G.DiffuseMapType,{fabric:{type:G.DiffuseMapType,uniforms:{image:G.DefaultImageId,channels:"rgb",repeat:new i.A(1,1)},components:{diffuse:"texture(image, fract(repeat * materialInput.st)).channels"}},translucent:!1}),G.AlphaMapType="AlphaMap",G._materialCache.addMaterial(G.AlphaMapType,{fabric:{type:G.AlphaMapType,uniforms:{image:G.DefaultImageId,channel:"a",repeat:new i.A(1,1)},components:{alpha:"texture(image, fract(repeat * materialInput.st)).channel"}},translucent:!0}),G.SpecularMapType="SpecularMap",G._materialCache.addMaterial(G.SpecularMapType,{fabric:{type:G.SpecularMapType,uniforms:{image:G.DefaultImageId,channel:"r",repeat:new i.A(1,1)},components:{specular:"texture(image, fract(repeat * materialInput.st)).channel"}},translucent:!1}),G.EmissionMapType="EmissionMap",G._materialCache.addMaterial(G.EmissionMapType,{fabric:{type:G.EmissionMapType,uniforms:{image:G.DefaultImageId,channels:"rgb",repeat:new i.A(1,1)},components:{emission:"texture(image, fract(repeat * materialInput.st)).channels"}},translucent:!1}),G.BumpMapType="BumpMap",G._materialCache.addMaterial(G.BumpMapType,{fabric:{type:G.BumpMapType,uniforms:{image:G.DefaultImageId,channel:"r",strength:.8,repeat:new i.A(1,1)},source:v.A},translucent:!1}),G.NormalMapType="NormalMap",G._materialCache.addMaterial(G.NormalMapType,{fabric:{type:G.NormalMapType,uniforms:{image:G.DefaultImageId,channels:"rgb",strength:.8,repeat:new i.A(1,1)},source:D.A},translucent:!1}),G.GridType="Grid",G._materialCache.addMaterial(G.GridType,{fabric:{type:G.GridType,uniforms:{color:new r.A(0,1,0,1),cellAlpha:.1,lineCount:new i.A(8,8),lineThickness:new i.A(1,1),lineOffset:new i.A(0,0)},source:S.A},translucent:function(e){const t=e.uniforms;return t.color.alpha<1||t.cellAlpha<1}}),G.StripeType="Stripe",G._materialCache.addMaterial(G.StripeType,{fabric:{type:G.StripeType,uniforms:{horizontal:!0,evenColor:new r.A(1,1,1,.5),oddColor:new r.A(0,0,1,.5),offset:0,repeat:5},source:M.A},translucent:function(e){const t=e.uniforms;return t.evenColor.alpha<1||t.oddColor.alpha<1}}),G.CheckerboardType="Checkerboard",G._materialCache.addMaterial(G.CheckerboardType,{fabric:{type:G.CheckerboardType,uniforms:{lightColor:new r.A(1,1,1,.5),darkColor:new r.A(0,0,0,.5),repeat:new i.A(5,5)},source:b.A},translucent:function(e){const t=e.uniforms;return t.lightColor.alpha<1||t.darkColor.alpha<1}}),G.DotType="Dot",G._materialCache.addMaterial(G.DotType,{fabric:{type:G.DotType,uniforms:{lightColor:new r.A(1,1,0,.75),darkColor:new r.A(0,1,1,.75),repeat:new i.A(5,5)},source:w.A},translucent:function(e){const t=e.uniforms;return t.lightColor.alpha<1||t.darkColor.alpha<1}}),G.WaterType="Water",G._materialCache.addMaterial(G.WaterType,{fabric:{type:G.WaterType,uniforms:{baseWaterColor:new r.A(.2,.3,.6,1),blendColor:new r.A(0,1,.699,1),specularMap:G.DefaultImageId,normalMap:G.DefaultImageId,frequency:10,animationSpeed:.01,amplitude:1,specularIntensity:.5,fadeFactor:1},source:V.A},translucent:function(e){const t=e.uniforms;return t.baseWaterColor.alpha<1||t.blendColor.alpha<1}}),G.RimLightingType="RimLighting",G._materialCache.addMaterial(G.RimLightingType,{fabric:{type:G.RimLightingType,uniforms:{color:new r.A(1,0,0,.7),rimColor:new r.A(1,1,1,.4),width:.3},source:R.A},translucent:function(e){const t=e.uniforms;return t.color.alpha<1||t.rimColor.alpha<1}}),G.FadeType="Fade",G._materialCache.addMaterial(G.FadeType,{fabric:{type:G.FadeType,uniforms:{fadeInColor:new r.A(1,0,0,1),fadeOutColor:new r.A(0,0,0,0),maximumDistance:.5,repeat:!0,fadeDirection:{x:!0,y:!0},time:new i.A(.5,.5)},source:E.A},translucent:function(e){const t=e.uniforms;return t.fadeInColor.alpha<1||t.fadeOutColor.alpha<1}}),G.PolylineArrowType="PolylineArrow",G._materialCache.addMaterial(G.PolylineArrowType,{fabric:{type:G.PolylineArrowType,uniforms:{color:new r.A(1,1,1,1)},source:O.A},translucent:!0}),G.PolylineDashType="PolylineDash",G._materialCache.addMaterial(G.PolylineDashType,{fabric:{type:G.PolylineDashType,uniforms:{color:new r.A(1,0,1,1),gapColor:new r.A(0,0,0,0),dashLength:16,dashPattern:255},source:z.A},translucent:!0}),G.PolylineGlowType="PolylineGlow",G._materialCache.addMaterial(G.PolylineGlowType,{fabric:{type:G.PolylineGlowType,uniforms:{color:new r.A(0,.5,1,1),glowPower:.25,taperPower:1},source:I.A},translucent:!0}),G.PolylineOutlineType="PolylineOutline",G._materialCache.addMaterial(G.PolylineOutlineType,{fabric:{type:G.PolylineOutlineType,uniforms:{color:new r.A(1,1,1,1),outlineColor:new r.A(1,0,0,1),outlineWidth:1},source:P.A},translucent:function(e){const t=e.uniforms;return t.color.alpha<1||t.outlineColor.alpha<1}}),G.ElevationContourType="ElevationContour",G._materialCache.addMaterial(G.ElevationContourType,{fabric:{type:G.ElevationContourType,uniforms:{spacing:100,color:new r.A(1,0,0,1),width:1},source:x.A},translucent:!1}),G.ElevationRampType="ElevationRamp",G._materialCache.addMaterial(G.ElevationRampType,{fabric:{type:G.ElevationRampType,uniforms:{image:G.DefaultImageId,minimumHeight:0,maximumHeight:1e4},source:C.A},translucent:!1}),G.SlopeRampMaterialType="SlopeRamp",G._materialCache.addMaterial(G.SlopeRampMaterialType,{fabric:{type:G.SlopeRampMaterialType,uniforms:{image:G.DefaultImageId},source:L.A},translucent:!1}),G.AspectRampMaterialType="AspectRamp",G._materialCache.addMaterial(G.AspectRampMaterialType,{fabric:{type:G.AspectRampMaterialType,uniforms:{image:G.DefaultImageId},source:y.A},translucent:!1}),G.ElevationBandType="ElevationBand",G._materialCache.addMaterial(G.ElevationBandType,{fabric:{type:G.ElevationBandType,uniforms:{heights:G.DefaultImageId,colors:G.DefaultImageId},source:T.A},translucent:!0}),G.WaterMaskType="WaterMask",G._materialCache.addMaterial(G.WaterMaskType,{fabric:{type:G.WaterMaskType,source:k.A,uniforms:{waterColor:new r.A(1,1,1,1),landColor:new r.A(0,0,0,0)}},translucent:!1});const Q=G},612123:(e,t,n)=>{"use strict";n.d(t,{A:()=>u});var i=n(915325),o=n(769534),r=n(495702),a=n(328326),s=n(857831),c=n(537335),l=n(207828);function h(e){const t=(e=e??i.A.EMPTY_OBJECT).translucent??!0,n=e.closed??!1,o=e.flat??!1,u=o?c.A:a.A,d=o?s.A:r.A,p=o?h.FLAT_VERTEX_FORMAT:h.VERTEX_FORMAT;this.material=void 0,this.translucent=t,this._vertexShaderSource=e.vertexShaderSource??u,this._fragmentShaderSource=e.fragmentShaderSource??d,this._renderState=l.A.getDefaultRenderState(t,n,e.renderState),this._closed=n,this._vertexFormat=p,this._flat=o,this._faceForward=e.faceForward??!n}Object.defineProperties(h.prototype,{vertexShaderSource:{get:function(){return this._vertexShaderSource}},fragmentShaderSource:{get:function(){return this._fragmentShaderSource}},renderState:{get:function(){return this._renderState}},closed:{get:function(){return this._closed}},vertexFormat:{get:function(){return this._vertexFormat}},flat:{get:function(){return this._flat}},faceForward:{get:function(){return this._faceForward}}}),h.VERTEX_FORMAT=o.A.POSITION_AND_NORMAL,h.FLAT_VERTEX_FORMAT=o.A.POSITION_ONLY,h.prototype.getFragmentShaderSource=l.A.prototype.getFragmentShaderSource,h.prototype.isTranslucent=l.A.prototype.isTranslucent,h.prototype.getRenderState=l.A.prototype.getRenderState;const u=h},520853:(e,t,n)=>{"use strict";n.d(t,{A:()=>P});var i=n(647934),o=n(434067),r=n(267980),a=n(626809),s=n(41476),c=n(915325),l=n(491446),h=n(605971),u=n(853331),d=n(584164),p=n(290176),m=n(62467),f=n(78173),A=n(913419);function _(e,t){if(e=e??c.A.EMPTY_OBJECT,(0,l.A)(e.disableDepthTestDistance)&&e.disableDepthTestDistance<0)throw new h.A("disableDepthTestDistance must be greater than or equal to 0.0.");let n=e.translucencyByDistance,i=e.scaleByDistance,o=e.distanceDisplayCondition;if((0,l.A)(n)){if(n.far<=n.near)throw new h.A("translucencyByDistance.far must be greater than translucencyByDistance.near.");n=p.A.clone(n)}if((0,l.A)(i)){if(i.far<=i.near)throw new h.A("scaleByDistance.far must be greater than scaleByDistance.near.");i=p.A.clone(i)}if((0,l.A)(o)){if(o.far<=o.near)throw new h.A("distanceDisplayCondition.far must be greater than distanceDisplayCondition.near.");o=u.A.clone(o)}this._show=e.show??!0,this._position=r.A.clone(e.position??r.A.ZERO),this._actualPosition=r.A.clone(this._position),this._color=s.A.clone(e.color??s.A.WHITE),this._outlineColor=s.A.clone(e.outlineColor??s.A.TRANSPARENT),this._outlineWidth=e.outlineWidth??0,this._pixelSize=e.pixelSize??10,this._scaleByDistance=i,this._translucencyByDistance=n,this._distanceDisplayCondition=o,this._disableDepthTestDistance=e.disableDepthTestDistance??0,this._id=e.id,this._collection=e.collection??t,this._clusterShow=!0,this._pickId=void 0,this._pointPrimitiveCollection=t,this._dirty=!1,this._index=-1,this._splitDirection=e.splitDirection??A.A.NONE}const g=_.SHOW_INDEX=0,y=_.POSITION_INDEX=1,v=_.COLOR_INDEX=2,b=_.OUTLINE_COLOR_INDEX=3,w=_.OUTLINE_WIDTH_INDEX=4,T=_.PIXEL_SIZE_INDEX=5,x=_.SCALE_BY_DISTANCE_INDEX=6,C=_.TRANSLUCENCY_BY_DISTANCE_INDEX=7,E=_.DISTANCE_DISPLAY_CONDITION_INDEX=8,S=_.DISABLE_DEPTH_DISTANCE_INDEX=9,D=_.SPLIT_DIRECTION_INDEX=10;function O(e,t){const n=e._pointPrimitiveCollection;(0,l.A)(n)&&(n._updatePointPrimitive(e,t),e._dirty=!0)}_.NUMBER_OF_PROPERTIES=11,Object.defineProperties(_.prototype,{show:{get:function(){return this._show},set:function(e){if(!(0,l.A)(e))throw new h.A("value is required.");this._show!==e&&(this._show=e,O(this,g))}},position:{get:function(){return this._position},set:function(e){if(!(0,l.A)(e))throw new h.A("value is required.");const t=this._position;r.A.equals(t,e)||(r.A.clone(e,t),r.A.clone(e,this._actualPosition),O(this,y))}},scaleByDistance:{get:function(){return this._scaleByDistance},set:function(e){if((0,l.A)(e)&&e.far<=e.near)throw new h.A("far distance must be greater than near distance.");const t=this._scaleByDistance;p.A.equals(t,e)||(this._scaleByDistance=p.A.clone(e,t),O(this,x))}},translucencyByDistance:{get:function(){return this._translucencyByDistance},set:function(e){if((0,l.A)(e)&&e.far<=e.near)throw new h.A("far distance must be greater than near distance.");const t=this._translucencyByDistance;p.A.equals(t,e)||(this._translucencyByDistance=p.A.clone(e,t),O(this,C))}},pixelSize:{get:function(){return this._pixelSize},set:function(e){if(!(0,l.A)(e))throw new h.A("value is required.");this._pixelSize!==e&&(this._pixelSize=e,O(this,T))}},color:{get:function(){return this._color},set:function(e){if(!(0,l.A)(e))throw new h.A("value is required.");const t=this._color;s.A.equals(t,e)||(s.A.clone(e,t),O(this,v))}},outlineColor:{get:function(){return this._outlineColor},set:function(e){if(!(0,l.A)(e))throw new h.A("value is required.");const t=this._outlineColor;s.A.equals(t,e)||(s.A.clone(e,t),O(this,b))}},outlineWidth:{get:function(){return this._outlineWidth},set:function(e){if(!(0,l.A)(e))throw new h.A("value is required.");this._outlineWidth!==e&&(this._outlineWidth=e,O(this,w))}},distanceDisplayCondition:{get:function(){return this._distanceDisplayCondition},set:function(e){if((0,l.A)(e)&&e.far<=e.near)throw new h.A("far must be greater than near");u.A.equals(this._distanceDisplayCondition,e)||(this._distanceDisplayCondition=u.A.clone(e,this._distanceDisplayCondition),O(this,E))}},disableDepthTestDistance:{get:function(){return this._disableDepthTestDistance},set:function(e){if(this._disableDepthTestDistance!==e){if(!(0,l.A)(e)||e<0)throw new h.A("disableDepthTestDistance must be greater than or equal to 0.0.");this._disableDepthTestDistance=e,O(this,S)}}},id:{get:function(){return this._id},set:function(e){this._id=e,(0,l.A)(this._pickId)&&(this._pickId.object.id=e)}},pickId:{get:function(){return this._pickId}},clusterShow:{get:function(){return this._clusterShow},set:function(e){this._clusterShow!==e&&(this._clusterShow=e,O(this,g))}},splitDirection:{get:function(){return this._splitDirection},set:function(e){this._splitDirection!==e&&(this._splitDirection=e,O(this,D))}}}),_.prototype.getPickId=function(e){return(0,l.A)(this._pickId)||(this._pickId=e.createPickId({primitive:this,collection:this._collection,id:this._id})),this._pickId},_.prototype._getActualPosition=function(){return this._actualPosition},_.prototype._setActualPosition=function(e){r.A.clone(e,this._actualPosition),O(this,y)};const z=new a.A;_._computeActualPosition=function(e,t,n){return t.mode===m.A.SCENE3D?e:(d.A.multiplyByPoint(n,e,z),f.A.computeActualEllipsoidPosition(t,z))};const I=new a.A;_._computeScreenSpacePosition=function(e,t,n,i){const o=d.A.multiplyByVector(e,a.A.fromElements(t.x,t.y,t.z,1,I),I);return f.A.worldToWindowCoordinates(n,o,i)},_.prototype.computeScreenSpacePosition=function(e,t){const n=this._pointPrimitiveCollection;if((0,l.A)(t)||(t=new o.A),!(0,l.A)(n))throw new h.A("PointPrimitive must be in a collection.");if(!(0,l.A)(e))throw new h.A("scene is required.");const i=n.modelMatrix,r=_._computeScreenSpacePosition(i,this._actualPosition,e,t);if((0,l.A)(r))return r.y=e.canvas.clientHeight-r.y,r},_.getScreenSpaceBoundingBox=function(e,t,n){const o=e.pixelSize,r=.5*o,a=t.x-r,s=t.y-r,c=o,h=o;return(0,l.A)(n)||(n=new i.A),n.x=a,n.y=s,n.width=c,n.height=h,n},_.prototype.equals=function(e){return this===e||(0,l.A)(e)&&this._id===e._id&&r.A.equals(this._position,e._position)&&s.A.equals(this._color,e._color)&&this._pixelSize===e._pixelSize&&this._outlineWidth===e._outlineWidth&&this._show===e._show&&s.A.equals(this._outlineColor,e._outlineColor)&&p.A.equals(this._scaleByDistance,e._scaleByDistance)&&p.A.equals(this._translucencyByDistance,e._translucencyByDistance)&&u.A.equals(this._distanceDisplayCondition,e._distanceDisplayCondition)&&this._disableDepthTestDistance===e._disableDepthTestDistance&&this._splitDirection===e._splitDirection},_.prototype._destroy=function(){this._pickId=this._pickId&&this._pickId.destroy(),this._pointPrimitiveCollection=void 0};const P=_},24013:(e,t,n)=>{"use strict";n.d(t,{A:()=>ne});var i=n(660662),o=n(41476),r=n(571804),a=n(915325),s=n(491446),c=n(677354),l=n(605971),h=n(816422),u=n(367817),d=n(584164),p=n(402330),m=n(352581),f=n(442790),A=n(430332),_=n(377496),g=n(760866),y=n(40118),v=n(302836),b=n(342875),w=n(193470),T=n(208276),x=n(510148),C=n(200646),E=n(416882),S=n(520853),D=n(62467);const O=S.A.SHOW_INDEX,z=S.A.POSITION_INDEX,I=S.A.COLOR_INDEX,P=S.A.OUTLINE_COLOR_INDEX,R=S.A.OUTLINE_WIDTH_INDEX,N=S.A.PIXEL_SIZE_INDEX,L=S.A.SCALE_BY_DISTANCE_INDEX,M=S.A.TRANSLUCENCY_BY_DISTANCE_INDEX,F=S.A.DISTANCE_DISPLAY_CONDITION_INDEX,B=S.A.DISABLE_DEPTH_DISTANCE_INDEX,k=S.A.SPLIT_DIRECTION_INDEX,V=S.A.NUMBER_OF_PROPERTIES,G={positionHighAndSize:0,positionLowAndOutline:1,compressedAttribute0:2,compressedAttribute1:3,scaleByDistance:4,distanceDisplayConditionAndDisableDepthAndSplitDirection:5};function H(e){e=e??a.A.EMPTY_OBJECT,this._sp=void 0,this._spTranslucent=void 0,this._rsOpaque=void 0,this._rsTranslucent=void 0,this._vaf=void 0,this._pointPrimitives=[],this._pointPrimitivesToUpdate=[],this._pointPrimitivesToUpdateIndex=0,this._pointPrimitivesRemoved=!1,this._createVertexArray=!1,this._shaderScaleByDistance=!1,this._compiledShaderScaleByDistance=!1,this._shaderTranslucencyByDistance=!1,this._compiledShaderTranslucencyByDistance=!1,this._shaderDistanceDisplayCondition=!1,this._compiledShaderDistanceDisplayCondition=!1,this._shaderDisableDepthDistance=!1,this._compiledShaderDisableDepthDistance=!1,this._propertiesChanged=new Uint32Array(V),this._maxPixelSize=1,this._baseVolume=new i.A,this._baseVolumeWC=new i.A,this._baseVolume2D=new i.A,this._boundingVolume=new i.A,this._boundingVolumeDirty=!1,this._colorCommands=[],this.show=e.show??!0,this.modelMatrix=d.A.clone(e.modelMatrix??d.A.IDENTITY),this._modelMatrix=d.A.clone(d.A.IDENTITY),this.debugShowBoundingVolume=e.debugShowBoundingVolume??!1,this.blendOption=e.blendOption??E.A.OPAQUE_AND_TRANSLUCENT,this._blendOption=void 0,this._mode=D.A.SCENE3D,this._maxTotalPointSize=1,this._buffersUsage=[f.A.STATIC_DRAW,f.A.STATIC_DRAW,f.A.STATIC_DRAW,f.A.STATIC_DRAW,f.A.STATIC_DRAW,f.A.STATIC_DRAW,f.A.STATIC_DRAW,f.A.STATIC_DRAW,f.A.STATIC_DRAW];const t=this;this._uniforms={u_maxTotalPointSize:function(){return t._maxTotalPointSize}}}function U(e){const t=e.length;for(let n=0;n<t;++n)e[n]&&e[n]._destroy()}function W(e){if(e._pointPrimitivesRemoved){e._pointPrimitivesRemoved=!1;const t=[],n=e._pointPrimitives,i=n.length;for(let e=0,o=0;e<i;++e){const i=n[e];i&&(i._index=o++,t.push(i))}e._pointPrimitives=t}}Object.defineProperties(H.prototype,{length:{get:function(){return W(this),this._pointPrimitives.length}}}),H.prototype.add=function(e){const t=new S.A(e,this);return t._index=this._pointPrimitives.length,this._pointPrimitives.push(t),this._createVertexArray=!0,t},H.prototype.remove=function(e){return!!this.contains(e)&&(this._pointPrimitives[e._index]=null,this._pointPrimitivesRemoved=!0,this._createVertexArray=!0,e._destroy(),!0)},H.prototype.removeAll=function(){U(this._pointPrimitives),this._pointPrimitives=[],this._pointPrimitivesToUpdate=[],this._pointPrimitivesToUpdateIndex=0,this._pointPrimitivesRemoved=!1,this._createVertexArray=!0},H.prototype._updatePointPrimitive=function(e,t){e._dirty||(this._pointPrimitivesToUpdate[this._pointPrimitivesToUpdateIndex++]=e),++this._propertiesChanged[t]},H.prototype.contains=function(e){return(0,s.A)(e)&&e._pointPrimitiveCollection===this},H.prototype.get=function(e){if(!(0,s.A)(e))throw new l.A("index is required.");return W(this),this._pointPrimitives[e]},H.prototype.computeNewBuffersUsage=function(){const e=this._buffersUsage;let t=!1;const n=this._propertiesChanged;for(let i=0;i<V;++i){const o=0===n[i]?f.A.STATIC_DRAW:f.A.STREAM_DRAW;t=t||e[i]!==o,e[i]=o}return t};const q=new h.A;function j(e,t,n,o){const r=o._index,a=o._getActualPosition();e._mode===D.A.SCENE3D&&(i.A.expand(e._baseVolume,a,e._baseVolume),e._boundingVolumeDirty=!0),h.A.fromCartesian(a,q);const s=o.pixelSize,c=o.outlineWidth;e._maxPixelSize=Math.max(e._maxPixelSize,s+c);const l=n[G.positionHighAndSize],u=q.high;l(r,u.x,u.y,u.z,s);const d=n[G.positionLowAndOutline],p=q.low;d(r,p.x,p.y,p.z,c)}const Y=65536,X=256;function $(e,t,n,i){const r=i._index,a=i.color,s=i.getPickId(t).color,c=i.outlineColor;let l=o.A.floatToByte(a.red),h=o.A.floatToByte(a.green),u=o.A.floatToByte(a.blue);const d=l*Y+h*X+u;l=o.A.floatToByte(c.red),h=o.A.floatToByte(c.green),u=o.A.floatToByte(c.blue);const p=l*Y+h*X+u;l=o.A.floatToByte(s.red),h=o.A.floatToByte(s.green),u=o.A.floatToByte(s.blue);const m=l*Y+h*X+u,f=o.A.floatToByte(a.alpha)*Y+o.A.floatToByte(c.alpha)*X+o.A.floatToByte(s.alpha);(0,n[G.compressedAttribute0])(r,d,p,m,f)}function Z(e,t,n,i){const o=i._index;let r=0,a=1,c=1,l=1;const h=i.translucencyByDistance;(0,s.A)(h)&&(r=h.near,a=h.nearValue,c=h.far,l=h.farValue,1===a&&1===l||(e._shaderTranslucencyByDistance=!0));let d=i.show&&i.clusterShow;0===i.color.alpha&&0===i.outlineColor.alpha&&(d=!1),a=u.A.clamp(a,0,1),a=1===a?255:255*a|0;const p=(d?1:0)*X+a;l=u.A.clamp(l,0,1),l=1===l?255:255*l|0;const m=l;(0,n[G.compressedAttribute1])(o,p,m,r,c)}function K(e,t,n,i){const o=i._index,r=n[G.scaleByDistance];let a=0,c=1,l=1,h=1;const u=i.scaleByDistance;(0,s.A)(u)&&(a=u.near,c=u.nearValue,l=u.far,h=u.farValue,1===c&&1===h||(e._shaderScaleByDistance=!0)),r(o,a,c,l,h)}function Q(e,t,n,i){const o=i._index,r=n[G.distanceDisplayConditionAndDisableDepthAndSplitDirection];let a=0,c=Number.MAX_VALUE;const l=i.distanceDisplayCondition;(0,s.A)(l)&&(a=l.near,c=l.far,a*=a,c*=c,e._shaderDistanceDisplayCondition=!0);let h=i.disableDepthTestDistance;h*=h,h>0&&(e._shaderDisableDepthDistance=!0,h===Number.POSITIVE_INFINITY&&(h=-1));let u=0;const d=i.splitDirection;(0,s.A)(d)&&(u=d),r(o,a,c,h,u)}function J(e,t,n,i){j(e,0,n,i),$(0,t,n,i),Z(e,0,n,i),K(e,0,n,i),Q(e,0,n,i)}function ee(e,t,n,o,r,a){let c;o.mode===D.A.SCENE3D?(c=e._baseVolume,e._boundingVolumeDirty=!0):c=e._baseVolume2D;const l=[];for(let e=0;e<n;++e){const n=t[e],h=n.position,u=S.A._computeActualPosition(h,o,r);(0,s.A)(u)&&(n._setActualPosition(u),a?l.push(u):i.A.expand(c,u,c))}a&&i.A.fromPoints(l,c)}const te=[];H.prototype.update=function(e){if(W(this),!this.show)return;this._maxTotalPointSize=A.A.maximumAliasedPointSize,function(e,t){const n=t.mode,i=e._pointPrimitives,o=e._pointPrimitivesToUpdate,r=e._modelMatrix;e._createVertexArray||e._mode!==n||n!==D.A.SCENE3D&&!d.A.equals(r,e.modelMatrix)?(e._mode=n,d.A.clone(e.modelMatrix,r),e._createVertexArray=!0,n!==D.A.SCENE3D&&n!==D.A.SCENE2D&&n!==D.A.COLUMBUS_VIEW||ee(e,i,i.length,t,r,!0)):n===D.A.MORPHING?ee(e,i,i.length,t,r,!0):n!==D.A.SCENE2D&&n!==D.A.COLUMBUS_VIEW||ee(e,o,e._pointPrimitivesToUpdateIndex,t,r,!1)}(this,e);const t=this._pointPrimitives.length,n=this._pointPrimitivesToUpdate,o=this._pointPrimitivesToUpdateIndex,a=this._propertiesChanged,c=this._createVertexArray;let l;const h=e.context,u=e.passes,f=u.pick;if(c||!f&&this.computeNewBuffersUsage()){this._createVertexArray=!1;for(let e=0;e<V;++e)a[e]=0;if(this._vaf=this._vaf&&this._vaf.destroy(),t>0){this._vaf=function(e,t,n){return new w.A(e,[{index:G.positionHighAndSize,componentsPerAttribute:4,componentDatatype:r.A.FLOAT,usage:n[z]},{index:G.positionLowAndShow,componentsPerAttribute:4,componentDatatype:r.A.FLOAT,usage:n[z]},{index:G.compressedAttribute0,componentsPerAttribute:4,componentDatatype:r.A.FLOAT,usage:n[I]},{index:G.compressedAttribute1,componentsPerAttribute:4,componentDatatype:r.A.FLOAT,usage:n[M]},{index:G.scaleByDistance,componentsPerAttribute:4,componentDatatype:r.A.FLOAT,usage:n[L]},{index:G.distanceDisplayConditionAndDisableDepthAndSplitDirection,componentsPerAttribute:4,componentDatatype:r.A.FLOAT,usage:n[F]}],t)}(h,t,this._buffersUsage),l=this._vaf.writers;for(let e=0;e<t;++e){const t=this._pointPrimitives[e];t._dirty=!1,J(this,h,l,t)}this._vaf.commit()}this._pointPrimitivesToUpdateIndex=0}else if(o>0){const e=te;e.length=0,(a[z]||a[R]||a[N])&&e.push(j),(a[I]||a[P])&&e.push($),(a[O]||a[M])&&e.push(Z),a[L]&&e.push(K),(a[F]||a[B]||a[k])&&e.push(Q);const i=e.length;if(l=this._vaf.writers,o/t>.1){for(let t=0;t<o;++t){const o=n[t];o._dirty=!1;for(let t=0;t<i;++t)e[t](this,h,l,o)}this._vaf.commit()}else{for(let t=0;t<o;++t){const o=n[t];o._dirty=!1;for(let t=0;t<i;++t)e[t](this,h,l,o);this._vaf.subCommit(o._index,1)}this._vaf.endSubCommits()}this._pointPrimitivesToUpdateIndex=0}if(o>1.5*t&&(n.length=t),!(0,s.A)(this._vaf)||!(0,s.A)(this._vaf.va))return;let S;this._boundingVolumeDirty&&(this._boundingVolumeDirty=!1,i.A.transform(this._baseVolume,this.modelMatrix,this._baseVolumeWC));let H=d.A.IDENTITY;e.mode===D.A.SCENE3D?(H=this.modelMatrix,S=i.A.clone(this._baseVolumeWC,this._boundingVolume)):S=i.A.clone(this._baseVolume2D,this._boundingVolume),function(e,t,n){const i=t.camera.getPixelSize(n,t.context.drawingBufferWidth,t.context.drawingBufferHeight)*e._maxPixelSize;n.radius+=i}(this,e,S);const U=this._blendOption!==this.blendOption;let q,Y,X,ne,ie,oe;this._blendOption=this.blendOption,U&&(this._blendOption===E.A.OPAQUE||this._blendOption===E.A.OPAQUE_AND_TRANSLUCENT?this._rsOpaque=y.A.fromCache({depthTest:{enabled:!0,func:m.A.LEQUAL},depthMask:!0}):this._rsOpaque=void 0,this._blendOption===E.A.TRANSLUCENT||this._blendOption===E.A.OPAQUE_AND_TRANSLUCENT?this._rsTranslucent=y.A.fromCache({depthTest:{enabled:!0,func:m.A.LEQUAL},depthMask:!1,blending:C.A.ALPHA_BLEND}):this._rsTranslucent=void 0),this._shaderDisableDepthDistance=this._shaderDisableDepthDistance||0!==e.minimumDisableDepthTestDistance,(U||this._shaderScaleByDistance&&!this._compiledShaderScaleByDistance||this._shaderTranslucencyByDistance&&!this._compiledShaderTranslucencyByDistance||this._shaderDistanceDisplayCondition&&!this._compiledShaderDistanceDisplayCondition||this._shaderDisableDepthDistance!==this._compiledShaderDisableDepthDistance)&&(q=new b.A({sources:[x.A]}),this._shaderScaleByDistance&&q.defines.push("EYE_DISTANCE_SCALING"),this._shaderTranslucencyByDistance&&q.defines.push("EYE_DISTANCE_TRANSLUCENCY"),this._shaderDistanceDisplayCondition&&q.defines.push("DISTANCE_DISPLAY_CONDITION"),this._shaderDisableDepthDistance&&q.defines.push("DISABLE_DEPTH_DISTANCE"),this._blendOption===E.A.OPAQUE_AND_TRANSLUCENT&&(Y=new b.A({defines:["OPAQUE"],sources:[T.A]}),this._sp=v.A.replaceCache({context:h,shaderProgram:this._sp,vertexShaderSource:q,fragmentShaderSource:Y,attributeLocations:G}),Y=new b.A({defines:["TRANSLUCENT"],sources:[T.A]}),this._spTranslucent=v.A.replaceCache({context:h,shaderProgram:this._spTranslucent,vertexShaderSource:q,fragmentShaderSource:Y,attributeLocations:G})),this._blendOption===E.A.OPAQUE&&(Y=new b.A({sources:[T.A]}),this._sp=v.A.replaceCache({context:h,shaderProgram:this._sp,vertexShaderSource:q,fragmentShaderSource:Y,attributeLocations:G})),this._blendOption===E.A.TRANSLUCENT&&(Y=new b.A({sources:[T.A]}),this._spTranslucent=v.A.replaceCache({context:h,shaderProgram:this._spTranslucent,vertexShaderSource:q,fragmentShaderSource:Y,attributeLocations:G})),this._compiledShaderScaleByDistance=this._shaderScaleByDistance,this._compiledShaderTranslucencyByDistance=this._shaderTranslucencyByDistance,this._compiledShaderDistanceDisplayCondition=this._shaderDistanceDisplayCondition,this._compiledShaderDisableDepthDistance=this._shaderDisableDepthDistance);const re=e.commandList;if(u.render||f){const e=this._colorCommands,t=this._blendOption===E.A.OPAQUE,n=this._blendOption===E.A.OPAQUE_AND_TRANSLUCENT;X=this._vaf.va,ne=X.length,e.length=ne;const i=n?2*ne:ne;for(oe=0;oe<i;++oe){const i=t||n&&oe%2==0;ie=e[oe],(0,s.A)(ie)||(ie=e[oe]=new _.A),ie.primitiveType=p.A.POINTS,ie.pass=i||!n?g.A.OPAQUE:g.A.TRANSLUCENT,ie.owner=this;const o=n?Math.floor(oe/2):oe;ie.boundingVolume=S,ie.modelMatrix=H,ie.shaderProgram=i?this._sp:this._spTranslucent,ie.uniformMap=this._uniforms,ie.vertexArray=X[o].va,ie.renderState=i?this._rsOpaque:this._rsTranslucent,ie.debugShowBoundingVolume=this.debugShowBoundingVolume,ie.pickId="v_pickColor",re.push(ie)}}},H.prototype.isDestroyed=function(){return!1},H.prototype.destroy=function(){return this._sp=this._sp&&this._sp.destroy(),this._spTranslucent=this._spTranslucent&&this._spTranslucent.destroy(),this._spPick=this._spPick&&this._spPick.destroy(),this._vaf=this._vaf&&this._vaf.destroy(),U(this._pointPrimitives),(0,c.A)(this)};const ne=H},234957:(e,t,n)=>{"use strict";n.d(t,{A:()=>p});var i=n(915325),o=n(520098),r=n(769534),a=n(857831),s=n(692608),c=n(78149),l=n(207828);let h=`${c.A}\n${s.A}`;const u=a.A;function d(e){const t=(e=e??i.A.EMPTY_OBJECT).translucent??!0,n=!1,o=d.VERTEX_FORMAT;this.material=void 0,this.translucent=t,this._vertexShaderSource=e.vertexShaderSource??h,this._fragmentShaderSource=e.fragmentShaderSource??u,this._renderState=l.A.getDefaultRenderState(t,n,e.renderState),this._closed=n,this._vertexFormat=o}o.A.isInternetExplorer()||(h=`#define CLIP_POLYLINE \n${h}`),Object.defineProperties(d.prototype,{vertexShaderSource:{get:function(){return this._vertexShaderSource}},fragmentShaderSource:{get:function(){return this._fragmentShaderSource}},renderState:{get:function(){return this._renderState}},closed:{get:function(){return this._closed}},vertexFormat:{get:function(){return this._vertexFormat}}}),d.VERTEX_FORMAT=r.A.POSITION_ONLY,d.prototype.getFragmentShaderSource=l.A.prototype.getFragmentShaderSource,d.prototype.isTranslucent=l.A.prototype.isTranslucent,d.prototype.getRenderState=l.A.prototype.getRenderState;const p=d},920757:(e,t,n)=>{"use strict";n.d(t,{A:()=>f});var i=n(915325),o=n(491446),r=n(520098),a=n(769534),s=n(438376),c=n(78149),l=n(682091),h=n(207828),u=n(608191);let d=`${c.A}\n${s.A}`;const p=l.A;function m(e){const t=(e=e??i.A.EMPTY_OBJECT).translucent??!0,n=!1,r=m.VERTEX_FORMAT;this.material=(0,o.A)(e.material)?e.material:u.A.fromType(u.A.ColorType),this.translucent=t,this._vertexShaderSource=e.vertexShaderSource??d,this._fragmentShaderSource=e.fragmentShaderSource??p,this._renderState=h.A.getDefaultRenderState(t,n,e.renderState),this._closed=n,this._vertexFormat=r}r.A.isInternetExplorer()||(d=`#define CLIP_POLYLINE \n${d}`),Object.defineProperties(m.prototype,{vertexShaderSource:{get:function(){let e=this._vertexShaderSource;return-1!==this.material.shaderSource.search(/in\s+float\s+v_polylineAngle;/g)&&(e=`#define POLYLINE_DASH\n${e}`),e}},fragmentShaderSource:{get:function(){return this._fragmentShaderSource}},renderState:{get:function(){return this._renderState}},closed:{get:function(){return this._closed}},vertexFormat:{get:function(){return this._vertexFormat}}}),m.VERTEX_FORMAT=a.A.POSITION_AND_ST,m.prototype.getFragmentShaderSource=h.A.prototype.getFragmentShaderSource,m.prototype.isTranslucent=h.A.prototype.isTranslucent,m.prototype.getRenderState=h.A.prototype.getRenderState;const f=m},842153:(e,t,n)=>{"use strict";n.d(t,{A:()=>Se});var i=n(660662),o=n(434067),r=n(267980),a=n(626809),s=n(336946),c=n(376758),l=n(41476),h=n(430346),u=n(571804),d=n(915325),p=n(491446),m=n(677354),f=n(605971),A=n(816422),_=n(520098),g=n(944479),y=n(305439),v=n(46362),b=n(794554),w=n(647326),T=n(584164),x=n(257941),C=n(123245),E=n(841387),S=n(971724),D=n(442790),O=n(430332),z=n(377496),I=n(760866),P=n(40118),R=n(302836),N=n(342875),L=n(508380),M=n(425438),F=n(527083),B=n(523721),k=n(632791),V=n(871160),G=n(62467),H=n(988609);function U(e){if(e=e??d.A.EMPTY_OBJECT,this.geometryInstances=e.geometryInstances,this.appearance=e.appearance,this._appearance=void 0,this._material=void 0,this.depthFailAppearance=e.depthFailAppearance,this._depthFailAppearance=void 0,this._depthFailMaterial=void 0,this.modelMatrix=T.A.clone(e.modelMatrix??T.A.IDENTITY),this._modelMatrix=new T.A,this.show=e.show??!0,this._vertexCacheOptimize=e.vertexCacheOptimize??!1,this._interleave=e.interleave??!1,this._releaseGeometryInstances=e.releaseGeometryInstances??!0,this._allowPicking=e.allowPicking??!0,this._asynchronous=e.asynchronous??!0,this._compressVertices=e.compressVertices??!0,this.cull=e.cull??!0,this.debugShowBoundingVolume=e.debugShowBoundingVolume??!1,this.rtcCenter=e.rtcCenter,(0,p.A)(this.rtcCenter)&&(!(0,p.A)(this.geometryInstances)||Array.isArray(this.geometryInstances)&&1!==this.geometryInstances.length))throw new f.A("Relative-to-center rendering only supports one geometry instance.");this.shadows=e.shadows??H.A.DISABLED,this._translucent=void 0,this._state=V.A.READY,this._geometries=[],this._error=void 0,this._numberOfInstances=0,this._boundingSpheres=[],this._boundingSphereWC=[],this._boundingSphereCV=[],this._boundingSphere2D=[],this._boundingSphereMorph=[],this._perInstanceAttributeCache=new Map,this._instanceIds=[],this._lastPerInstanceAttributeIndex=0,this._va=[],this._attributeLocations=void 0,this._primitiveType=void 0,this._frontFaceRS=void 0,this._backFaceRS=void 0,this._sp=void 0,this._depthFailAppearance=void 0,this._spDepthFail=void 0,this._frontFaceDepthFailRS=void 0,this._backFaceDepthFailRS=void 0,this._pickIds=[],this._colorCommands=[],this._pickCommands=[],this._createBoundingVolumeFunction=e._createBoundingVolumeFunction,this._createRenderStatesFunction=e._createRenderStatesFunction,this._createShaderProgramFunction=e._createShaderProgramFunction,this._createCommandsFunction=e._createCommandsFunction,this._updateAndQueueCommandsFunction=e._updateAndQueueCommandsFunction,this._createPickOffsets=e._createPickOffsets,this._pickOffsets=void 0,this._createGeometryResults=void 0,this._ready=!1,this._batchTable=void 0,this._batchTableAttributeIndices=void 0,this._offsetInstanceExtend=void 0,this._batchTableOffsetAttribute2DIndex=void 0,this._batchTableOffsetsUpdated=!1,this._instanceBoundingSpheres=void 0,this._instanceBoundingSpheresCV=void 0,this._tempBoundingSpheres=void 0,this._recomputeBoundingSpheres=!1,this._batchTableBoundingSpheresUpdated=!1,this._batchTableBoundingSphereAttributeIndices=void 0}Object.defineProperties(U.prototype,{vertexCacheOptimize:{get:function(){return this._vertexCacheOptimize}},interleave:{get:function(){return this._interleave}},releaseGeometryInstances:{get:function(){return this._releaseGeometryInstances}},allowPicking:{get:function(){return this._allowPicking}},asynchronous:{get:function(){return this._asynchronous}},compressVertices:{get:function(){return this._compressVertices}},ready:{get:function(){return this._ready}}});const W=new o.A,q=new r.A,j=new a.A;function Y(e){const t=e.length;return 1===t?e[0]:2===t?o.A.unpack(e,0,W):3===t?r.A.unpack(e,0,q):4===t?a.A.unpack(e,0,j):void 0}function X(e){let t;return t=Array.isArray(e.values)?e.values.slice(0):new e.values.constructor(e.values),new y.A({componentDatatype:e.componentDatatype,componentsPerAttribute:e.componentsPerAttribute,normalize:e.normalize,values:t})}function $(e){const t=e.attributes,n=new v.A;for(const e in t)t.hasOwnProperty(e)&&(0,p.A)(t[e])&&(n[e]=X(t[e]));let o;if((0,p.A)(e.indices)){const t=e.indices;o=Array.isArray(t)?t.slice(0):new t.constructor(t)}return new g.A({attributes:n,indices:o,primitiveType:e.primitiveType,boundingSphere:i.A.clone(e.boundingSphere)})}function Z(e,t){return{geometry:t,attributes:e.attributes,modelMatrix:T.A.clone(e.modelMatrix),pickPrimitive:e.pickPrimitive,id:e.id}}const K=/in\s+vec(?:3|4)\s+(.*)3DHigh;/g;function Q(e){return`${N.A.replaceMain(e,"czm_non_pick_main")}\nout vec4 v_pickColor; \nvoid main() \n{ \n    czm_non_pick_main(); \n    v_pickColor = czm_batchTable_pickColor(batchId); \n}`}function J(e){return`in vec4 v_pickColor;\n${e}`}function ee(e,t){if(!e.compressVertices)return t;const n=-1!==t.search(/in\s+vec3\s+normal;/g),i=-1!==t.search(/in\s+vec2\s+st;/g);if(!n&&!i)return t;const o=-1!==t.search(/in\s+vec3\s+tangent;/g),r=-1!==t.search(/in\s+vec3\s+bitangent;/g);let a=i&&n?2:1;a+=o||r?1:0;const s="compressedAttributes",c=`in ${a>1?`vec${a}`:"float"} ${s};`;let l="",h="";i&&(l+="vec2 st;\n",h+=`    st = czm_decompressTextureCoordinates(${a>1?`${s}.x`:s});\n`),n&&o&&r?(l+="vec3 normal;\nvec3 tangent;\nvec3 bitangent;\n",h+=`    czm_octDecode(${s}.${i?"yz":"xy"}, normal, tangent, bitangent);\n`):(n&&(l+="vec3 normal;\n",h+=`    normal = czm_octDecode(${s}${a>1?"."+(i?"y":"x"):""});\n`),o&&(l+="vec3 tangent;\n",h+=`    tangent = czm_octDecode(${s}.${i&&n?"z":"y"});\n`),r&&(l+="vec3 bitangent;\n",h+=`    bitangent = czm_octDecode(${s}.${i&&n?"z":"y"});\n`));let u=t;return u=u.replace(/in\s+vec3\s+normal;/g,""),u=u.replace(/in\s+vec2\s+st;/g,""),u=u.replace(/in\s+vec3\s+tangent;/g,""),u=u.replace(/in\s+vec3\s+bitangent;/g,""),u=N.A.replaceMain(u,"czm_non_compressed_main"),[c,l,u,`void main() \n{ \n${h}    czm_non_compressed_main(); \n}`].join("\n")}function te(e,t){const n=e.vertexAttributes;for(const e in n)if(n.hasOwnProperty(e)&&!(0,p.A)(t[e]))throw new f.A(`Appearance/Geometry mismatch.  The appearance requires vertex shader attribute input '${e}', which was not computed as part of the Geometry.  Use the appearance's vertexFormat property when constructing the geometry.`)}function ne(e,t){return function(){return e[t]}}U._modifyShaderPosition=function(e,t,n){let i,o="",r="",a="";for(;null!==(i=K.exec(t));){const s=i[1],c=`vec4 czm_compute${s[0].toUpperCase()}${s.substr(1)}()`;"vec4 czm_computePosition()"!==c&&(o+=`${c};\n`),(0,p.A)(e.rtcCenter)?(o+="uniform mat4 u_modifiedModelView;\n",r+="in vec4 position;\n",a+=`${c}\n{\n    return u_modifiedModelView * position;\n}\n\n`,t=(t=(t=(t=t.replace(/in\s+vec(?:3|4)\s+position3DHigh;/g,"")).replace(/in\s+vec(?:3|4)\s+position3DLow;/g,"")).replace(/czm_modelViewRelativeToEye\s+\*\s+/g,"")).replace(/czm_modelViewProjectionRelativeToEye/g,"czm_projection")):n?a+=`${c}\n{\n    return czm_translateRelativeToEye(${s}3DHigh, ${s}3DLow);\n}\n\n`:(r+=`in vec3 ${s}2DHigh;\nin vec3 ${s}2DLow;\n`,a+=`${c}\n{\n    vec4 p;\n    if (czm_morphTime == 1.0)\n    {\n        p = czm_translateRelativeToEye(${s}3DHigh, ${s}3DLow);\n    }\n    else if (czm_morphTime == 0.0)\n    {\n        p = czm_translateRelativeToEye(${s}2DHigh.zxy, ${s}2DLow.zxy);\n    }\n    else\n    {\n        p = czm_columbusViewMorph(\n                czm_translateRelativeToEye(${s}2DHigh.zxy, ${s}2DLow.zxy),\n                czm_translateRelativeToEye(${s}3DHigh, ${s}3DLow),\n                czm_morphTime);\n    }\n    return p;\n}\n\n`)}return[o,r,t,a].join("\n")},U._appendShowToShader=function(e,t){return(0,p.A)(e._batchTableAttributeIndices.show)?`${N.A.replaceMain(t,"czm_non_show_main")}\nvoid main() \n{ \n    czm_non_show_main(); \n    gl_Position *= czm_batchTable_show(batchId); \n}`:t},U._updateColorAttribute=function(e,t,n){if(!(0,p.A)(e._batchTableAttributeIndices.color)&&!(0,p.A)(e._batchTableAttributeIndices.depthFailColor))return t;if(-1===t.search(/in\s+vec4\s+color;/g))return t;if(n&&!(0,p.A)(e._batchTableAttributeIndices.depthFailColor))throw new f.A("A depthFailColor per-instance attribute is required when using a depth fail appearance that uses a color attribute.");let i=t;return i=i.replace(/in\s+vec4\s+color;/g,""),i=n?i.replace(/(\b)color(\b)/g,"$1czm_batchTable_depthFailColor(batchId)$2"):i.replace(/(\b)color(\b)/g,"$1czm_batchTable_color(batchId)$2"),i},U._updatePickColorAttribute=function(e){let t=e.replace(/in\s+vec4\s+pickColor;/g,"");return t=t.replace(/(\b)pickColor(\b)/g,"$1czm_batchTable_pickColor(batchId)$2"),t},U._appendOffsetToShader=function(e,t){if(!(0,p.A)(e._batchTableAttributeIndices.offset))return t;let n="in float batchId;\n";n+="in float applyOffset;";let i=t.replace(/in\s+float\s+batchId;/g,"in float batchId;\nin float applyOffset;"),o="vec4 $1 = czm_computePosition();\n";return o+="    if (czm_sceneMode == czm_sceneMode3D)\n",o+="    {\n",o+="        $1 = $1 + vec4(czm_batchTable_offset(batchId) * applyOffset, 0.0);",o+="    }\n",o+="    else\n",o+="    {\n",o+="        $1 = $1 + vec4(czm_batchTable_offset2D(batchId) * applyOffset, 0.0);",o+="    }\n",i=i.replace(/vec4\s+([A-Za-z0-9_]+)\s+=\s+czm_computePosition\(\);/g,"vec4 $1 = czm_computePosition();\n    if (czm_sceneMode == czm_sceneMode3D)\n    {\n        $1 = $1 + vec4(czm_batchTable_offset(batchId) * applyOffset, 0.0);    }\n    else\n    {\n        $1 = $1 + vec4(czm_batchTable_offset2D(batchId) * applyOffset, 0.0);    }\n"),i},U._appendDistanceDisplayConditionToShader=function(e,t,n){if(!(0,p.A)(e._batchTableAttributeIndices.distanceDisplayCondition))return t;let i="void main() \n{ \n    czm_non_distanceDisplayCondition_main(); \n    vec2 distanceDisplayCondition = czm_batchTable_distanceDisplayCondition(batchId);\n    vec3 boundingSphereCenter3DHigh = czm_batchTable_boundingSphereCenter3DHigh(batchId);\n    vec3 boundingSphereCenter3DLow = czm_batchTable_boundingSphereCenter3DLow(batchId);\n    float boundingSphereRadius = czm_batchTable_boundingSphereRadius(batchId);\n";return i+=n?"    vec4 centerRTE = czm_translateRelativeToEye(boundingSphereCenter3DHigh, boundingSphereCenter3DLow);\n":"    vec3 boundingSphereCenter2DHigh = czm_batchTable_boundingSphereCenter2DHigh(batchId);\n    vec3 boundingSphereCenter2DLow = czm_batchTable_boundingSphereCenter2DLow(batchId);\n    vec4 centerRTE;\n    if (czm_morphTime == 1.0)\n    {\n        centerRTE = czm_translateRelativeToEye(boundingSphereCenter3DHigh, boundingSphereCenter3DLow);\n    }\n    else if (czm_morphTime == 0.0)\n    {\n        centerRTE = czm_translateRelativeToEye(boundingSphereCenter2DHigh.zxy, boundingSphereCenter2DLow.zxy);\n    }\n    else\n    {\n        centerRTE = czm_columbusViewMorph(\n                czm_translateRelativeToEye(boundingSphereCenter2DHigh.zxy, boundingSphereCenter2DLow.zxy),\n                czm_translateRelativeToEye(boundingSphereCenter3DHigh, boundingSphereCenter3DLow),\n                czm_morphTime);\n    }\n",i+="    float radiusSq = boundingSphereRadius * boundingSphereRadius; \n    float distanceSq; \n    if (czm_sceneMode == czm_sceneMode2D) \n    { \n        distanceSq = czm_eyeHeight2D.y - radiusSq; \n    } \n    else \n    { \n        distanceSq = dot(centerRTE.xyz, centerRTE.xyz) - radiusSq; \n    } \n    distanceSq = max(distanceSq, 0.0); \n    float nearSq = distanceDisplayCondition.x * distanceDisplayCondition.x; \n    float farSq = distanceDisplayCondition.y * distanceDisplayCondition.y; \n    float show = (distanceSq >= nearSq && distanceSq <= farSq) ? 1.0 : 0.0; \n    gl_Position *= show; \n}",`${N.A.replaceMain(t,"czm_non_distanceDisplayCondition_main")}\n${i}`};const ie=Math.max(_.A.hardwareConcurrency-1,1);let oe;const re=new S.A("combineGeometry"),ae=new A.A,se=new s.A,ce=new r.A,le=new i.A,he=new r.A,ue=new r.A;function de(e,t){if(!(0,p.A)(e._batchTableAttributeIndices.offset)||e._batchTableOffsetsUpdated||t.scene3DOnly)return;const n=e._batchTableOffsetAttribute2DIndex,o=t.mapProjection,a=o.ellipsoid,s=e._batchTable,c=e._instanceBoundingSpheres,l=c.length;for(let t=0;t<l;++t){let l=c[t];if(!(0,p.A)(l))continue;const h=s.getBatchedAttribute(t,e._batchTableAttributeIndices.offset);if(r.A.equals(h,r.A.ZERO)){s.setBatchedAttribute(t,n,r.A.ZERO);continue}const u=e.modelMatrix;(0,p.A)(u)&&(l=i.A.transform(l,u,le));let d=l.center;d=a.scaleToGeodeticSurface(d,ue);let m=a.cartesianToCartographic(d,se);const f=o.project(m,ce),A=r.A.add(h,d,he);m=a.cartesianToCartographic(A,m);const _=o.project(m,he),g=r.A.subtract(_,f,he),y=g.x;g.x=g.z,g.z=g.y,g.y=y,s.setBatchedAttribute(t,n,g)}e._batchTableOffsetsUpdated=!0}function pe(e,t,n,i){let o,r=n.getRenderState();i?(o=(0,c.A)(r,!1),o.cull={enabled:!0,face:F.A.BACK},e._frontFaceRS=P.A.fromCache(o),o.cull.face=F.A.FRONT,e._backFaceRS=P.A.fromCache(o)):(e._frontFaceRS=P.A.fromCache(r),e._backFaceRS=e._frontFaceRS),o=(0,c.A)(r,!1),(0,p.A)(e._depthFailAppearance)&&(o.depthTest.enabled=!1),(0,p.A)(e._depthFailAppearance)&&(r=e._depthFailAppearance.getRenderState(),o=(0,c.A)(r,!1),o.depthTest.func=B.A.GREATER,i?(o.cull={enabled:!0,face:F.A.BACK},e._frontFaceDepthFailRS=P.A.fromCache(o),o.cull.face=F.A.FRONT,e._backFaceDepthFailRS=P.A.fromCache(o)):(e._frontFaceDepthFailRS=P.A.fromCache(o),e._backFaceDepthFailRS=e._frontFaceRS))}function me(e,t,n){const i=t.context,o=e._attributeLocations;let r=e._batchTable.getVertexShaderCallback()(n.vertexShaderSource);r=U._appendOffsetToShader(e,r),r=U._appendShowToShader(e,r),r=U._appendDistanceDisplayConditionToShader(e,r,t.scene3DOnly),r=Q(r),r=U._updateColorAttribute(e,r,!1),r=ee(e,r),r=U._modifyShaderPosition(e,r,t.scene3DOnly);let a=n.getFragmentShaderSource();a=J(a),e._sp=R.A.replaceCache({context:i,shaderProgram:e._sp,vertexShaderSource:r,fragmentShaderSource:a,attributeLocations:o}),te(e._sp,o),(0,p.A)(e._depthFailAppearance)&&(r=e._batchTable.getVertexShaderCallback()(e._depthFailAppearance.vertexShaderSource),r=U._appendShowToShader(e,r),r=U._appendDistanceDisplayConditionToShader(e,r,t.scene3DOnly),r=Q(r),r=U._updateColorAttribute(e,r,!0),r=ee(e,r),r=U._modifyShaderPosition(e,r,t.scene3DOnly),r=function(e){let t=N.A.replaceMain(e,"czm_non_depth_clamp_main");return t+="void main() {\n    czm_non_depth_clamp_main();\n    gl_Position = czm_depthClamp(gl_Position);}\n",t}(r),a=e._depthFailAppearance.getFragmentShaderSource(),a=J(a),a=function(e){let t=N.A.replaceMain(e,"czm_non_depth_clamp_main");return t+="void main() {\n    czm_non_depth_clamp_main();\n    #if defined(LOG_DEPTH)\n        czm_writeLogDepth();\n    #else\n        czm_writeDepthClamp();\n    #endif\n}\n",t}(a),e._spDepthFail=R.A.replaceCache({context:i,shaderProgram:e._spDepthFail,vertexShaderSource:r,fragmentShaderSource:a,attributeLocations:o}),te(e._spDepthFail,o))}const fe=new T.A,Ae=new r.A;function _e(e,t,n,i){const o=(0,p.A)(n)?n._uniforms:void 0,r={},a=t.uniforms;if((0,p.A)(a))for(const e in a)if(a.hasOwnProperty(e)){if((0,p.A)(o)&&(0,p.A)(o[e]))throw new f.A(`Appearance and material have a uniform with the same name: ${e}`);r[e]=ne(a,e)}let s=(0,h.A)(r,o);return s=e._batchTable.getUniformMapCallback()(s),(0,p.A)(e.rtcCenter)&&(s.u_modifiedModelView=function(){const t=i.context.uniformState.view;return T.A.multiply(t,e._modelMatrix,fe),T.A.multiplyByPoint(fe,e.rtcCenter,Ae),T.A.setTranslation(fe,Ae,fe),fe}),s}function ge(e,t,n,i,o,r,a,s){const c=_e(e,t,n,s);let l;(0,p.A)(e._depthFailAppearance)&&(l=_e(e,e._depthFailAppearance,e._depthFailAppearance.material,s));const h=i?I.A.TRANSLUCENT:I.A.OPAQUE;let u=o?2:1;u*=(0,p.A)(e._depthFailAppearance)?2:1,r.length=e._va.length*u;const d=r.length;let m=0;for(let t=0;t<d;++t){let n;o&&(n=r[t],(0,p.A)(n)||(n=r[t]=new z.A({owner:e,primitiveType:e._primitiveType})),n.vertexArray=e._va[m],n.renderState=e._backFaceRS,n.shaderProgram=e._sp,n.uniformMap=c,n.pass=h,++t),n=r[t],(0,p.A)(n)||(n=r[t]=new z.A({owner:e,primitiveType:e._primitiveType})),n.vertexArray=e._va[m],n.renderState=e._frontFaceRS,n.shaderProgram=e._sp,n.uniformMap=c,n.pass=h,(0,p.A)(e._depthFailAppearance)&&(o&&(++t,n=r[t],(0,p.A)(n)||(n=r[t]=new z.A({owner:e,primitiveType:e._primitiveType})),n.vertexArray=e._va[m],n.renderState=e._backFaceDepthFailRS,n.shaderProgram=e._spDepthFail,n.uniformMap=l,n.pass=h),++t,n=r[t],(0,p.A)(n)||(n=r[t]=new z.A({owner:e,primitiveType:e._primitiveType})),n.vertexArray=e._va[m],n.renderState=e._frontFaceDepthFailRS,n.shaderProgram=e._spDepthFail,n.uniformMap=l,n.pass=h),++m}}function ye(e,t,n,i,o,r,a,s){if(t.mode!==G.A.SCENE3D&&!T.A.equals(o,T.A.IDENTITY))throw new f.A("Primitive.modelMatrix is only supported in 3D mode.");let c;U._updateBoundingVolumes(e,t,o),t.mode===G.A.SCENE3D?c=e._boundingSphereWC:t.mode===G.A.COLUMBUS_VIEW?c=e._boundingSphereCV:t.mode===G.A.SCENE2D&&(0,p.A)(e._boundingSphere2D)?c=e._boundingSphere2D:(0,p.A)(e._boundingSphereMorph)&&(c=e._boundingSphereMorph);const l=t.commandList,h=t.passes;if(h.render||h.pick){const t=e.allowPicking,i=H.A.castShadows(e.shadows),h=H.A.receiveShadows(e.shadows),u=n.length;let d=s?2:1;d*=(0,p.A)(e._depthFailAppearance)?2:1;for(let e=0;e<u;++e){const s=Math.floor(e/d),u=n[e];u.modelMatrix=o,u.boundingVolume=c[s],u.cull=r,u.debugShowBoundingVolume=a,u.castShadows=i,u.receiveShadows=h,u.pickId=t?"v_pickColor":void 0,l.push(u)}}}U._updateBoundingVolumes=function(e,t,n,o){let r,a,s;if(o||!T.A.equals(n,e._modelMatrix))for(T.A.clone(n,e._modelMatrix),a=e._boundingSpheres.length,r=0;r<a;++r)s=e._boundingSpheres[r],(0,p.A)(s)&&(e._boundingSphereWC[r]=i.A.transform(s,n,e._boundingSphereWC[r]),t.scene3DOnly||(e._boundingSphere2D[r]=i.A.clone(e._boundingSphereCV[r],e._boundingSphere2D[r]),e._boundingSphereMorph[r]=i.A.union(e._boundingSphereWC[r],e._boundingSphereCV[r])));const c=e.appearance.pixelSize;if((0,p.A)(c))for(a=e._boundingSpheres.length,r=0;r<a;++r){s=e._boundingSpheres[r];const n=e._boundingSphereWC[r],i=t.camera.getPixelSize(s,t.context.drawingBufferWidth,t.context.drawingBufferHeight)*c;n.radius=s.radius+i}},U.prototype.update=function(e){if(!(0,p.A)(this.geometryInstances)&&0===this._va.length||(0,p.A)(this.geometryInstances)&&Array.isArray(this.geometryInstances)&&0===this.geometryInstances.length||!(0,p.A)(this.appearance)||e.mode!==G.A.SCENE3D&&e.scene3DOnly||!e.passes.render&&!e.passes.pick)return;if((0,p.A)(this._error))throw this._error;if((0,p.A)(this.rtcCenter)&&!e.scene3DOnly)throw new f.A("RTC rendering is only available for 3D only scenes.");if(this._state===V.A.FAILED)return;const t=e.context;if((0,p.A)(this._batchTable)||function(e,t){const n=e.geometryInstances,i=Array.isArray(n)?n:[n],o=i.length;if(0===o)return;const r=function(e){const t=e.length,n=[],i=e[0].attributes;let o;for(o in i)if(i.hasOwnProperty(o)&&(0,p.A)(i[o])){const r=i[o];let a=!0;for(let n=1;n<t;++n){const t=e[n].attributes[o];if(!(0,p.A)(t)||r.componentDatatype!==t.componentDatatype||r.componentsPerAttribute!==t.componentsPerAttribute||r.normalize!==t.normalize){a=!1;break}}a&&n.push(o)}return n}(i),a=r.length,s=[],c={},h={};let d,m,f,A,_=i[0].attributes;for(m=0;m<a;++m)f=r[m],A=_[f],c[f]=m,s.push({functionName:`czm_batchTable_${f}`,componentDatatype:A.componentDatatype,componentsPerAttribute:A.componentsPerAttribute,normalize:A.normalize});-1!==r.indexOf("distanceDisplayCondition")&&(s.push({functionName:"czm_batchTable_boundingSphereCenter3DHigh",componentDatatype:u.A.FLOAT,componentsPerAttribute:3},{functionName:"czm_batchTable_boundingSphereCenter3DLow",componentDatatype:u.A.FLOAT,componentsPerAttribute:3},{functionName:"czm_batchTable_boundingSphereCenter2DHigh",componentDatatype:u.A.FLOAT,componentsPerAttribute:3},{functionName:"czm_batchTable_boundingSphereCenter2DLow",componentDatatype:u.A.FLOAT,componentsPerAttribute:3},{functionName:"czm_batchTable_boundingSphereRadius",componentDatatype:u.A.FLOAT,componentsPerAttribute:1}),h.center3DHigh=s.length-5,h.center3DLow=s.length-4,h.center2DHigh=s.length-3,h.center2DLow=s.length-2,h.radius=s.length-1),-1!==r.indexOf("offset")&&(s.push({functionName:"czm_batchTable_offset2D",componentDatatype:u.A.FLOAT,componentsPerAttribute:3}),d=s.length-1),s.push({functionName:"czm_batchTable_pickColor",componentDatatype:u.A.UNSIGNED_BYTE,componentsPerAttribute:4,normalize:!0});const g=s.length,y=new M.A(t,s,o);for(m=0;m<o;++m){const n=i[m];_=n.attributes;for(let e=0;e<a;++e){f=r[e],A=_[f];const t=Y(A.value),n=c[f];y.setBatchedAttribute(m,n,t)}const o={primitive:n.pickPrimitive??e};(0,p.A)(n.id)&&(o.id=n.id);const s=t.createPickId(o);e._pickIds.push(s);const h=s.color,u=j;u.x=l.A.floatToByte(h.red),u.y=l.A.floatToByte(h.green),u.z=l.A.floatToByte(h.blue),u.w=l.A.floatToByte(h.alpha),y.setBatchedAttribute(m,g-1,u)}e._batchTable=y,e._batchTableAttributeIndices=c,e._batchTableBoundingSphereAttributeIndices=h,e._batchTableOffsetAttribute2DIndex=d}(this,t),this._batchTable.attributes.length>0){if(0===O.A.maximumVertexTextureImageUnits)throw new C.A("Vertex texture fetch support is required to render primitives with per-instance attributes. The maximum number of vertex texture image units must be greater than zero.");this._batchTable.update(e)}if(this._state!==V.A.COMPLETE&&this._state!==V.A.COMBINED&&(this.asynchronous?function(e,t){let n,i,o,r;const a=e._instanceIds;if(e._state===V.A.READY){n=Array.isArray(e.geometryInstances)?e.geometryInstances:[e.geometryInstances];const s=e._numberOfInstances=n.length,c=[];let l,h=[];for(o=0;o<s;++o){if(i=n[o].geometry,a.push(n[o].id),(0,p.A)(i._workerName)&&(0,p.A)(i._workerPath)||!(0,p.A)(i._workerName)&&!(0,p.A)(i._workerPath))throw new f.A("Must define either _workerName or _workerPath for asynchronous geometry.");h.push({moduleName:i._workerName,modulePath:i._workerPath,geometry:i})}if(!(0,p.A)(oe))for(oe=new Array(ie),o=0;o<ie;o++)oe[o]=new S.A("createGeometry");for(h=(0,E.A)(h,ie),o=0;o<h.length;o++){let e=0;const t=h[o],n=t.length;for(r=0;r<n;++r)l=t[r],i=l.geometry,(0,p.A)(i.constructor.pack)&&(l.offset=e,e+=i.constructor.packedLength??i.packedLength);let a;if(e>0){const o=new Float64Array(e);for(a=[o.buffer],r=0;r<n;++r)l=t[r],i=l.geometry,(0,p.A)(i.constructor.pack)&&(i.constructor.pack(i,o,l.offset),l.geometry=o)}c.push(oe[o].scheduleTask({subTasks:h[o]},a))}e._state=V.A.CREATING,Promise.all(c).then(function(t){e._createGeometryResults=t,e._state=V.A.CREATED}).catch(function(n){Ee(e,t,V.A.FAILED,n)})}else if(e._state===V.A.CREATED){const i=[];n=Array.isArray(e.geometryInstances)?e.geometryInstances:[e.geometryInstances];const o=t.scene3DOnly,r=t.mapProjection,a=re.scheduleTask(k.A.packCombineGeometryParameters({createGeometryResults:e._createGeometryResults,instances:n,ellipsoid:r.ellipsoid,projection:r,elementIndexUintSupported:t.context.elementIndexUint,scene3DOnly:o,vertexCacheOptimize:e.vertexCacheOptimize,compressVertices:e.compressVertices,modelMatrix:e.modelMatrix,createPickOffsets:e._createPickOffsets},i),i);e._createGeometryResults=void 0,e._state=V.A.COMBINING,Promise.resolve(a).then(function(n){const i=k.A.unpackCombineGeometryResults(n);e._geometries=i.geometries,e._attributeLocations=i.attributeLocations,e.modelMatrix=T.A.clone(i.modelMatrix,e.modelMatrix),e._pickOffsets=i.pickOffsets,e._offsetInstanceExtend=i.offsetInstanceExtend,e._instanceBoundingSpheres=i.boundingSpheres,e._instanceBoundingSpheresCV=i.boundingSpheresCV,(0,p.A)(e._geometries)&&e._geometries.length>0?(e._recomputeBoundingSpheres=!0,e._state=V.A.COMBINED):Ee(e,t,V.A.FAILED,void 0)}).catch(function(n){Ee(e,t,V.A.FAILED,n)})}}(this,e):function(e,t){const n=Array.isArray(e.geometryInstances)?e.geometryInstances:[e.geometryInstances],i=e._numberOfInstances=n.length,o=new Array(i),r=e._instanceIds;let a,s,c=0;for(s=0;s<i;s++){a=n[s];const e=a.geometry;let t;t=(0,p.A)(e.attributes)&&(0,p.A)(e.primitiveType)?$(e):e.constructor.createGeometry(e),o[c++]=Z(a,t),r.push(a.id)}o.length=c;const l=t.scene3DOnly,h=t.mapProjection,u=k.A.combineGeometry({instances:o,ellipsoid:h.ellipsoid,projection:h,elementIndexUintSupported:t.context.elementIndexUint,scene3DOnly:l,vertexCacheOptimize:e.vertexCacheOptimize,compressVertices:e.compressVertices,modelMatrix:e.modelMatrix,createPickOffsets:e._createPickOffsets});e._geometries=u.geometries,e._attributeLocations=u.attributeLocations,e.modelMatrix=T.A.clone(u.modelMatrix,e.modelMatrix),e._pickOffsets=u.pickOffsets,e._offsetInstanceExtend=u.offsetInstanceExtend,e._instanceBoundingSpheres=u.boundingSpheres,e._instanceBoundingSpheresCV=u.boundingSpheresCV,(0,p.A)(e._geometries)&&e._geometries.length>0?(e._recomputeBoundingSpheres=!0,e._state=V.A.COMBINED):Ee(e,t,V.A.FAILED,void 0)}(this,e)),this._state===V.A.COMBINED&&(function(e,t){if(!(0,p.A)(e._batchTableAttributeIndices.distanceDisplayCondition)||e._batchTableBoundingSpheresUpdated)return;const n=e._batchTableBoundingSphereAttributeIndices,o=n.center3DHigh,r=n.center3DLow,a=n.center2DHigh,s=n.center2DLow,c=n.radius,l=t.mapProjection,h=l.ellipsoid,u=e._batchTable,d=e._instanceBoundingSpheres,m=d.length;for(let n=0;n<m;++n){let m=d[n];if(!(0,p.A)(m))continue;const f=e.modelMatrix;(0,p.A)(f)&&(m=i.A.transform(m,f,le));const _=m.center,g=m.radius;let y=A.A.fromCartesian(_,ae);if(u.setBatchedAttribute(n,o,y.high),u.setBatchedAttribute(n,r,y.low),!t.scene3DOnly){const e=h.cartesianToCartographic(_,se),t=l.project(e,ce);y=A.A.fromCartesian(t,ae),u.setBatchedAttribute(n,a,y.high),u.setBatchedAttribute(n,s,y.low)}u.setBatchedAttribute(n,c,g)}e._batchTableBoundingSpheresUpdated=!0}(this,e),de(this,e),function(e,t){const n=e._attributeLocations,o=e._geometries,r=t.scene3DOnly,a=t.context,s=[],c=o.length;for(let l=0;l<c;++l){const c=o[l];if(s.push(L.A.fromGeometry({context:a,geometry:c,attributeLocations:n,bufferUsage:D.A.STATIC_DRAW,interleave:e._interleave})),(0,p.A)(e._createBoundingVolumeFunction))e._createBoundingVolumeFunction(t,c);else if(e._boundingSpheres.push(i.A.clone(c.boundingSphere)),e._boundingSphereWC.push(new i.A),!r){const t=c.boundingSphereCV.center,n=t.x,o=t.y,r=t.z;t.x=r,t.y=n,t.z=o,e._boundingSphereCV.push(i.A.clone(c.boundingSphereCV)),e._boundingSphere2D.push(new i.A),e._boundingSphereMorph.push(new i.A)}}e._va=s,e._primitiveType=o[0].primitiveType,e.releaseGeometryInstances&&(e.geometryInstances=void 0),e._geometries=void 0,Ee(e,t,V.A.COMPLETE,void 0)}(this,e)),!this.show||this._state!==V.A.COMPLETE)return;this._batchTableOffsetsUpdated||de(this,e),this._recomputeBoundingSpheres&&function(e,t){const n=e._batchTableAttributeIndices.offset;if(!e._recomputeBoundingSpheres||!(0,p.A)(n))return void(e._recomputeBoundingSpheres=!1);let o;const a=e._offsetInstanceExtend,s=e._instanceBoundingSpheres,c=s.length;let l=e._tempBoundingSpheres;if(!(0,p.A)(l)){for(l=new Array(c),o=0;o<c;o++)l[o]=new i.A;e._tempBoundingSpheres=l}for(o=0;o<c;++o){let t=l[o];const i=e._batchTable.getBatchedAttribute(o,n,new r.A);t=s[o].clone(t),we(t,i,a[o])}const h=[],u=[],d=[];for(o=0;o<c;++o){const e=l[o];e.center.x-e.radius>0||i.A.intersectPlane(e,x.A.ORIGIN_ZX_PLANE)!==w.A.INTERSECTING?h.push(e):(u.push(e),d.push(e))}let m=h[0],f=d[0],A=u[0];for(o=1;o<h.length;o++)m=i.A.union(m,h[o]);for(o=1;o<d.length;o++)f=i.A.union(f,d[o]);for(o=1;o<u.length;o++)A=i.A.union(A,u[o]);const _=[];for((0,p.A)(m)&&_.push(m),(0,p.A)(f)&&_.push(f),(0,p.A)(A)&&_.push(A),o=0;o<_.length;o++){const n=_[o].clone(e._boundingSpheres[o]);e._boundingSpheres[o]=n,e._boundingSphereCV[o]=i.A.projectTo2D(n,t.mapProjection,e._boundingSphereCV[o])}U._updateBoundingVolumes(e,t,e.modelMatrix,!0),e._recomputeBoundingSpheres=!1}(this,e);const n=this.appearance,o=n.material;let a=!1,s=!1;this._appearance!==n?(this._appearance=n,this._material=o,a=!0,s=!0):this._material!==o&&(this._material=o,s=!0);const c=this.depthFailAppearance,h=(0,p.A)(c)?c.material:void 0;this._depthFailAppearance!==c?(this._depthFailAppearance=c,this._depthFailMaterial=h,a=!0,s=!0):this._depthFailMaterial!==h&&(this._depthFailMaterial=h,s=!0);const d=this._appearance.isTranslucent();this._translucent!==d&&(this._translucent=d,a=!0),(0,p.A)(this._material)&&this._material.update(t);const m=n.closed&&d;a&&(this._createRenderStatesFunction??pe)(this,t,n,m),s&&(this._createShaderProgramFunction??me)(this,e,n),(a||s)&&(this._createCommandsFunction??ge)(this,n,o,d,m,this._colorCommands,this._pickCommands,e),(this._updateAndQueueCommandsFunction??ye)(this,e,this._colorCommands,this._pickCommands,this.modelMatrix,this.cull,this.debugShowBoundingVolume,m)};const ve=new i.A,be=new i.A;function we(e,t,n){if(n===b.A.TOP){const n=i.A.clone(e,ve),o=i.A.clone(e,be);o.center=r.A.add(o.center,t,o.center),e=i.A.union(n,o,e)}else n===b.A.ALL&&(e.center=r.A.add(e.center,t,e.center));return e}function Te(e,t,n){return function(){const i=e.getBatchedAttribute(t,n),o=e.attributes[n],r=o.componentsPerAttribute,a=u.A.createTypedArray(o.componentDatatype,r);return(0,p.A)(i.constructor.pack)?i.constructor.pack(i,a,0):a[0]=i,a}}function xe(e,t,n,i,o){return function(r){if(!(0,p.A)(r)||!(0,p.A)(r.length)||r.length<1||r.length>4)throw new f.A("value must be and array with length between 1 and 4.");const a=Y(r);e.setBatchedAttribute(t,n,a),"offset"===o&&(i._recomputeBoundingSpheres=!0,i._batchTableOffsetsUpdated=!1)}}const Ce=new r.A;function Ee(e,t,n,i){e._error=i,e._state=n,t.afterRender.push(function(){e._ready=e._state===V.A.COMPLETE||e._state===V.A.FAILED})}U.prototype.getGeometryInstanceAttributes=function(e){if(!(0,p.A)(e))throw new f.A("id is required");if(!(0,p.A)(this._batchTable))throw new f.A("must call update before calling getGeometryInstanceAttributes");let t=this._perInstanceAttributeCache.get(e);if((0,p.A)(t))return t;let n=-1;const o=this._lastPerInstanceAttributeIndex,a=this._instanceIds,s=a.length;for(let t=0;t<s;++t){const i=(o+t)%s;if(e===a[i]){n=i;break}}if(-1===n)return;const c=this._batchTable,l=this._batchTableAttributeIndices;t={};const h={};for(const e in l)if(l.hasOwnProperty(e)){const t=l[e];h[e]={get:Te(c,n,t),set:xe(c,n,t,this,e)}}return function(e,t,n){t.boundingSphere={get:function(){let o=e._instanceBoundingSpheres[n];if((0,p.A)(o)){o=o.clone();const a=e.modelMatrix,s=t.offset;(0,p.A)(s)&&we(o,r.A.fromArray(s.get(),0,Ce),e._offsetInstanceExtend[n]),(0,p.A)(a)&&(o=i.A.transform(o,a))}return o}},t.boundingSphereCV={get:function(){return e._instanceBoundingSpheresCV[n]}}}(this,h,n),function(e,t,n){t.pickId={get:function(){return e._pickIds[n]}}}(this,h,n),Object.defineProperties(t,h),this._lastPerInstanceAttributeIndex=n,this._perInstanceAttributeCache.set(e,t),t},U.prototype.isDestroyed=function(){return!1},U.prototype.destroy=function(){let e,t;this._sp=this._sp&&this._sp.destroy(),this._spDepthFail=this._spDepthFail&&this._spDepthFail.destroy();const n=this._va;for(e=n.length,t=0;t<e;++t)n[t].destroy();this._va=void 0;const i=this._pickIds;for(e=i.length,t=0;t<e;++t)i[t].destroy();return this._pickIds=void 0,this._batchTable=this._batchTable&&this._batchTable.destroy(),this._instanceIds=void 0,this._perInstanceAttributeCache=void 0,this._attributeLocations=void 0,(0,m.A)(this)};const Se=U},632791:(e,t,n)=>{"use strict";n.d(t,{A:()=>x});var i=n(660662),o=n(571804),r=n(491446),a=n(605971),s=n(610750),c=n(653577),l=n(944479),h=n(305439),u=n(46362),d=n(34233),p=n(874915),m=n(584164),f=n(852575),A=n(414305);function _(e,t){const n=e.attributes,i=n.position,r=i.values.length/i.componentsPerAttribute;n.batchId=new h.A({componentDatatype:o.A.FLOAT,componentsPerAttribute:1,values:new Float32Array(r)});const a=n.batchId.values;for(let e=0;e<r;++e)a[e]=t}function g(e,t,n,i){let o,a,s;const c=i.length-1;if(c>=0){const e=i[c];o=e.offset+e.count,s=e.index,a=n[s].indices.length}else o=0,s=0,a=n[s].indices.length;const l=e.length;for(let c=0;c<l;++c){const l=e[c][t];if(!(0,r.A)(l))continue;const h=l.indices.length;o+h>a&&(o=0,a=n[++s].indices.length),i.push({index:s,offset:o,count:h}),o+=h}}const y={};function v(e,t){const n=e.attributes;for(const e in n)if(n.hasOwnProperty(e)){const i=n[e];(0,r.A)(i)&&(0,r.A)(i.values)&&t.push(i.values.buffer)}(0,r.A)(e.indices)&&t.push(e.indices.buffer)}function b(e,t){const n=e.length,i=new Float64Array(1+19*n);let o=0;i[o++]=n;for(let t=0;t<n;t++){const n=e[t];if(m.A.pack(n.modelMatrix,i,o),o+=m.A.packedLength,(0,r.A)(n.attributes)&&(0,r.A)(n.attributes.offset)){const e=n.attributes.offset.value;i[o]=e[0],i[o+1]=e[1],i[o+2]=e[2]}o+=3}return t.push(i.buffer),i}function w(e){const t=e.length,n=1+(i.A.packedLength+1)*t,o=new Float32Array(n);let a=0;o[a++]=t;for(let n=0;n<t;++n){const t=e[n];(0,r.A)(t)?(o[a++]=1,i.A.pack(e[n],o,a)):o[a++]=0,a+=i.A.packedLength}return o}function T(e){const t=new Array(e[0]);let n=0,o=1;for(;o<e.length;)1===e[o++]&&(t[n]=i.A.unpack(e,o)),++n,o+=i.A.packedLength;return t}y.combineGeometry=function(e){let t,n;const s=e.instances,c=s.length;let l,h,u=!1;c>0&&(t=function(e){const t=e.instances,n=e.projection,s=e.elementIndexUintSupported,c=e.scene3DOnly,l=e.vertexCacheOptimize,h=e.compressVertices,u=e.modelMatrix;let p,f,A,g=t.length;for(p=0;p<g;++p)if((0,r.A)(t[p].geometry)){A=t[p].geometry.primitiveType;break}for(p=1;p<g;++p)if((0,r.A)(t[p].geometry)&&t[p].geometry.primitiveType!==A)throw new a.A("All instance geometries must have the same primitiveType.");if(function(e,t,n){let i=!n;const o=e.length;let a;if(!i&&o>1){const t=e[0].modelMatrix;for(a=1;a<o;++a)if(!m.A.equals(t,e[a].modelMatrix)){i=!0;break}}if(i)for(a=0;a<o;++a)(0,r.A)(e[a].geometry)&&d.A.transformToWorldCoordinates(e[a]);else m.A.multiplyTransformation(t,e[0].modelMatrix,t)}(t,u,c),!c)for(p=0;p<g;++p)(0,r.A)(t[p].geometry)&&d.A.splitLongitude(t[p]);if(function(e){const t=e.length;for(let n=0;n<t;++n){const t=e[n];(0,r.A)(t.geometry)?_(t.geometry,n):(0,r.A)(t.westHemisphereGeometry)&&(0,r.A)(t.eastHemisphereGeometry)&&(_(t.westHemisphereGeometry,n),_(t.eastHemisphereGeometry,n))}}(t),l)for(p=0;p<g;++p){const e=t[p];(0,r.A)(e.geometry)?(d.A.reorderForPostVertexCache(e.geometry),d.A.reorderForPreVertexCache(e.geometry)):(0,r.A)(e.westHemisphereGeometry)&&(0,r.A)(e.eastHemisphereGeometry)&&(d.A.reorderForPostVertexCache(e.westHemisphereGeometry),d.A.reorderForPreVertexCache(e.westHemisphereGeometry),d.A.reorderForPostVertexCache(e.eastHemisphereGeometry),d.A.reorderForPreVertexCache(e.eastHemisphereGeometry))}let y=d.A.combineInstances(t);for(g=y.length,p=0;p<g;++p){f=y[p];const e=f.attributes;if(c)for(const t in e)e.hasOwnProperty(t)&&e[t].componentDatatype===o.A.DOUBLE&&d.A.encodeAttribute(f,t,`${t}3DHigh`,`${t}3DLow`);else for(const t in e)if(e.hasOwnProperty(t)&&e[t].componentDatatype===o.A.DOUBLE){const e=`${t}3D`,o=`${t}2D`;d.A.projectTo2D(f,t,e,o,n),(0,r.A)(f.boundingSphere)&&"position"===t&&(f.boundingSphereCV=i.A.fromVertices(f.attributes.position2D.values)),d.A.encodeAttribute(f,e,`${e}High`,`${e}Low`),d.A.encodeAttribute(f,o,`${o}High`,`${o}Low`)}h&&d.A.compressVertices(f)}if(!s){let e=[];for(g=y.length,p=0;p<g;++p)f=y[p],e=e.concat(d.A.fitToUnsignedShortIndices(f));y=e}return y}(e),t.length>0&&(n=d.A.createAttributeLocations(t[0]),e.createPickOffsets&&(l=function(e,t){const n=[];return g(e,"geometry",t,n),g(e,"westHemisphereGeometry",t,n),g(e,"eastHemisphereGeometry",t,n),n}(s,t))),(0,r.A)(s[0].attributes)&&(0,r.A)(s[0].attributes.offset)&&(h=new Array(c),u=!0));const p=new Array(c),f=new Array(c);for(let e=0;e<c;++e){const t=s[e],n=t.geometry;(0,r.A)(n)&&(p[e]=n.boundingSphere,f[e]=n.boundingSphereCV,u&&(h[e]=t.geometry.offsetAttribute));const o=t.eastHemisphereGeometry,a=t.westHemisphereGeometry;(0,r.A)(o)&&(0,r.A)(a)&&((0,r.A)(o.boundingSphere)&&(0,r.A)(a.boundingSphere)&&(p[e]=i.A.union(o.boundingSphere,a.boundingSphere)),(0,r.A)(o.boundingSphereCV)&&(0,r.A)(a.boundingSphereCV)&&(f[e]=i.A.union(o.boundingSphereCV,a.boundingSphereCV)))}return{geometries:t,modelMatrix:e.modelMatrix,attributeLocations:n,pickOffsets:l,offsetInstanceExtend:h,boundingSpheres:p,boundingSpheresCV:f}},y.packCreateGeometryResults=function(e,t){const n=new Float64Array(function(e){let t=1;const n=e.length;for(let o=0;o<n;o++){const n=e[o];if(++t,!(0,r.A)(n))continue;const a=n.attributes;t+=7+2*i.A.packedLength+((0,r.A)(n.indices)?n.indices.length:0);for(const e in a)a.hasOwnProperty(e)&&(0,r.A)(a[e])&&(t+=5+a[e].values.length)}return t}(e)),o=[],a={},s=e.length;let c=0;n[c++]=s;for(let t=0;t<s;t++){const s=e[t],l=(0,r.A)(s);if(n[c++]=l?1:0,!l)continue;n[c++]=s.primitiveType,n[c++]=s.geometryType,n[c++]=s.offsetAttribute??-1;const h=(0,r.A)(s.boundingSphere)?1:0;n[c++]=h,h&&i.A.pack(s.boundingSphere,n,c),c+=i.A.packedLength;const u=(0,r.A)(s.boundingSphereCV)?1:0;n[c++]=u,u&&i.A.pack(s.boundingSphereCV,n,c),c+=i.A.packedLength;const d=s.attributes,p=[];for(const e in d)d.hasOwnProperty(e)&&(0,r.A)(d[e])&&(p.push(e),(0,r.A)(a[e])||(a[e]=o.length,o.push(e)));n[c++]=p.length;for(let e=0;e<p.length;e++){const t=p[e],i=d[t];n[c++]=a[t],n[c++]=i.componentDatatype,n[c++]=i.componentsPerAttribute,n[c++]=i.normalize?1:0,n[c++]=i.values.length,n.set(i.values,c),c+=i.values.length}const m=(0,r.A)(s.indices)?s.indices.length:0;n[c++]=m,m>0&&(n.set(s.indices,c),c+=m)}return t.push(n.buffer),{stringTable:o,packedData:n}},y.unpackCreateGeometryResults=function(e){const t=e.stringTable,n=e.packedData;let r;const a=new Array(n[0]);let s=0,c=1;for(;c<n.length;){if(1!==n[c++]){a[s++]=void 0;continue}const e=n[c++],d=n[c++];let m,f,A,_,g,y=n[c++];-1===y&&(y=void 0),1===n[c++]&&(m=i.A.unpack(n,c)),c+=i.A.packedLength,1===n[c++]&&(f=i.A.unpack(n,c)),c+=i.A.packedLength;const v=new u.A,b=n[c++];for(r=0;r<b;r++){const e=t[n[c++]],i=n[c++];g=n[c++];const r=0!==n[c++];A=n[c++],_=o.A.createTypedArray(i,A);for(let e=0;e<A;e++)_[e]=n[c++];v[e]=new h.A({componentDatatype:i,componentsPerAttribute:g,normalize:r,values:_})}let w;if(A=n[c++],A>0){const e=_.length/g;for(w=p.A.createTypedArray(e,A),r=0;r<A;r++)w[r]=n[c++]}a[s++]=new l.A({primitiveType:e,geometryType:d,boundingSphere:m,boundingSphereCV:f,indices:w,attributes:v,offsetAttribute:y})}return a},y.packCombineGeometryParameters=function(e,t){const n=e.createGeometryResults,i=n.length;for(let e=0;e<i;e++)t.push(n[e].packedData.buffer);return{createGeometryResults:e.createGeometryResults,packedInstances:b(e.instances,t),ellipsoid:e.ellipsoid,isGeographic:e.projection instanceof c.A,elementIndexUintSupported:e.elementIndexUintSupported,scene3DOnly:e.scene3DOnly,vertexCacheOptimize:e.vertexCacheOptimize,compressVertices:e.compressVertices,modelMatrix:e.modelMatrix,createPickOffsets:e.createPickOffsets}},y.unpackCombineGeometryParameters=function(e){const t=function(e){const t=e,n=new Array(t[0]);let i=0,o=1;for(;o<t.length;){const e=m.A.unpack(t,o);let a;o+=m.A.packedLength,(0,r.A)(t[o])&&(a={offset:new f.A(t[o],t[o+1],t[o+2])}),o+=3,n[i++]={modelMatrix:e,attributes:a}}return n}(e.packedInstances),n=e.createGeometryResults,i=n.length;let o=0;for(let e=0;e<i;e++){const i=y.unpackCreateGeometryResults(n[e]),r=i.length;for(let e=0;e<r;e++){const n=i[e];t[o].geometry=n,++o}}const a=s.A.clone(e.ellipsoid);return{instances:t,ellipsoid:a,projection:e.isGeographic?new c.A(a):new A.A(a),elementIndexUintSupported:e.elementIndexUintSupported,scene3DOnly:e.scene3DOnly,vertexCacheOptimize:e.vertexCacheOptimize,compressVertices:e.compressVertices,modelMatrix:m.A.clone(e.modelMatrix),createPickOffsets:e.createPickOffsets}},y.packCombineGeometryResults=function(e,t){(0,r.A)(e.geometries)&&function(e,t){const n=e.length;for(let i=0;i<n;++i)v(e[i],t)}(e.geometries,t);const n=w(e.boundingSpheres),i=w(e.boundingSpheresCV);return t.push(n.buffer,i.buffer),{geometries:e.geometries,attributeLocations:e.attributeLocations,modelMatrix:e.modelMatrix,pickOffsets:e.pickOffsets,offsetInstanceExtend:e.offsetInstanceExtend,boundingSpheres:n,boundingSpheresCV:i}},y.unpackCombineGeometryResults=function(e){return{geometries:e.geometries,attributeLocations:e.attributeLocations,modelMatrix:e.modelMatrix,pickOffsets:e.pickOffsets,offsetInstanceExtend:e.offsetInstanceExtend,boundingSpheres:T(e.boundingSpheres),boundingSpheresCV:T(e.boundingSpheresCV)}};const x=y},871160:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i=Object.freeze({READY:0,CREATING:1,CREATED:2,COMBINING:3,COMBINED:4,COMPLETE:5,FAILED:6})},589834:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i=Object.freeze({FONT_SIZE:48,PADDING:10,RADIUS:8,CUTOFF:.25})},62467:(e,t,n)=>{"use strict";n.d(t,{A:()=>o});const i={MORPHING:0,COLUMBUS_VIEW:1,SCENE2D:2,SCENE3D:3,getMorphTime:function(e){return e===i.SCENE3D?1:e!==i.MORPHING?0:void 0}},o=Object.freeze(i)},78173:(e,t,n)=>{"use strict";n.d(t,{A:()=>L});var i=n(647934),o=n(434067),r=n(267980),a=n(626809),s=n(336946),c=n(491446),l=n(605971),h=n(367817),u=n(584164),d=n(811203),p=n(65891),m=n(543622),f=n(62467);const A={},_=new a.A(0,0,0,1);let g=new a.A;const y=new i.A,v=new o.A,b=new o.A;A.worldToWindowCoordinates=function(e,t,n){return A.worldWithEyeOffsetToWindowCoordinates(e,t,r.A.ZERO,n)};const w=new a.A,T=new r.A;function x(e,t,n,i){const o=n.viewMatrix,s=u.A.multiplyByVector(o,a.A.fromElements(e.x,e.y,e.z,1,w),w),c=r.A.multiplyComponents(t,r.A.normalize(s,T),T);return s.x+=t.x+c.x,s.y+=t.y+c.y,s.z+=c.z,u.A.multiplyByVector(n.frustum.projectionMatrix,s,i)}const C=new s.A(Math.PI,h.A.PI_OVER_TWO),E=new r.A,S=new r.A;A.worldWithEyeOffsetToWindowCoordinates=function(e,t,n,i){if(!(0,c.A)(e))throw new l.A("scene is required.");if(!(0,c.A)(t))throw new l.A("position is required.");const a=e.frameState,s=A.computeActualEllipsoidPosition(a,t,_);if(!(0,c.A)(s))return;const w=e.canvas,T=y;T.x=0,T.y=0,T.width=w.clientWidth,T.height=w.clientHeight;const D=e.camera;let O=!1;if(a.mode===f.A.SCENE2D){const t=e.mapProjection,a=C,c=t.project(a,E),l=r.A.clone(D.position,S),d=D.frustum.clone(),p=u.A.computeViewportTransformation(T,0,1,new u.A),f=D.frustum.projectionMatrix,_=D.positionWC.y,y=r.A.fromElements(h.A.sign(_)*c.x-_,0,-D.positionWC.x),z=m.A.pointToGLWindowCoordinates(f,p,y);if(0===_||z.x<=0||z.x>=w.clientWidth)O=!0;else{if(z.x>.5*w.clientWidth){T.width=z.x,D.frustum.right=c.x-_,g=x(s,n,D,g),A.clipToGLWindowCoordinates(T,g,v),T.x+=z.x,D.position.x=-D.position.x;const e=D.frustum.right;D.frustum.right=-D.frustum.left,D.frustum.left=-e,g=x(s,n,D,g),A.clipToGLWindowCoordinates(T,g,b)}else{T.x+=z.x,T.width-=z.x,D.frustum.left=-c.x-_,g=x(s,n,D,g),A.clipToGLWindowCoordinates(T,g,v),T.x=T.x-T.width,D.position.x=-D.position.x;const e=D.frustum.left;D.frustum.left=-D.frustum.right,D.frustum.right=-e,g=x(s,n,D,g),A.clipToGLWindowCoordinates(T,g,b)}r.A.clone(l,D.position),D.frustum=d.clone(),((i=o.A.clone(v,i)).x<0||i.x>w.clientWidth)&&(i.x=b.x)}}if(a.mode!==f.A.SCENE2D||O){if(g=x(s,n,D,g),g.z<0&&!(D.frustum instanceof d.A)&&!(D.frustum instanceof p.A))return;i=A.clipToGLWindowCoordinates(T,g,i)}return i.y=w.clientHeight-i.y,i},A.worldToDrawingBufferCoordinates=function(e,t,n){if(n=A.worldToWindowCoordinates(e,t,n),(0,c.A)(n))return A.transformWindowToDrawingBuffer(e,n,n)};const D=new r.A,O=new s.A;A.computeActualEllipsoidPosition=function(e,t,n){const i=e.mode;if(i===f.A.SCENE3D)return r.A.clone(t,n);const o=e.mapProjection,a=o.ellipsoid.cartesianToCartographic(t,O);if(!(0,c.A)(a))return;if(o.project(a,D),i===f.A.COLUMBUS_VIEW)return r.A.fromElements(D.z,D.x,D.y,n);if(i===f.A.SCENE2D)return r.A.fromElements(0,D.x,D.y,n);const s=e.morphTime;return r.A.fromElements(h.A.lerp(D.z,t.x,s),h.A.lerp(D.x,t.y,s),h.A.lerp(D.y,t.z,s),n)};const z=new r.A,I=new r.A,P=new u.A;A.clipToGLWindowCoordinates=function(e,t,n){return r.A.divideByScalar(t,t.w,z),u.A.computeViewportTransformation(e,0,1,P),u.A.multiplyByPoint(P,z,I),o.A.fromCartesian3(I,n)},A.transformWindowToDrawingBuffer=function(e,t,n){const i=e.canvas,r=e.drawingBufferWidth/i.clientWidth,a=e.drawingBufferHeight/i.clientHeight;return o.A.fromElements(t.x*r,t.y*a,n)};const R=new a.A,N=new a.A;A.drawingBufferToWorldCoordinates=function(e,t,n,i){const o=e.context.uniformState,s=o.currentFrustum,l=s.x,h=s.y;if(e.frameState.useLogDepth){const e=n*o.log2FarDepthFromNearPlusOne;n=h*(1-l/(Math.pow(2,e)-1+l))/(h-l)}const d=e.view.passState.viewport,p=a.A.clone(a.A.UNIT_W,R);let m;p.x=(t.x-d.x)/d.width*2-1,p.y=(t.y-d.y)/d.height*2-1,p.z=2*n-1,p.w=1;let f=e.camera.frustum;if((0,c.A)(f.fovy)){m=u.A.multiplyByVector(o.inverseViewProjection,p,N);const e=1/m.w;r.A.multiplyByScalar(m,e,m)}else{const e=f.offCenterFrustum;(0,c.A)(e)&&(f=e),m=N,m.x=.5*(p.x*(f.right-f.left)+f.left+f.right),m.y=.5*(p.y*(f.top-f.bottom)+f.bottom+f.top),m.z=.5*(p.z*(l-h)-l-h),m.w=1,m=u.A.multiplyByVector(o.inverseView,m,m)}return r.A.fromCartesian4(m,i)};const L=A},988609:(e,t,n)=>{"use strict";n.d(t,{A:()=>o});const i={DISABLED:0,ENABLED:1,CAST_ONLY:2,RECEIVE_ONLY:3,NUMBER_OF_SHADOW_MODES:4,castShadows:function(e){return e===i.ENABLED||e===i.CAST_ONLY},receiveShadows:function(e){return e===i.ENABLED||e===i.RECEIVE_ONLY},fromCastReceive:function(e,t){return e&&t?i.ENABLED:e?i.CAST_ONLY:t?i.RECEIVE_ONLY:i.DISABLED}},o=Object.freeze(i)},395250:(e,t,n)=>{"use strict";n.d(t,{A:()=>W});var i=n(434067),o=n(267980),r=n(336946),a=n(369031),s=n(571804),c=n(491446),l=n(816422),h=n(494938),u=n(367817),d=n(584164),p=n(697422),m=n(543622),f=n(342875),A=n(612123),_=n(710807);function g(e,t,n){a.A.typeOf.bool("extentsCulling",e),a.A.typeOf.bool("planarExtents",t),a.A.typeOf.object("appearance",n),this._projectionExtentDefines={eastMostYhighDefine:"",eastMostYlowDefine:"",westMostYhighDefine:"",westMostYlowDefine:""};const i=new T;i.requiresTextureCoordinates=e,i.requiresEC=!n.flat;const o=new T;if(o.requiresTextureCoordinates=e,n instanceof A.A)i.requiresNormalEC=!n.flat;else{const e=`${n.material.shaderSource}\n${n.fragmentShaderSource}`;i.normalEC=-1!==e.indexOf("materialInput.normalEC")||-1!==e.indexOf("czm_getDefaultMaterial"),i.positionToEyeEC=-1!==e.indexOf("materialInput.positionToEyeEC"),i.tangentToEyeMatrix=-1!==e.indexOf("materialInput.tangentToEyeMatrix"),i.st=-1!==e.indexOf("materialInput.st")}this._colorShaderDependencies=i,this._pickShaderDependencies=o,this._appearance=n,this._extentsCulling=e,this._planarExtents=t}g.prototype.createFragmentShader=function(e){a.A.typeOf.bool("columbusView2D",e);const t=this._appearance,n=this._colorShaderDependencies,i=[];e||this._planarExtents||i.push("SPHERICAL"),n.requiresEC&&i.push("REQUIRES_EC"),n.requiresWC&&i.push("REQUIRES_WC"),n.requiresTextureCoordinates&&i.push("TEXTURE_COORDINATES"),this._extentsCulling&&i.push("CULL_FRAGMENTS"),n.requiresNormalEC&&i.push("NORMAL_EC"),t instanceof A.A&&i.push("PER_INSTANCE_COLOR"),n.normalEC&&i.push("USES_NORMAL_EC"),n.positionToEyeEC&&i.push("USES_POSITION_TO_EYE_EC"),n.tangentToEyeMatrix&&i.push("USES_TANGENT_TO_EYE"),n.st&&i.push("USES_ST"),t.flat&&i.push("FLAT");let o="";return t instanceof A.A||(o=t.material.shaderSource),new f.A({defines:i,sources:[o,_.A]})},g.prototype.createPickFragmentShader=function(e){a.A.typeOf.bool("columbusView2D",e);const t=this._pickShaderDependencies,n=["PICK"];return e||this._planarExtents||n.push("SPHERICAL"),t.requiresEC&&n.push("REQUIRES_EC"),t.requiresWC&&n.push("REQUIRES_WC"),t.requiresTextureCoordinates&&n.push("TEXTURE_COORDINATES"),this._extentsCulling&&n.push("CULL_FRAGMENTS"),new f.A({defines:n,sources:[_.A],pickColorQualifier:"in"})},g.prototype.createVertexShader=function(e,t,n,i){return a.A.defined("defines",e),a.A.typeOf.string("vertexShaderSource",t),a.A.typeOf.bool("columbusView2D",n),a.A.defined("mapProjection",i),w(this._colorShaderDependencies,this._planarExtents,n,e,t,this._appearance,i,this._projectionExtentDefines)},g.prototype.createPickVertexShader=function(e,t,n,i){return a.A.defined("defines",e),a.A.typeOf.string("vertexShaderSource",t),a.A.typeOf.bool("columbusView2D",n),a.A.defined("mapProjection",i),w(this._pickShaderDependencies,this._planarExtents,n,e,t,void 0,i,this._projectionExtentDefines)};const y=new o.A,v=new r.A,b={high:0,low:0};function w(e,t,n,i,o,r,a,s){const h=i.slice();if(""===s.eastMostYhighDefine){const e=v;e.longitude=u.A.PI,e.latitude=0,e.height=0;const t=a.project(e,y);let n=l.A.encode(t.x,b);s.eastMostYhighDefine=`EAST_MOST_X_HIGH ${n.high.toFixed(`${n.high}`.length+1)}`,s.eastMostYlowDefine=`EAST_MOST_X_LOW ${n.low.toFixed(`${n.low}`.length+1)}`;const i=v;i.longitude=-u.A.PI,i.latitude=0,i.height=0;const o=a.project(i,y);n=l.A.encode(o.x,b),s.westMostYhighDefine=`WEST_MOST_X_HIGH ${n.high.toFixed(`${n.high}`.length+1)}`,s.westMostYlowDefine=`WEST_MOST_X_LOW ${n.low.toFixed(`${n.low}`.length+1)}`}return n&&(h.push(s.eastMostYhighDefine),h.push(s.eastMostYlowDefine),h.push(s.westMostYhighDefine),h.push(s.westMostYlowDefine)),(0,c.A)(r)&&r instanceof A.A&&h.push("PER_INSTANCE_COLOR"),e.requiresTextureCoordinates&&(h.push("TEXTURE_COORDINATES"),t||n||h.push("SPHERICAL"),n&&h.push("COLUMBUS_VIEW_2D")),new f.A({defines:h,sources:[o]})}function T(){this._requiresEC=!1,this._requiresWC=!1,this._requiresNormalEC=!1,this._requiresTextureCoordinates=!1,this._usesNormalEC=!1,this._usesPositionToEyeEC=!1,this._usesTangentToEyeMat=!1,this._usesSt=!1}function x(e,t,n){return Math.abs((t.y-e.y)*n.x-(t.x-e.x)*n.y+t.x*e.y-t.y*e.x)/i.A.distance(t,e)}Object.defineProperties(T.prototype,{requiresEC:{get:function(){return this._requiresEC},set:function(e){this._requiresEC=e||this._requiresEC}},requiresWC:{get:function(){return this._requiresWC},set:function(e){this._requiresWC=e||this._requiresWC,this.requiresEC=this._requiresWC}},requiresNormalEC:{get:function(){return this._requiresNormalEC},set:function(e){this._requiresNormalEC=e||this._requiresNormalEC,this.requiresEC=this._requiresNormalEC}},requiresTextureCoordinates:{get:function(){return this._requiresTextureCoordinates},set:function(e){this._requiresTextureCoordinates=e||this._requiresTextureCoordinates,this.requiresWC=this._requiresTextureCoordinates}},normalEC:{set:function(e){this.requiresNormalEC=e,this._usesNormalEC=e},get:function(){return this._usesNormalEC}},tangentToEyeMatrix:{set:function(e){this.requiresWC=e,this.requiresNormalEC=e,this._usesTangentToEyeMat=e},get:function(){return this._usesTangentToEyeMat}},positionToEyeEC:{set:function(e){this.requiresEC=e,this._usesPositionToEyeEC=e},get:function(){return this._usesPositionToEyeEC}},st:{set:function(e){this.requiresTextureCoordinates=e,this._usesSt=e},get:function(){return this._usesSt}}});const C=[new i.A,new i.A,new i.A,new i.A];function E(e,t){const n=C,o=i.A.unpack(t,0,n[0]),r=i.A.unpack(t,2,n[1]),a=i.A.unpack(t,4,n[2]);e.uMaxVmax=new h.A({componentDatatype:s.A.FLOAT,componentsPerAttribute:4,normalize:!1,value:[r.x,r.y,a.x,a.y]});const c=1/x(o,r,a),l=1/x(o,a,r);e.uvMinAndExtents=new h.A({componentDatatype:s.A.FLOAT,componentsPerAttribute:4,normalize:!1,value:[o.x,o.y,c,l]})}const S=new r.A,D=new o.A,O=new o.A,z=new o.A,I={high:0,low:0};function P(e,t,n){const i=S;i.height=0,i.longitude=e.west,i.latitude=e.south;const o=t.project(i,D);i.latitude=e.north;const r=t.project(i,O);i.longitude=e.east,i.latitude=e.south;const a=t.project(i,z),c=[0,0,0,0],u=[0,0,0,0];let d=l.A.encode(o.x,I);c[0]=d.high,u[0]=d.low,d=l.A.encode(o.y,I),c[1]=d.high,u[1]=d.low,d=l.A.encode(r.y,I),c[2]=d.high,u[2]=d.low,d=l.A.encode(a.x,I),c[3]=d.high,u[3]=d.low,n.planes2D_HIGH=new h.A({componentDatatype:s.A.FLOAT,componentsPerAttribute:4,normalize:!1,value:c}),n.planes2D_LOW=new h.A({componentDatatype:s.A.FLOAT,componentsPerAttribute:4,normalize:!1,value:u})}const R=new d.A,N=new d.A,L=new o.A,M=new r.A,F=[new r.A,new r.A,new r.A,new r.A,new r.A,new r.A,new r.A,new r.A],B=new o.A,k=new o.A,V=new l.A;g.getPlanarTextureCoordinateAttributes=function(e,t,n,i,c){a.A.typeOf.object("boundingRectangle",e),a.A.defined("textureCoordinateRotationPoints",t),a.A.typeOf.object("ellipsoid",n),a.A.typeOf.object("projection",i);const u=D,f=B,A=k;!function(e,t,n,i,a,s){const c=p.A.center(e,M);c.height=n;const l=r.A.toCartesian(c,t,L),h=m.A.eastNorthUpToFixedFrame(l,t,R),u=d.A.inverse(h,N),f=e.west,A=e.east,_=e.north,g=e.south,y=F;y[0].latitude=g,y[0].longitude=f,y[1].latitude=_,y[1].longitude=f,y[2].latitude=_,y[2].longitude=A,y[3].latitude=g,y[3].longitude=A;const v=.5*(f+A),b=.5*(_+g);y[4].latitude=g,y[4].longitude=v,y[5].latitude=_,y[5].longitude=v,y[6].latitude=b,y[6].longitude=f,y[7].latitude=b,y[7].longitude=A;let w=Number.POSITIVE_INFINITY,T=Number.NEGATIVE_INFINITY,x=Number.POSITIVE_INFINITY,C=Number.NEGATIVE_INFINITY;for(let e=0;e<8;e++){y[e].height=n;const i=r.A.toCartesian(y[e],t,L);d.A.multiplyByPoint(u,i,i),i.z=0,w=Math.min(w,i.x),T=Math.max(T,i.x),x=Math.min(x,i.y),C=Math.max(C,i.y)}const E=i;E.x=w,E.y=x,E.z=0,d.A.multiplyByPoint(h,E,E);const S=a;S.x=T,S.y=x,S.z=0,d.A.multiplyByPoint(h,S,S),o.A.subtract(S,E,a);const D=s;D.x=w,D.y=C,D.z=0,d.A.multiplyByPoint(h,D,D),o.A.subtract(D,E,s)}(e,n,c??0,u,f,A);const _={};E(_,t);const g=l.A.fromCartesian(u,V);return _.southWest_HIGH=new h.A({componentDatatype:s.A.FLOAT,componentsPerAttribute:3,normalize:!1,value:o.A.pack(g.high,[0,0,0])}),_.southWest_LOW=new h.A({componentDatatype:s.A.FLOAT,componentsPerAttribute:3,normalize:!1,value:o.A.pack(g.low,[0,0,0])}),_.eastward=new h.A({componentDatatype:s.A.FLOAT,componentsPerAttribute:3,normalize:!1,value:o.A.pack(f,[0,0,0])}),_.northward=new h.A({componentDatatype:s.A.FLOAT,componentsPerAttribute:3,normalize:!1,value:o.A.pack(A,[0,0,0])}),P(e,i,_),_};const G=new o.A;function H(e,t,n,i){const o=S;o.latitude=e,o.longitude=t,o.height=0;const a=r.A.toCartesian(o,n,G),s=Math.sqrt(a.x*a.x+a.y*a.y),c=u.A.fastApproximateAtan2(s,a.z),l=u.A.fastApproximateAtan2(a.x,a.y);return i.x=c,i.y=l,i}const U=new i.A;g.getSphericalExtentGeometryInstanceAttributes=function(e,t,n,i){a.A.typeOf.object("boundingRectangle",e),a.A.defined("textureCoordinateRotationPoints",t),a.A.typeOf.object("ellipsoid",n),a.A.typeOf.object("projection",i);const o=H(e.south,e.west,n,U);let r=o.x,c=o.y;const l=H(e.north,e.east,n,U);let d=l.x,p=l.y,m=0;c>p&&(m=u.A.PI-c,c=-u.A.PI,p+=m),r-=u.A.EPSILON5,c-=u.A.EPSILON5,d+=u.A.EPSILON5,p+=u.A.EPSILON5;const f=1/(p-c),A=1/(d-r),_={sphericalExtents:new h.A({componentDatatype:s.A.FLOAT,componentsPerAttribute:4,normalize:!1,value:[r,c,A,f]}),longitudeRotation:new h.A({componentDatatype:s.A.FLOAT,componentsPerAttribute:1,normalize:!1,value:[m]})};return E(_,t),P(e,i,_),_},g.hasAttributesForTextureCoordinatePlanes=function(e){return(0,c.A)(e.southWest_HIGH)&&(0,c.A)(e.southWest_LOW)&&(0,c.A)(e.northward)&&(0,c.A)(e.eastward)&&(0,c.A)(e.planes2D_HIGH)&&(0,c.A)(e.planes2D_LOW)&&(0,c.A)(e.uMaxVmax)&&(0,c.A)(e.uvMinAndExtents)},g.hasAttributesForSphericalExtents=function(e){return(0,c.A)(e.sphericalExtents)&&(0,c.A)(e.longitudeRotation)&&(0,c.A)(e.planes2D_HIGH)&&(0,c.A)(e.planes2D_LOW)&&(0,c.A)(e.uMaxVmax)&&(0,c.A)(e.uvMinAndExtents)},g.shouldUseSphericalCoordinates=function(e){return a.A.typeOf.object("rectangle",e),function(e){return Math.max(e.width,e.height)>g.MAX_WIDTH_FOR_PLANAR_EXTENTS}(e)},g.MAX_WIDTH_FOR_PLANAR_EXTENTS=u.A.toRadians(1);const W=g},913419:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i=Object.freeze({LEFT:-1,NONE:0,RIGHT:1})},938987:(e,t,n)=>{"use strict";n.d(t,{A:()=>a});var i=n(896464),o=n(138151);const r={CESIUM_3D_TILE_MASK:128,SKIP_LOD_MASK:112,SKIP_LOD_BIT_SHIFT:4,CLASSIFICATION_MASK:15,setCesium3DTileBit:function(){return{enabled:!0,frontFunction:i.A.ALWAYS,frontOperation:{fail:o.A.KEEP,zFail:o.A.KEEP,zPass:o.A.REPLACE},backFunction:i.A.ALWAYS,backOperation:{fail:o.A.KEEP,zFail:o.A.KEEP,zPass:o.A.REPLACE},reference:r.CESIUM_3D_TILE_MASK,mask:r.CESIUM_3D_TILE_MASK}}},a=Object.freeze(r)},896464:(e,t,n)=>{"use strict";n.d(t,{A:()=>r});var i=n(352581);const o={NEVER:i.A.NEVER,LESS:i.A.LESS,EQUAL:i.A.EQUAL,LESS_OR_EQUAL:i.A.LEQUAL,GREATER:i.A.GREATER,NOT_EQUAL:i.A.NOTEQUAL,GREATER_OR_EQUAL:i.A.GEQUAL,ALWAYS:i.A.ALWAYS},r=Object.freeze(o)},138151:(e,t,n)=>{"use strict";n.d(t,{A:()=>r});var i=n(352581);const o={ZERO:i.A.ZERO,KEEP:i.A.KEEP,REPLACE:i.A.REPLACE,INCREMENT:i.A.INCR,DECREMENT:i.A.DECR,INVERT:i.A.INVERT,INCREMENT_WRAP:i.A.INCR_WRAP,DECREMENT_WRAP:i.A.DECR_WRAP},r=Object.freeze(o)},742558:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i=Object.freeze({CENTER:0,BOTTOM:1,BASELINE:2,TOP:-1})},495702:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="in vec3 v_positionEC;\nin vec3 v_normalEC;\nin vec4 v_color;\n\nvoid main()\n{\n    vec3 positionToEyeEC = -v_positionEC;\n\n    vec3 normalEC = normalize(v_normalEC);\n#ifdef FACE_FORWARD\n    normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\n#endif\n\n    vec4 color = czm_gammaCorrect(v_color);\n\n    czm_materialInput materialInput;\n    materialInput.normalEC = normalEC;\n    materialInput.positionToEyeEC = positionToEyeEC;\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    material.diffuse = color.rgb;\n    material.alpha = color.a;\n\n    out_FragColor = czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);\n}\n"},328326:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="in vec3 position3DHigh;\nin vec3 position3DLow;\nin vec3 normal;\nin vec4 color;\nin float batchId;\n\nout vec3 v_positionEC;\nout vec3 v_normalEC;\nout vec4 v_color;\n\nvoid main()\n{\n    vec4 p = czm_computePosition();\n\n    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;      // position in eye coordinates\n    v_normalEC = czm_normal * normal;                         // normal in eye coordinates\n    v_color = color;\n\n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\n}\n"},857831:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="in vec4 v_color;\n\nvoid main()\n{\n    out_FragColor = czm_gammaCorrect(v_color);\n}\n"},537335:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="in vec3 position3DHigh;\nin vec3 position3DLow;\nin vec4 color;\nin float batchId;\n\nout vec4 v_color;\n\nvoid main()\n{\n    vec4 p = czm_computePosition();\n\n    v_color = color;\n\n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\n}\n"},692608:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="in vec3 position3DHigh;\nin vec3 position3DLow;\nin vec3 prevPosition3DHigh;\nin vec3 prevPosition3DLow;\nin vec3 nextPosition3DHigh;\nin vec3 nextPosition3DLow;\nin vec2 expandAndWidth;\nin vec4 color;\nin float batchId;\n\nout vec4 v_color;\n\nvoid main()\n{\n    float expandDir = expandAndWidth.x;\n    float width = abs(expandAndWidth.y) + 0.5;\n    bool usePrev = expandAndWidth.y < 0.0;\n\n    vec4 p = czm_computePosition();\n    vec4 prev = czm_computePrevPosition();\n    vec4 next = czm_computeNextPosition();\n\n    float angle;\n    vec4 positionWC = getPolylineWindowCoordinates(p, prev, next, expandDir, width, usePrev, angle);\n    gl_Position = czm_viewportOrthographic * positionWC;\n\n    v_color = color;\n}\n"},438376:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="in vec3 position3DHigh;\nin vec3 position3DLow;\nin vec3 prevPosition3DHigh;\nin vec3 prevPosition3DLow;\nin vec3 nextPosition3DHigh;\nin vec3 nextPosition3DLow;\nin vec2 expandAndWidth;\nin vec2 st;\nin float batchId;\n\nout float v_width;\nout vec2 v_st;\nout float v_polylineAngle;\n\nvoid main()\n{\n    float expandDir = expandAndWidth.x;\n    float width = abs(expandAndWidth.y) + 0.5;\n    bool usePrev = expandAndWidth.y < 0.0;\n\n    vec4 p = czm_computePosition();\n    vec4 prev = czm_computePrevPosition();\n    vec4 next = czm_computeNextPosition();\n\n    float angle;\n    vec4 positionWC = getPolylineWindowCoordinates(p, prev, next, expandDir, width, usePrev, angle);\n    gl_Position = czm_viewportOrthographic * positionWC;\n\n    v_width = width;\n    v_st.s = st.s;\n    v_st.t = czm_writeNonPerspective(st.t, gl_Position.w);\n    v_polylineAngle = angle;\n}\n"},952738:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i='uniform sampler2D u_atlas;\n\n#ifdef VECTOR_TILE\nuniform vec4 u_highlightColor;\n#endif\n\nin vec2 v_textureCoordinates;\nin vec4 v_pickColor;\nin vec4 v_color;\nin float v_splitDirection;\n\n#ifdef SDF\nin vec4 v_outlineColor;\nin float v_outlineWidth;\n#endif\n\n#ifdef FRAGMENT_DEPTH_CHECK\nin vec4 v_textureCoordinateBounds;                  // the min and max x and y values for the texture coordinates\nin vec4 v_originTextureCoordinateAndTranslate;      // texture coordinate at the origin, billboard translate (used for label glyphs)\nin vec4 v_compressed;                               // x: eyeDepth, y: applyTranslate & enableDepthCheck, z: dimensions, w: imageSize\nin mat2 v_rotationMatrix;\n\nconst float SHIFT_LEFT12 = 4096.0;\nconst float SHIFT_LEFT1 = 2.0;\n\nconst float SHIFT_RIGHT12 = 1.0 / 4096.0;\nconst float SHIFT_RIGHT1 = 1.0 / 2.0;\n\nfloat getGlobeDepth(vec2 adjustedST, vec2 depthLookupST, bool applyTranslate, vec2 dimensions, vec2 imageSize)\n{\n    vec2 lookupVector = imageSize * (depthLookupST - adjustedST);\n    lookupVector = v_rotationMatrix * lookupVector;\n    vec2 labelOffset = (dimensions - imageSize) * (depthLookupST - vec2(0.0, v_originTextureCoordinateAndTranslate.y)); // aligns label glyph with bounding rectangle.  Will be zero for billboards because dimensions and imageSize will be equal\n\n    vec2 translation = v_originTextureCoordinateAndTranslate.zw;\n\n    if (applyTranslate)\n    {\n        // this is only needed for labels where the horizontal origin is not LEFT\n        // it moves the label back to where the "origin" should be since all label glyphs are set to HorizontalOrigin.LEFT\n        translation += (dimensions * v_originTextureCoordinateAndTranslate.xy * vec2(1.0, 0.0));\n    }\n\n    vec2 st = ((lookupVector - translation + labelOffset) + gl_FragCoord.xy) / czm_viewport.zw;\n    float logDepthOrDepth = czm_unpackDepth(texture(czm_globeDepthTexture, st));\n\n    if (logDepthOrDepth == 0.0)\n    {\n        return 0.0; // not on the globe\n    }\n\n    vec4 eyeCoordinate = czm_windowToEyeCoordinates(gl_FragCoord.xy, logDepthOrDepth);\n    return eyeCoordinate.z / eyeCoordinate.w;\n}\n#endif\n\n\n#ifdef SDF\n\n// Get the distance from the edge of a glyph at a given position sampling an SDF texture.\nfloat getDistance(vec2 position)\n{\n    return texture(u_atlas, position).r;\n}\n\n// Samples the sdf texture at the given position and produces a color based on the fill color and the outline.\nvec4 getSDFColor(vec2 position, float outlineWidth, vec4 outlineColor, float smoothing)\n{\n    float distance = getDistance(position);\n\n    if (outlineWidth > 0.0)\n    {\n        // Don\'t get the outline edge exceed the SDF_EDGE\n        float outlineEdge = clamp(SDF_EDGE - outlineWidth, 0.0, SDF_EDGE);\n        float outlineFactor = smoothstep(SDF_EDGE - smoothing, SDF_EDGE + smoothing, distance);\n        vec4 sdfColor = mix(outlineColor, v_color, outlineFactor);\n        float alpha = smoothstep(outlineEdge - smoothing, outlineEdge + smoothing, distance);\n        return vec4(sdfColor.rgb, sdfColor.a * alpha);\n    }\n    else\n    {\n        float alpha = smoothstep(SDF_EDGE - smoothing, SDF_EDGE + smoothing, distance);\n        return vec4(v_color.rgb, v_color.a * alpha);\n    }\n}\n#endif\n\nvoid main()\n{\n    if (v_splitDirection < 0.0 && gl_FragCoord.x > czm_splitPosition) discard;\n    if (v_splitDirection > 0.0 && gl_FragCoord.x < czm_splitPosition) discard;\n    \n    vec4 color = texture(u_atlas, v_textureCoordinates);\n\n#ifdef SDF\n    float outlineWidth = v_outlineWidth;\n    vec4 outlineColor = v_outlineColor;\n\n    // Get the current distance\n    float distance = getDistance(v_textureCoordinates);\n\n#if (__VERSION__ == 300 || defined(GL_OES_standard_derivatives))\n    float smoothing = fwidth(distance);\n    // Get an offset that is approximately half the distance to the neighbor pixels\n    // 0.354 is approximately half of 1/sqrt(2)\n    vec2 sampleOffset = 0.354 * vec2(dFdx(v_textureCoordinates) + dFdy(v_textureCoordinates));\n\n    // Sample the center point\n    vec4 center = getSDFColor(v_textureCoordinates, outlineWidth, outlineColor, smoothing);\n\n    // Sample the 4 neighbors\n    vec4 color1 = getSDFColor(v_textureCoordinates + vec2(sampleOffset.x, sampleOffset.y), outlineWidth, outlineColor, smoothing);\n    vec4 color2 = getSDFColor(v_textureCoordinates + vec2(-sampleOffset.x, sampleOffset.y), outlineWidth, outlineColor, smoothing);\n    vec4 color3 = getSDFColor(v_textureCoordinates + vec2(-sampleOffset.x, -sampleOffset.y), outlineWidth, outlineColor, smoothing);\n    vec4 color4 = getSDFColor(v_textureCoordinates + vec2(sampleOffset.x, -sampleOffset.y), outlineWidth, outlineColor, smoothing);\n\n    // Equally weight the center sample and the 4 neighboring samples\n    color = (center + color1 + color2 + color3 + color4)/5.0;\n#else\n    // If no derivatives available (IE 10?), just do a single sample\n    float smoothing = 1.0/32.0;\n    color = getSDFColor(v_textureCoordinates, outlineWidth, outlineColor, smoothing);\n#endif\n\n    color = czm_gammaCorrect(color);\n#else\n    color = czm_gammaCorrect(color);\n    color *= czm_gammaCorrect(v_color);\n#endif\n\n// Fully transparent parts of the billboard are not pickable.\n#if !defined(OPAQUE) && !defined(TRANSLUCENT)\n    if (color.a < 0.005)   // matches 0/255 and 1/255\n    {\n        discard;\n    }\n#else\n// The billboard is rendered twice. The opaque pass discards translucent fragments\n// and the translucent pass discards opaque fragments.\n#ifdef OPAQUE\n    if (color.a < 0.995)   // matches < 254/255\n    {\n        discard;\n    }\n#else\n    if (color.a >= 0.995)  // matches 254/255 and 255/255\n    {\n        discard;\n    }\n#endif\n#endif\n\n#ifdef VECTOR_TILE\n    color *= u_highlightColor;\n#endif\n    out_FragColor = color;\n\n#ifdef LOG_DEPTH\n    czm_writeLogDepth();\n#endif\n\n#ifdef FRAGMENT_DEPTH_CHECK\n    float temp = v_compressed.y;\n\n    temp = temp * SHIFT_RIGHT1;\n\n    float temp2 = (temp - floor(temp)) * SHIFT_LEFT1;\n    bool enableDepthTest = temp2 != 0.0;\n    bool applyTranslate = floor(temp) != 0.0;\n\n    if (enableDepthTest) {\n        temp = v_compressed.z;\n        temp = temp * SHIFT_RIGHT12;\n\n        vec2 dimensions;\n        dimensions.y = (temp - floor(temp)) * SHIFT_LEFT12;\n        dimensions.x = floor(temp);\n\n        temp = v_compressed.w;\n        temp = temp * SHIFT_RIGHT12;\n\n        vec2 imageSize;\n        imageSize.y = (temp - floor(temp)) * SHIFT_LEFT12;\n        imageSize.x = floor(temp);\n\n        vec2 adjustedST = v_textureCoordinates - v_textureCoordinateBounds.xy;\n        adjustedST = adjustedST / vec2(v_textureCoordinateBounds.z - v_textureCoordinateBounds.x, v_textureCoordinateBounds.w - v_textureCoordinateBounds.y);\n\n        float epsilonEyeDepth = v_compressed.x + czm_epsilon1;\n        float globeDepth1 = getGlobeDepth(adjustedST, v_originTextureCoordinateAndTranslate.xy, applyTranslate, dimensions, imageSize);\n\n        // negative values go into the screen\n        if (globeDepth1 != 0.0 && globeDepth1 > epsilonEyeDepth)\n        {\n            float globeDepth2 = getGlobeDepth(adjustedST, vec2(0.0, 1.0), applyTranslate, dimensions, imageSize); // top left corner\n            if (globeDepth2 != 0.0 && globeDepth2 > epsilonEyeDepth)\n            {\n                float globeDepth3 = getGlobeDepth(adjustedST, vec2(1.0, 1.0), applyTranslate, dimensions, imageSize); // top right corner\n                if (globeDepth3 != 0.0 && globeDepth3 > epsilonEyeDepth)\n                {\n                    discard;\n                }\n            }\n        }\n    }\n#endif\n\n}\n'},412562:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="#ifdef INSTANCED\nin vec2 direction;\n#endif\nin vec4 positionHighAndScale;\nin vec4 positionLowAndRotation;\nin vec4 compressedAttribute0;                       // pixel offset, translate, horizontal origin, vertical origin, show, direction, texture coordinates (texture offset)\nin vec4 compressedAttribute1;                       // aligned axis, translucency by distance, image width\nin vec4 compressedAttribute2;                       // label horizontal origin, image height, color, pick color, size in meters, valid aligned axis, 13 bits free\nin vec4 eyeOffset;                                  // eye offset in meters, 4 bytes free (texture range)\nin vec4 scaleByDistance;                            // near, nearScale, far, farScale\nin vec4 pixelOffsetScaleByDistance;                 // near, nearScale, far, farScale\nin vec4 compressedAttribute3;                       // distance display condition near, far, disableDepthTestDistance, dimensions\nin vec2 sdf;                                        // sdf outline color (rgb) and width (w)\nin float splitDirection;                            // splitDirection\n#if defined(VERTEX_DEPTH_CHECK) || defined(FRAGMENT_DEPTH_CHECK)\nin vec4 textureCoordinateBoundsOrLabelTranslate;    // the min and max x and y values for the texture coordinates\n#endif\n#ifdef VECTOR_TILE\nin float a_batchId;\n#endif\n\nout vec2 v_textureCoordinates;\n#ifdef FRAGMENT_DEPTH_CHECK\nout vec4 v_textureCoordinateBounds;\nout vec4 v_originTextureCoordinateAndTranslate;\nout vec4 v_compressed;                                 // x: eyeDepth, y: applyTranslate & enableDepthCheck, z: dimensions, w: imageSize\nout mat2 v_rotationMatrix;\n#endif\n\nout vec4 v_pickColor;\nout vec4 v_color;\nout float v_splitDirection;\n#ifdef SDF\nout vec4 v_outlineColor;\nout float v_outlineWidth;\n#endif\n\nconst float UPPER_BOUND = 32768.0;\n\nconst float SHIFT_LEFT16 = 65536.0;\nconst float SHIFT_LEFT12 = 4096.0;\nconst float SHIFT_LEFT8 = 256.0;\nconst float SHIFT_LEFT7 = 128.0;\nconst float SHIFT_LEFT5 = 32.0;\nconst float SHIFT_LEFT3 = 8.0;\nconst float SHIFT_LEFT2 = 4.0;\nconst float SHIFT_LEFT1 = 2.0;\n\nconst float SHIFT_RIGHT12 = 1.0 / 4096.0;\nconst float SHIFT_RIGHT8 = 1.0 / 256.0;\nconst float SHIFT_RIGHT7 = 1.0 / 128.0;\nconst float SHIFT_RIGHT5 = 1.0 / 32.0;\nconst float SHIFT_RIGHT3 = 1.0 / 8.0;\nconst float SHIFT_RIGHT2 = 1.0 / 4.0;\nconst float SHIFT_RIGHT1 = 1.0 / 2.0;\n\nvec4 addScreenSpaceOffset(vec4 positionEC, vec2 imageSize, float scale, vec2 direction, vec2 origin, vec2 translate, vec2 pixelOffset, vec3 alignedAxis, bool validAlignedAxis, float rotation, bool sizeInMeters, out mat2 rotationMatrix, out float mpp)\n{\n    // Note the halfSize cannot be computed in JavaScript because it is sent via\n    // compressed vertex attributes that coerce it to an integer.\n    vec2 halfSize = imageSize * scale * 0.5;\n    halfSize *= ((direction * 2.0) - 1.0);\n\n    vec2 originTranslate = origin * abs(halfSize);\n\n#if defined(ROTATION) || defined(ALIGNED_AXIS)\n    if (validAlignedAxis || rotation != 0.0)\n    {\n        float angle = rotation;\n        if (validAlignedAxis)\n        {\n            vec4 projectedAlignedAxis = czm_modelView3D * vec4(alignedAxis, 0.0);\n            angle += sign(-projectedAlignedAxis.x) * acos(sign(projectedAlignedAxis.y) * (projectedAlignedAxis.y * projectedAlignedAxis.y) /\n                    (projectedAlignedAxis.x * projectedAlignedAxis.x + projectedAlignedAxis.y * projectedAlignedAxis.y));\n        }\n\n        float cosTheta = cos(angle);\n        float sinTheta = sin(angle);\n        rotationMatrix = mat2(cosTheta, sinTheta, -sinTheta, cosTheta);\n        halfSize = rotationMatrix * halfSize;\n    }\n    else\n    {\n        rotationMatrix = mat2(1.0, 0.0, 0.0, 1.0);\n    }\n#endif\n\n    mpp = czm_metersPerPixel(positionEC);\n    positionEC.xy += (originTranslate + halfSize) * czm_branchFreeTernary(sizeInMeters, 1.0, mpp);\n    positionEC.xy += (translate + pixelOffset) * mpp;\n\n    return positionEC;\n}\n\n#ifdef VERTEX_DEPTH_CHECK\nfloat getGlobeDepth(vec4 positionEC)\n{\n    vec4 posWC = czm_eyeToWindowCoordinates(positionEC);\n\n    float globeDepth = czm_unpackDepth(texture(czm_globeDepthTexture, posWC.xy / czm_viewport.zw));\n\n    if (globeDepth == 0.0)\n    {\n        return 0.0; // not on the globe\n    }\n\n    vec4 eyeCoordinate = czm_windowToEyeCoordinates(posWC.xy, globeDepth);\n    return eyeCoordinate.z / eyeCoordinate.w;\n}\n#endif\nvoid main()\n{\n    // Modifying this shader may also require modifications to Billboard._computeScreenSpacePosition\n\n    // unpack attributes\n    vec3 positionHigh = positionHighAndScale.xyz;\n    vec3 positionLow = positionLowAndRotation.xyz;\n    float scale = positionHighAndScale.w;\n\n#if defined(ROTATION) || defined(ALIGNED_AXIS)\n    float rotation = positionLowAndRotation.w;\n#else\n    float rotation = 0.0;\n#endif\n\n    float compressed = compressedAttribute0.x;\n\n    vec2 pixelOffset;\n    pixelOffset.x = floor(compressed * SHIFT_RIGHT7);\n    compressed -= pixelOffset.x * SHIFT_LEFT7;\n    pixelOffset.x -= UPPER_BOUND;\n\n    vec2 origin;\n    origin.x = floor(compressed * SHIFT_RIGHT5);\n    compressed -= origin.x * SHIFT_LEFT5;\n\n    origin.y = floor(compressed * SHIFT_RIGHT3);\n    compressed -= origin.y * SHIFT_LEFT3;\n\n#ifdef FRAGMENT_DEPTH_CHECK\n    vec2 depthOrigin = origin.xy;\n#endif\n    origin -= vec2(1.0);\n\n    float show = floor(compressed * SHIFT_RIGHT2);\n    compressed -= show * SHIFT_LEFT2;\n\n#ifdef INSTANCED\n    vec2 textureCoordinatesBottomLeft = czm_decompressTextureCoordinates(compressedAttribute0.w);\n    vec2 textureCoordinatesRange = czm_decompressTextureCoordinates(eyeOffset.w);\n    vec2 textureCoordinates = textureCoordinatesBottomLeft + direction * textureCoordinatesRange;\n#else\n    vec2 direction;\n    direction.x = floor(compressed * SHIFT_RIGHT1);\n    direction.y = compressed - direction.x * SHIFT_LEFT1;\n\n    vec2 textureCoordinates = czm_decompressTextureCoordinates(compressedAttribute0.w);\n#endif\n\n    float temp = compressedAttribute0.y  * SHIFT_RIGHT8;\n    pixelOffset.y = -(floor(temp) - UPPER_BOUND);\n\n    vec2 translate;\n    translate.y = (temp - floor(temp)) * SHIFT_LEFT16;\n\n    temp = compressedAttribute0.z * SHIFT_RIGHT8;\n    translate.x = floor(temp) - UPPER_BOUND;\n\n    translate.y += (temp - floor(temp)) * SHIFT_LEFT8;\n    translate.y -= UPPER_BOUND;\n\n    temp = compressedAttribute1.x * SHIFT_RIGHT8;\n    float temp2 = floor(compressedAttribute2.w * SHIFT_RIGHT2);\n\n    vec2 imageSize = vec2(floor(temp), temp2);\n\n#ifdef FRAGMENT_DEPTH_CHECK\n    float labelHorizontalOrigin = floor(compressedAttribute2.w - (temp2 * SHIFT_LEFT2));\n    float applyTranslate = 0.0;\n    if (labelHorizontalOrigin != 0.0) // is a billboard, so set apply translate to false\n    {\n        applyTranslate = 1.0;\n        labelHorizontalOrigin -= 2.0;\n        depthOrigin.x = labelHorizontalOrigin + 1.0;\n    }\n\n    depthOrigin = vec2(1.0) - (depthOrigin * 0.5);\n#endif\n\n#ifdef EYE_DISTANCE_TRANSLUCENCY\n    vec4 translucencyByDistance;\n    translucencyByDistance.x = compressedAttribute1.z;\n    translucencyByDistance.z = compressedAttribute1.w;\n\n    translucencyByDistance.y = ((temp - floor(temp)) * SHIFT_LEFT8) / 255.0;\n\n    temp = compressedAttribute1.y * SHIFT_RIGHT8;\n    translucencyByDistance.w = ((temp - floor(temp)) * SHIFT_LEFT8) / 255.0;\n#endif\n\n#if defined(VERTEX_DEPTH_CHECK) || defined(FRAGMENT_DEPTH_CHECK)\n    temp = compressedAttribute3.w;\n    temp = temp * SHIFT_RIGHT12;\n\n    vec2 dimensions;\n    dimensions.y = (temp - floor(temp)) * SHIFT_LEFT12;\n    dimensions.x = floor(temp);\n#endif\n\n#ifdef ALIGNED_AXIS\n    vec3 alignedAxis = czm_octDecode(floor(compressedAttribute1.y * SHIFT_RIGHT8));\n    temp = compressedAttribute2.z * SHIFT_RIGHT5;\n    bool validAlignedAxis = (temp - floor(temp)) * SHIFT_LEFT1 > 0.0;\n#else\n    vec3 alignedAxis = vec3(0.0);\n    bool validAlignedAxis = false;\n#endif\n\n    vec4 pickColor;\n    vec4 color;\n\n    temp = compressedAttribute2.y;\n    temp = temp * SHIFT_RIGHT8;\n    pickColor.b = (temp - floor(temp)) * SHIFT_LEFT8;\n    temp = floor(temp) * SHIFT_RIGHT8;\n    pickColor.g = (temp - floor(temp)) * SHIFT_LEFT8;\n    pickColor.r = floor(temp);\n\n    temp = compressedAttribute2.x;\n    temp = temp * SHIFT_RIGHT8;\n    color.b = (temp - floor(temp)) * SHIFT_LEFT8;\n    temp = floor(temp) * SHIFT_RIGHT8;\n    color.g = (temp - floor(temp)) * SHIFT_LEFT8;\n    color.r = floor(temp);\n\n    temp = compressedAttribute2.z * SHIFT_RIGHT8;\n    bool sizeInMeters = floor((temp - floor(temp)) * SHIFT_LEFT7) > 0.0;\n    temp = floor(temp) * SHIFT_RIGHT8;\n\n    pickColor.a = (temp - floor(temp)) * SHIFT_LEFT8;\n    pickColor /= 255.0;\n\n    color.a = floor(temp);\n    color /= 255.0;\n\n    ///////////////////////////////////////////////////////////////////////////\n\n    vec4 p = czm_translateRelativeToEye(positionHigh, positionLow);\n    vec4 positionEC = czm_modelViewRelativeToEye * p;\n\n#if defined(FRAGMENT_DEPTH_CHECK) || defined(VERTEX_DEPTH_CHECK)\n    float eyeDepth = positionEC.z;\n#endif\n\n    positionEC = czm_eyeOffset(positionEC, eyeOffset.xyz);\n    positionEC.xyz *= show;\n\n    ///////////////////////////////////////////////////////////////////////////\n\n#if defined(EYE_DISTANCE_SCALING) || defined(EYE_DISTANCE_TRANSLUCENCY) || defined(EYE_DISTANCE_PIXEL_OFFSET) || defined(DISTANCE_DISPLAY_CONDITION) || defined(DISABLE_DEPTH_DISTANCE)\n    float lengthSq;\n    if (czm_sceneMode == czm_sceneMode2D)\n    {\n        // 2D camera distance is a special case\n        // treat all billboards as flattened to the z=0.0 plane\n        lengthSq = czm_eyeHeight2D.y;\n    }\n    else\n    {\n        lengthSq = dot(positionEC.xyz, positionEC.xyz);\n    }\n#endif\n\n#ifdef EYE_DISTANCE_SCALING\n    float distanceScale = czm_nearFarScalar(scaleByDistance, lengthSq);\n    scale *= distanceScale;\n    translate *= distanceScale;\n    // push vertex behind near plane for clipping\n    if (scale == 0.0)\n    {\n        positionEC.xyz = vec3(0.0);\n    }\n#endif\n\n    float translucency = 1.0;\n#ifdef EYE_DISTANCE_TRANSLUCENCY\n    translucency = czm_nearFarScalar(translucencyByDistance, lengthSq);\n    // push vertex behind near plane for clipping\n    if (translucency == 0.0)\n    {\n        positionEC.xyz = vec3(0.0);\n    }\n#endif\n\n#ifdef EYE_DISTANCE_PIXEL_OFFSET\n    float pixelOffsetScale = czm_nearFarScalar(pixelOffsetScaleByDistance, lengthSq);\n    pixelOffset *= pixelOffsetScale;\n#endif\n\n#ifdef DISTANCE_DISPLAY_CONDITION\n    float nearSq = compressedAttribute3.x;\n    float farSq = compressedAttribute3.y;\n    if (lengthSq < nearSq || lengthSq > farSq)\n    {\n        positionEC.xyz = vec3(0.0);\n    }\n#endif\n\n    mat2 rotationMatrix;\n    float mpp;\n\n#ifdef DISABLE_DEPTH_DISTANCE\n    float disableDepthTestDistance = compressedAttribute3.z;\n#endif\n\n#ifdef VERTEX_DEPTH_CHECK\nif (lengthSq < disableDepthTestDistance) {\n    float depthsilon = 10.0;\n\n    vec2 labelTranslate = textureCoordinateBoundsOrLabelTranslate.xy;\n    vec4 pEC1 = addScreenSpaceOffset(positionEC, dimensions, scale, vec2(0.0), origin, labelTranslate, pixelOffset, alignedAxis, validAlignedAxis, rotation, sizeInMeters, rotationMatrix, mpp);\n    float globeDepth1 = getGlobeDepth(pEC1);\n\n    if (globeDepth1 != 0.0 && pEC1.z + depthsilon < globeDepth1)\n    {\n        vec4 pEC2 = addScreenSpaceOffset(positionEC, dimensions, scale, vec2(0.0, 1.0), origin, labelTranslate, pixelOffset, alignedAxis, validAlignedAxis, rotation, sizeInMeters, rotationMatrix, mpp);\n        float globeDepth2 = getGlobeDepth(pEC2);\n\n        if (globeDepth2 != 0.0 && pEC2.z + depthsilon < globeDepth2)\n        {\n            vec4 pEC3 = addScreenSpaceOffset(positionEC, dimensions, scale, vec2(1.0), origin, labelTranslate, pixelOffset, alignedAxis, validAlignedAxis, rotation, sizeInMeters, rotationMatrix, mpp);\n            float globeDepth3 = getGlobeDepth(pEC3);\n            if (globeDepth3 != 0.0 && pEC3.z + depthsilon < globeDepth3)\n            {\n                positionEC.xyz = vec3(0.0);\n            }\n        }\n    }\n}\n#endif\n\n    positionEC = addScreenSpaceOffset(positionEC, imageSize, scale, direction, origin, translate, pixelOffset, alignedAxis, validAlignedAxis, rotation, sizeInMeters, rotationMatrix, mpp);\n    gl_Position = czm_projection * positionEC;\n    v_textureCoordinates = textureCoordinates;\n\n#ifdef LOG_DEPTH\n    czm_vertexLogDepth();\n#endif\n\n#ifdef DISABLE_DEPTH_DISTANCE\n    if (disableDepthTestDistance == 0.0 && czm_minimumDisableDepthTestDistance != 0.0)\n    {\n        disableDepthTestDistance = czm_minimumDisableDepthTestDistance;\n    }\n\n    if (disableDepthTestDistance != 0.0)\n    {\n        // Don't try to \"multiply both sides\" by w.  Greater/less-than comparisons won't work for negative values of w.\n        float zclip = gl_Position.z / gl_Position.w;\n        bool clipped = (zclip < -1.0 || zclip > 1.0);\n        if (!clipped && (disableDepthTestDistance < 0.0 || (lengthSq > 0.0 && lengthSq < disableDepthTestDistance)))\n        {\n            // Position z on the near plane.\n            gl_Position.z = -gl_Position.w;\n#ifdef LOG_DEPTH\n            v_depthFromNearPlusOne = 1.0;\n#endif\n        }\n    }\n#endif\n\n#ifdef FRAGMENT_DEPTH_CHECK\n    if (sizeInMeters) {\n        translate /= mpp;\n        dimensions /= mpp;\n        imageSize /= mpp;\n    }\n\n#if defined(ROTATION) || defined(ALIGNED_AXIS)\n    v_rotationMatrix = rotationMatrix;\n#else\n    v_rotationMatrix = mat2(1.0, 0.0, 0.0, 1.0);\n#endif\n\n    float enableDepthCheck = 0.0;\n    if (lengthSq < disableDepthTestDistance)\n    {\n        enableDepthCheck = 1.0;\n    }\n\n    float dw = floor(clamp(dimensions.x, 0.0, SHIFT_LEFT12));\n    float dh = floor(clamp(dimensions.y, 0.0, SHIFT_LEFT12));\n\n    float iw = floor(clamp(imageSize.x, 0.0, SHIFT_LEFT12));\n    float ih = floor(clamp(imageSize.y, 0.0, SHIFT_LEFT12));\n\n    v_compressed.x = eyeDepth;\n    v_compressed.y = applyTranslate * SHIFT_LEFT1 + enableDepthCheck;\n    v_compressed.z = dw * SHIFT_LEFT12 + dh;\n    v_compressed.w = iw * SHIFT_LEFT12 + ih;\n    v_originTextureCoordinateAndTranslate.xy = depthOrigin;\n    v_originTextureCoordinateAndTranslate.zw = translate;\n    v_textureCoordinateBounds = textureCoordinateBoundsOrLabelTranslate;\n\n#endif\n\n#ifdef SDF\n    vec4 outlineColor;\n    float outlineWidth;\n\n    temp = sdf.x;\n    temp = temp * SHIFT_RIGHT8;\n    outlineColor.b = (temp - floor(temp)) * SHIFT_LEFT8;\n    temp = floor(temp) * SHIFT_RIGHT8;\n    outlineColor.g = (temp - floor(temp)) * SHIFT_LEFT8;\n    outlineColor.r = floor(temp);\n\n    temp = sdf.y;\n    temp = temp * SHIFT_RIGHT8;\n    float temp3 = (temp - floor(temp)) * SHIFT_LEFT8;\n    temp = floor(temp) * SHIFT_RIGHT8;\n    outlineWidth = (temp - floor(temp)) * SHIFT_LEFT8;\n    outlineColor.a = floor(temp);\n    outlineColor /= 255.0;\n\n    v_outlineWidth = outlineWidth / 255.0;\n    v_outlineColor = outlineColor;\n    v_outlineColor.a *= translucency;\n#endif\n\n    v_pickColor = pickColor;\n\n    v_color = color;\n    v_color.a *= translucency;\n    v_splitDirection = splitDirection;\n}\n"},433175:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * A built-in GLSL floating-point constant for converting radians to degrees.\n *\n * @alias czm_degreesPerRadian\n * @glslConstant\n *\n * @see CesiumMath.DEGREES_PER_RADIAN\n *\n * @example\n * // GLSL declaration\n * const float czm_degreesPerRadian = ...;\n *\n * // Example\n * float deg = czm_degreesPerRadian * rad;\n */\nconst float czm_degreesPerRadian = 57.29577951308232;\n"},779548:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * A built-in GLSL vec2 constant for defining the depth range.\n * This is a workaround to a bug where IE11 does not implement gl_DepthRange.\n *\n * @alias czm_depthRange\n * @glslConstant\n *\n * @example\n * // GLSL declaration\n * float depthRangeNear = czm_depthRange.near;\n * float depthRangeFar = czm_depthRange.far;\n *\n */\nconst czm_depthRangeStruct czm_depthRange = czm_depthRangeStruct(0.0, 1.0);\n"},945363:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * 0.1\n *\n * @name czm_epsilon1\n * @glslConstant\n */\nconst float czm_epsilon1 = 0.1;\n"},575190:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * 0.01\n *\n * @name czm_epsilon2\n * @glslConstant\n */\nconst float czm_epsilon2 = 0.01;\n"},703381:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * 0.001\n *\n * @name czm_epsilon3\n * @glslConstant\n */\nconst float czm_epsilon3 = 0.001;\n"},960352:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * 0.0001\n *\n * @name czm_epsilon4\n * @glslConstant\n */\nconst float czm_epsilon4 = 0.0001;\n"},550071:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * 0.00001\n *\n * @name czm_epsilon5\n * @glslConstant\n */\nconst float czm_epsilon5 = 0.00001;\n"},291146:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * 0.000001\n *\n * @name czm_epsilon6\n * @glslConstant\n */\nconst float czm_epsilon6 = 0.000001;\n"},680633:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * 0.0000001\n *\n * @name czm_epsilon7\n * @glslConstant\n */\nconst float czm_epsilon7 = 0.0000001;\n"},751418:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * DOC_TBA\n *\n * @name czm_infinity\n * @glslConstant\n */\nconst float czm_infinity = 5906376272000.0;  // Distance from the Sun to Pluto in meters.  TODO: What is best given lowp, mediump, and highp?\n"},616053:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * A built-in GLSL floating-point constant for <code>1/pi</code>.\n *\n * @alias czm_oneOverPi\n * @glslConstant\n *\n * @see CesiumMath.ONE_OVER_PI\n *\n * @example\n * // GLSL declaration\n * const float czm_oneOverPi = ...;\n *\n * // Example\n * float pi = 1.0 / czm_oneOverPi;\n */\nconst float czm_oneOverPi = 0.3183098861837907;\n"},509473:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * A built-in GLSL floating-point constant for <code>1/2pi</code>.\n *\n * @alias czm_oneOverTwoPi\n * @glslConstant\n *\n * @see CesiumMath.ONE_OVER_TWO_PI\n *\n * @example\n * // GLSL declaration\n * const float czm_oneOverTwoPi = ...;\n *\n * // Example\n * float pi = 2.0 * czm_oneOverTwoPi;\n */\nconst float czm_oneOverTwoPi = 0.15915494309189535;\n"},54754:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * The automatic GLSL constant for {@link Pass#CESIUM_3D_TILE}\n *\n * @name czm_passCesium3DTile\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passCesium3DTile = 4.0;\n"},484374:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * The automatic GLSL constant for {@link Pass#CESIUM_3D_TILE_CLASSIFICATION}\n *\n * @name czm_passCesium3DTileClassification\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passCesium3DTileClassification = 5.0;\n"},673089:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * The automatic GLSL constant for {@link Pass#CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW}\n *\n * @name czm_passCesium3DTileClassificationIgnoreShow\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passCesium3DTileClassificationIgnoreShow = 6.0;\n"},178303:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * The automatic GLSL constant for {@link Pass#CLASSIFICATION}\n *\n * @name czm_passClassification\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passClassification = 7.0;\n"},658594:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * The automatic GLSL constant for {@link Pass#COMPUTE}\n *\n * @name czm_passCompute\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passCompute = 1.0;\n"},228970:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * The automatic GLSL constant for {@link Pass#ENVIRONMENT}\n *\n * @name czm_passEnvironment\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passEnvironment = 0.0;\n"},135869:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * The automatic GLSL constant for {@link Pass#GAUSSIAN_SPLATS}\n *\n * @name czm_passGaussianSplats\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passGaussianSplats = 10.0;\n"},517382:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * The automatic GLSL constant for {@link Pass#GLOBE}\n *\n * @name czm_passGlobe\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passGlobe = 2.0;\n"},538496:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * The automatic GLSL constant for {@link Pass#OPAQUE}\n *\n * @name czm_passOpaque\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passOpaque = 7.0;\n"},747543:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * The automatic GLSL constant for {@link Pass#OVERLAY}\n *\n * @name czm_passOverlay\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passOverlay = 11.0;\n"},317374:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * The automatic GLSL constant for {@link Pass#TERRAIN_CLASSIFICATION}\n *\n * @name czm_passTerrainClassification\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passTerrainClassification = 3.0;\n"},884252:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * The automatic GLSL constant for {@link Pass#TRANSLUCENT}\n *\n * @name czm_passTranslucent\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passTranslucent = 8.0;\n"},485806:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * The automatic GLSL constant for {@link Pass#VOXELS}\n *\n * @name czm_passVoxels\n * @glslConstant\n *\n * @see czm_pass\n */\nconst float czm_passVoxels = 9.0;\n"},903149:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * A built-in GLSL floating-point constant for <code>Math.PI</code>.\n *\n * @alias czm_pi\n * @glslConstant\n *\n * @see CesiumMath.PI\n *\n * @example\n * // GLSL declaration\n * const float czm_pi = ...;\n *\n * // Example\n * float twoPi = 2.0 * czm_pi;\n */\nconst float czm_pi = 3.141592653589793;\n"},601995:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * A built-in GLSL floating-point constant for <code>pi/4</code>.\n *\n * @alias czm_piOverFour\n * @glslConstant\n *\n * @see CesiumMath.PI_OVER_FOUR\n *\n * @example\n * // GLSL declaration\n * const float czm_piOverFour = ...;\n *\n * // Example\n * float pi = 4.0 * czm_piOverFour;\n */\nconst float czm_piOverFour = 0.7853981633974483;\n"},552111:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * A built-in GLSL floating-point constant for <code>pi/6</code>.\n *\n * @alias czm_piOverSix\n * @glslConstant\n *\n * @see CesiumMath.PI_OVER_SIX\n *\n * @example\n * // GLSL declaration\n * const float czm_piOverSix = ...;\n *\n * // Example\n * float pi = 6.0 * czm_piOverSix;\n */\nconst float czm_piOverSix = 0.5235987755982988;\n"},154487:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * A built-in GLSL floating-point constant for <code>pi/3</code>.\n *\n * @alias czm_piOverThree\n * @glslConstant\n *\n * @see CesiumMath.PI_OVER_THREE\n *\n * @example\n * // GLSL declaration\n * const float czm_piOverThree = ...;\n *\n * // Example\n * float pi = 3.0 * czm_piOverThree;\n */\nconst float czm_piOverThree = 1.0471975511965976;\n"},856253:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * A built-in GLSL floating-point constant for <code>pi/2</code>.\n *\n * @alias czm_piOverTwo\n * @glslConstant\n *\n * @see CesiumMath.PI_OVER_TWO\n *\n * @example\n * // GLSL declaration\n * const float czm_piOverTwo = ...;\n *\n * // Example\n * float pi = 2.0 * czm_piOverTwo;\n */\nconst float czm_piOverTwo = 1.5707963267948966;\n"},685879:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * A built-in GLSL floating-point constant for converting degrees to radians.\n *\n * @alias czm_radiansPerDegree\n * @glslConstant\n *\n * @see CesiumMath.RADIANS_PER_DEGREE\n *\n * @example\n * // GLSL declaration\n * const float czm_radiansPerDegree = ...;\n *\n * // Example\n * float rad = czm_radiansPerDegree * deg;\n */\nconst float czm_radiansPerDegree = 0.017453292519943295;\n"},570941:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * The constant identifier for the 2D {@link SceneMode}\n *\n * @name czm_sceneMode2D\n * @glslConstant\n * @see czm_sceneMode\n * @see czm_sceneModeColumbusView\n * @see czm_sceneMode3D\n * @see czm_sceneModeMorphing\n */\nconst float czm_sceneMode2D = 2.0;\n"},819888:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * The constant identifier for the 3D {@link SceneMode}\n *\n * @name czm_sceneMode3D\n * @glslConstant\n * @see czm_sceneMode\n * @see czm_sceneMode2D\n * @see czm_sceneModeColumbusView\n * @see czm_sceneModeMorphing\n */\nconst float czm_sceneMode3D = 3.0;\n"},656328:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * The constant identifier for the Columbus View {@link SceneMode}\n *\n * @name czm_sceneModeColumbusView\n * @glslConstant\n * @see czm_sceneMode\n * @see czm_sceneMode2D\n * @see czm_sceneMode3D\n * @see czm_sceneModeMorphing\n */\nconst float czm_sceneModeColumbusView = 1.0;\n"},915065:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * The constant identifier for the Morphing {@link SceneMode}\n *\n * @name czm_sceneModeMorphing\n * @glslConstant\n * @see czm_sceneMode\n * @see czm_sceneMode2D\n * @see czm_sceneModeColumbusView\n * @see czm_sceneMode3D\n */\nconst float czm_sceneModeMorphing = 0.0;\n"},564363:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * A built-in GLSL floating-point constant for one solar radius.\n *\n * @alias czm_solarRadius\n * @glslConstant\n *\n * @see CesiumMath.SOLAR_RADIUS\n *\n * @example\n * // GLSL declaration\n * const float czm_solarRadius = ...;\n */\nconst float czm_solarRadius = 695500000.0;\n"},300255:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * A built-in GLSL floating-point constant for <code>3pi/2</code>.\n *\n * @alias czm_threePiOver2\n * @glslConstant\n *\n * @see CesiumMath.THREE_PI_OVER_TWO\n *\n * @example\n * // GLSL declaration\n * const float czm_threePiOver2 = ...;\n *\n * // Example\n * float pi = (2.0 / 3.0) * czm_threePiOver2;\n */\nconst float czm_threePiOver2 = 4.71238898038469;\n"},658169:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * A built-in GLSL floating-point constant for <code>2pi</code>.\n *\n * @alias czm_twoPi\n * @glslConstant\n *\n * @see CesiumMath.TWO_PI\n *\n * @example\n * // GLSL declaration\n * const float czm_twoPi = ...;\n *\n * // Example\n * float pi = czm_twoPi / 2.0;\n */\nconst float czm_twoPi = 6.283185307179586;\n"},820965:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * The maximum latitude, in radians, both North and South, supported by a Web Mercator\n * (EPSG:3857) projection.  Technically, the Mercator projection is defined\n * for any latitude up to (but not including) 90 degrees, but it makes sense\n * to cut it off sooner because it grows exponentially with increasing latitude.\n * The logic behind this particular cutoff value, which is the one used by\n * Google Maps, Bing Maps, and Esri, is that it makes the projection\n * square.  That is, the rectangle is equal in the X and Y directions.\n *\n * The constant value is computed as follows:\n *   czm_pi * 0.5 - (2.0 * atan(exp(-czm_pi)))\n *\n * @name czm_webMercatorMaxLatitude\n * @glslConstant\n */\nconst float czm_webMercatorMaxLatitude = 1.4844222297453324;\n"},2218:(e,t,n)=>{"use strict";n.d(t,{A:()=>Pt});var i=n(433175),o=n(779548),r=n(945363),a=n(575190),s=n(703381),c=n(960352),l=n(550071),h=n(291146),u=n(680633),d=n(751418),p=n(616053),m=n(509473),f=n(54754),A=n(484374),_=n(673089),g=n(178303),y=n(658594),v=n(228970),b=n(135869),w=n(517382),T=n(538496),x=n(747543),C=n(317374),E=n(884252),S=n(485806),D=n(903149),O=n(601995),z=n(552111),I=n(154487),P=n(856253),R=n(685879),N=n(570941),L=n(819888),M=n(656328),F=n(915065),B=n(564363),k=n(300255),V=n(658169),G=n(820965),H=n(30284),U=n(851714),W=n(423340),q=n(416407),j=n(171037),Y=n(41715),X=n(229806),$=n(731759),Z=n(106245),K=n(638211),Q=n(702673),J=n(461091),ee=n(187411),te=n(812499),ne=n(498386),ie=n(264968),oe=n(668784),re=n(990227),ae=n(922956),se=n(981767),ce=n(413799),le=n(919085),he=n(892987),ue=n(498969),de=n(505559),pe=n(436749),me=n(641179),fe=n(68787),Ae=n(803270),_e=n(225424),ge=n(441786),ye=n(865459),ve=n(269453),be=n(817515),we=n(240790),Te=n(12624),xe=n(13500),Ce=n(943703),Ee=n(915493),Se=n(493458),De=n(820789),Oe=n(565274),ze=n(247408),Ie=n(177627),Pe=n(624782),Re=n(195814),Ne=n(9102),Le=n(534173),Me=n(348941),Fe=n(431443),Be=n(448358),ke=n(633899),Ve=n(393597),Ge=n(293367),He=n(31862),Ue=n(610675),We=n(160958),qe=n(21038),je=n(363063),Ye=n(973717),Xe=n(254805),$e=n(548051),Ze=n(191195),Ke=n(738340),Qe=n(674794),Je=n(584312),et=n(428395),tt=n(696042),nt=n(820121),it=n(147769),ot=n(394839),rt=n(932901),at=n(527105),st=n(916117),ct=n(755541),lt=n(463540),ht=n(199494),ut=n(82914),dt=n(568758),pt=n(562348),mt=n(19687),ft=n(501738),At=n(660164),_t=n(480262),gt=n(608860),yt=n(980902),vt=n(367309),bt=n(880691),wt=n(648777),Tt=n(231511),xt=n(293752),Ct=n(617172),Et=n(169513),St=n(720547),Dt=n(584783),Ot=n(10451),zt=n(237688),It=n(322556);const Pt={czm_degreesPerRadian:i.A,czm_depthRange:o.A,czm_epsilon1:r.A,czm_epsilon2:a.A,czm_epsilon3:s.A,czm_epsilon4:c.A,czm_epsilon5:l.A,czm_epsilon6:h.A,czm_epsilon7:u.A,czm_infinity:d.A,czm_oneOverPi:p.A,czm_oneOverTwoPi:m.A,czm_passCesium3DTile:f.A,czm_passCesium3DTileClassification:A.A,czm_passCesium3DTileClassificationIgnoreShow:_.A,czm_passClassification:g.A,czm_passCompute:y.A,czm_passEnvironment:v.A,czm_passGaussianSplats:b.A,czm_passGlobe:w.A,czm_passOpaque:T.A,czm_passOverlay:x.A,czm_passTerrainClassification:C.A,czm_passTranslucent:E.A,czm_passVoxels:S.A,czm_pi:D.A,czm_piOverFour:O.A,czm_piOverSix:z.A,czm_piOverThree:I.A,czm_piOverTwo:P.A,czm_radiansPerDegree:R.A,czm_sceneMode2D:N.A,czm_sceneMode3D:L.A,czm_sceneModeColumbusView:M.A,czm_sceneModeMorphing:F.A,czm_solarRadius:B.A,czm_threePiOver2:k.A,czm_twoPi:V.A,czm_webMercatorMaxLatitude:G.A,czm_depthRangeStruct:H.A,czm_material:U.A,czm_materialInput:W.A,czm_modelMaterial:q.A,czm_modelVertexOutput:j.A,czm_ray:Y.A,czm_raySegment:X.A,czm_shadowParameters:$.A,czm_HSBToRGB:Z.A,czm_HSLToRGB:K.A,czm_RGBToHSB:Q.A,czm_RGBToHSL:J.A,czm_RGBToXYZ:ee.A,czm_XYZToRGB:te.A,czm_acesTonemapping:ne.A,czm_alphaWeight:ie.A,czm_antialias:oe.A,czm_applyHSBShift:re.A,czm_approximateSphericalCoordinates:ae.A,czm_approximateTanh:se.A,czm_backFacing:ce.A,czm_branchFreeTernary:le.A,czm_cascadeColor:he.A,czm_cascadeDistance:ue.A,czm_cascadeMatrix:de.A,czm_cascadeWeights:pe.A,czm_clipPolygons:me.A,czm_columbusViewMorph:fe.A,czm_computeAtmosphereColor:Ae.A,czm_computeGroundAtmosphereScattering:_e.A,czm_computePosition:ge.A,czm_computeScattering:ye.A,czm_cosineAndSine:ve.A,czm_decompressTextureCoordinates:be.A,czm_depthClamp:we.A,czm_eastNorthUpToEyeCoordinates:Te.A,czm_ellipsoidContainsPoint:xe.A,czm_ellipsoidTextureCoordinates:Ce.A,czm_equalsEpsilon:Ee.A,czm_eyeOffset:Se.A,czm_eyeToWindowCoordinates:De.A,czm_fastApproximateAtan:Oe.A,czm_fog:ze.A,czm_gammaCorrect:Ie.A,czm_geodeticSurfaceNormal:Pe.A,czm_getDefaultMaterial:Re.A,czm_getDynamicAtmosphereLightDirection:Ne.A,czm_getLambertDiffuse:Le.A,czm_getSpecular:Me.A,czm_getWaterNoise:Fe.A,czm_hue:Be.A,czm_inverseGamma:ke.A,czm_isEmpty:Ve.A,czm_isFull:Ge.A,czm_latitudeToWebMercatorFraction:He.A,czm_lineDistance:Ue.A,czm_linearToSrgb:We.A,czm_luminance:qe.A,czm_maximumComponent:je.A,czm_metersPerPixel:Ye.A,czm_modelToWindowCoordinates:Xe.A,czm_multiplyWithColorBalance:$e.A,czm_nearFarScalar:Ze.A,czm_octDecode:Ke.A,czm_packDepth:Qe.A,czm_pbrLighting:Je.A,czm_pbrNeutralTonemapping:et.A,czm_phong:tt.A,czm_planeDistance:nt.A,czm_pointAlongRay:it.A,czm_rayEllipsoidIntersectionInterval:ot.A,czm_raySphereIntersectionInterval:rt.A,czm_readDepth:at.A,czm_readNonPerspective:st.A,czm_reverseLogDepth:ct.A,czm_round:lt.A,czm_saturation:ht.A,czm_shadowDepthCompare:ut.A,czm_shadowVisibility:dt.A,czm_signNotZero:pt.A,czm_sphericalHarmonics:mt.A,czm_srgbToLinear:ft.A,czm_tangentToEyeSpaceMatrix:At.A,czm_textureCube:_t.A,czm_transformPlane:gt.A,czm_translateRelativeToEye:yt.A,czm_translucentPhong:vt.A,czm_transpose:bt.A,czm_unpackClippingExtents:wt.A,czm_unpackDepth:Tt.A,czm_unpackFloat:xt.A,czm_unpackUint:Ct.A,czm_valueTransform:Et.A,czm_vertexLogDepth:St.A,czm_windowToEyeCoordinates:Dt.A,czm_writeDepthClamp:Ot.A,czm_writeLogDepth:zt.A,czm_writeNonPerspective:It.A}},106245:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Converts an HSB color (hue, saturation, brightness) to RGB\n * HSB <-> RGB conversion with minimal branching: {@link http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl}\n *\n * @name czm_HSBToRGB\n * @glslFunction\n * \n * @param {vec3} hsb The color in HSB.\n *\n * @returns {vec3} The color in RGB.\n *\n * @example\n * vec3 hsb = czm_RGBToHSB(rgb);\n * hsb.z *= 0.1;\n * rgb = czm_HSBToRGB(hsb);\n */\n\nconst vec4 K_HSB2RGB = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\nvec3 czm_HSBToRGB(vec3 hsb)\n{\n    vec3 p = abs(fract(hsb.xxx + K_HSB2RGB.xyz) * 6.0 - K_HSB2RGB.www);\n    return hsb.z * mix(K_HSB2RGB.xxx, clamp(p - K_HSB2RGB.xxx, 0.0, 1.0), hsb.y);\n}\n"},638211:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Converts an HSL color (hue, saturation, lightness) to RGB\n * HSL <-> RGB conversion: {@link http://www.chilliant.com/rgb2hsv.html}\n *\n * @name czm_HSLToRGB\n * @glslFunction\n * \n * @param {vec3} rgb The color in HSL.\n *\n * @returns {vec3} The color in RGB.\n *\n * @example\n * vec3 hsl = czm_RGBToHSL(rgb);\n * hsl.z *= 0.1;\n * rgb = czm_HSLToRGB(hsl);\n */\n\nvec3 hueToRGB(float hue)\n{\n    float r = abs(hue * 6.0 - 3.0) - 1.0;\n    float g = 2.0 - abs(hue * 6.0 - 2.0);\n    float b = 2.0 - abs(hue * 6.0 - 4.0);\n    return clamp(vec3(r, g, b), 0.0, 1.0);\n}\n\nvec3 czm_HSLToRGB(vec3 hsl)\n{\n    vec3 rgb = hueToRGB(hsl.x);\n    float c = (1.0 - abs(2.0 * hsl.z - 1.0)) * hsl.y;\n    return (rgb - 0.5) * c + hsl.z;\n}\n"},702673:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Converts an RGB color to HSB (hue, saturation, brightness)\n * HSB <-> RGB conversion with minimal branching: {@link http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl}\n *\n * @name czm_RGBToHSB\n * @glslFunction\n * \n * @param {vec3} rgb The color in RGB.\n *\n * @returns {vec3} The color in HSB.\n *\n * @example\n * vec3 hsb = czm_RGBToHSB(rgb);\n * hsb.z *= 0.1;\n * rgb = czm_HSBToRGB(hsb);\n */\n\nconst vec4 K_RGB2HSB = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n\nvec3 czm_RGBToHSB(vec3 rgb)\n{\n    vec4 p = mix(vec4(rgb.bg, K_RGB2HSB.wz), vec4(rgb.gb, K_RGB2HSB.xy), step(rgb.b, rgb.g));\n    vec4 q = mix(vec4(p.xyw, rgb.r), vec4(rgb.r, p.yzx), step(p.x, rgb.r));\n\n    float d = q.x - min(q.w, q.y);\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + czm_epsilon7)), d / (q.x + czm_epsilon7), q.x);\n}\n"},461091:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Converts an RGB color to HSL (hue, saturation, lightness)\n * HSL <-> RGB conversion: {@link http://www.chilliant.com/rgb2hsv.html}\n *\n * @name czm_RGBToHSL\n * @glslFunction\n * \n * @param {vec3} rgb The color in RGB.\n *\n * @returns {vec3} The color in HSL.\n *\n * @example\n * vec3 hsl = czm_RGBToHSL(rgb);\n * hsl.z *= 0.1;\n * rgb = czm_HSLToRGB(hsl);\n */\n \nvec3 RGBtoHCV(vec3 rgb)\n{\n    // Based on work by Sam Hocevar and Emil Persson\n    vec4 p = (rgb.g < rgb.b) ? vec4(rgb.bg, -1.0, 2.0 / 3.0) : vec4(rgb.gb, 0.0, -1.0 / 3.0);\n    vec4 q = (rgb.r < p.x) ? vec4(p.xyw, rgb.r) : vec4(rgb.r, p.yzx);\n    float c = q.x - min(q.w, q.y);\n    float h = abs((q.w - q.y) / (6.0 * c + czm_epsilon7) + q.z);\n    return vec3(h, c, q.x);\n}\n\nvec3 czm_RGBToHSL(vec3 rgb)\n{\n    vec3 hcv = RGBtoHCV(rgb);\n    float l = hcv.z - hcv.y * 0.5;\n    float s = hcv.y / (1.0 - abs(l * 2.0 - 1.0) + czm_epsilon7);\n    return vec3(hcv.x, s, l);\n}\n"},187411:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Converts an RGB color to CIE Yxy.\n * <p>The conversion is described in\n * {@link http://content.gpwiki.org/index.php/D3DBook:High-Dynamic_Range_Rendering#Luminance_Transform|Luminance Transform}\n * </p>\n * \n * @name czm_RGBToXYZ\n * @glslFunction\n * \n * @param {vec3} rgb The color in RGB.\n *\n * @returns {vec3} The color in CIE Yxy.\n *\n * @example\n * vec3 xyz = czm_RGBToXYZ(rgb);\n * xyz.x = max(xyz.x - luminanceThreshold, 0.0);\n * rgb = czm_XYZToRGB(xyz);\n */\nvec3 czm_RGBToXYZ(vec3 rgb)\n{\n    const mat3 RGB2XYZ = mat3(0.4124, 0.2126, 0.0193,\n                              0.3576, 0.7152, 0.1192,\n                              0.1805, 0.0722, 0.9505);\n    vec3 xyz = RGB2XYZ * rgb;\n    vec3 Yxy;\n    Yxy.r = xyz.g;\n    float temp = dot(vec3(1.0), xyz);\n    Yxy.gb = xyz.rg / temp;\n    return Yxy;\n}\n"},812499:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Converts a CIE Yxy color to RGB.\n * <p>The conversion is described in\n * {@link http://content.gpwiki.org/index.php/D3DBook:High-Dynamic_Range_Rendering#Luminance_Transform|Luminance Transform}\n * </p>\n * \n * @name czm_XYZToRGB\n * @glslFunction\n * \n * @param {vec3} Yxy The color in CIE Yxy.\n *\n * @returns {vec3} The color in RGB.\n *\n * @example\n * vec3 xyz = czm_RGBToXYZ(rgb);\n * xyz.x = max(xyz.x - luminanceThreshold, 0.0);\n * rgb = czm_XYZToRGB(xyz);\n */\nvec3 czm_XYZToRGB(vec3 Yxy)\n{\n    const mat3 XYZ2RGB = mat3( 3.2405, -0.9693,  0.0556,\n                              -1.5371,  1.8760, -0.2040,\n                              -0.4985,  0.0416,  1.0572);\n    vec3 xyz;\n    xyz.r = Yxy.r * Yxy.g / Yxy.b;\n    xyz.g = Yxy.r;\n    xyz.b = Yxy.r * (1.0 - Yxy.g - Yxy.b) / Yxy.b;\n    \n    return XYZ2RGB * xyz;\n}\n"},498386:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="// See:\n//    https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n\nvec3 czm_acesTonemapping(vec3 color) {\n    float g = 0.985;\n    float a = 0.065;\n    float b = 0.0001;\n    float c = 0.433;\n    float d = 0.238;\n\n    color = (color * (color + a) - b) / (color * (g * color + c) + d);\n\n    color = clamp(color, 0.0, 1.0);\n\n    return color;\n}\n"},264968:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * @private\n */\nfloat czm_alphaWeight(float a)\n{\n    float z = (gl_FragCoord.z - czm_viewportTransformation[3][2]) / czm_viewportTransformation[2][2];\n\n    // See Weighted Blended Order-Independent Transparency for examples of different weighting functions:\n    // http://jcgt.org/published/0002/02/09/\n    return pow(a + 0.01, 4.0) + max(1e-2, min(3.0 * 1e3, 0.003 / (1e-5 + pow(abs(z) / 200.0, 4.0))));\n}\n"},668784:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Procedural anti-aliasing by blurring two colors that meet at a sharp edge.\n *\n * @name czm_antialias\n * @glslFunction\n *\n * @param {vec4} color1 The color on one side of the edge.\n * @param {vec4} color2 The color on the other side of the edge.\n * @param {vec4} currentcolor The current color, either <code>color1</code> or <code>color2</code>.\n * @param {float} dist The distance to the edge in texture coordinates.\n * @param {float} [fuzzFactor=0.1] Controls the blurriness between the two colors.\n * @returns {vec4} The anti-aliased color.\n *\n * @example\n * // GLSL declarations\n * vec4 czm_antialias(vec4 color1, vec4 color2, vec4 currentColor, float dist, float fuzzFactor);\n * vec4 czm_antialias(vec4 color1, vec4 color2, vec4 currentColor, float dist);\n *\n * // get the color for a material that has a sharp edge at the line y = 0.5 in texture space\n * float dist = abs(textureCoordinates.t - 0.5);\n * vec4 currentColor = mix(bottomColor, topColor, step(0.5, textureCoordinates.t));\n * vec4 color = czm_antialias(bottomColor, topColor, currentColor, dist, 0.1);\n */\nvec4 czm_antialias(vec4 color1, vec4 color2, vec4 currentColor, float dist, float fuzzFactor)\n{\n    float val1 = clamp(dist / fuzzFactor, 0.0, 1.0);\n    float val2 = clamp((dist - 0.5) / fuzzFactor, 0.0, 1.0);\n    val1 = val1 * (1.0 - val2);\n    val1 = val1 * val1 * (3.0 - (2.0 * val1));\n    val1 = pow(val1, 0.5); //makes the transition nicer\n    \n    vec4 midColor = (color1 + color2) * 0.5;\n    return mix(midColor, currentColor, val1);\n}\n\nvec4 czm_antialias(vec4 color1, vec4 color2, vec4 currentColor, float dist)\n{\n    return czm_antialias(color1, color2, currentColor, dist, 0.1);\n}\n"},990227:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Apply a HSB color shift to an RGB color.\n *\n * @param {vec3} rgb The color in RGB space.\n * @param {vec3} hsbShift The amount to shift each component. The xyz components correspond to hue, saturation, and brightness. Shifting the hue by +/- 1.0 corresponds to shifting the hue by a full cycle. Saturation and brightness are clamped between 0 and 1 after the adjustment\n * @param {bool} ignoreBlackPixels If true, black pixels will be unchanged. This is necessary in some shaders such as atmosphere-related effects.\n *\n * @return {vec3} The RGB color after shifting in HSB space and clamping saturation and brightness to a valid range.\n */\nvec3 czm_applyHSBShift(vec3 rgb, vec3 hsbShift, bool ignoreBlackPixels) {\n    // Convert rgb color to hsb\n    vec3 hsb = czm_RGBToHSB(rgb);\n\n    // Perform hsb shift\n    // Hue cycles around so no clamp is needed.\n    hsb.x += hsbShift.x; // hue\n    hsb.y = clamp(hsb.y + hsbShift.y, 0.0, 1.0); // saturation\n\n    // brightness\n    //\n    // Some shaders such as atmosphere-related effects need to leave black\n    // pixels unchanged\n    if (ignoreBlackPixels) {\n        hsb.z = hsb.z > czm_epsilon7 ? hsb.z + hsbShift.z : 0.0;\n    } else {\n        hsb.z = hsb.z + hsbShift.z;\n    }\n    hsb.z = clamp(hsb.z, 0.0, 1.0);\n\n    // Convert shifted hsb back to rgb\n    return czm_HSBToRGB(hsb);\n}\n"},922956:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Approximately computes spherical coordinates given a normal.\n * Uses approximate inverse trigonometry for speed and consistency,\n * since inverse trigonometry can differ from vendor-to-vendor and when compared with the CPU.\n *\n * @name czm_approximateSphericalCoordinates\n * @glslFunction\n *\n * @param {vec3} normal arbitrary-length normal.\n *\n * @returns {vec2} Approximate latitude and longitude spherical coordinates.\n */\nvec2 czm_approximateSphericalCoordinates(vec3 normal) {\n    // Project into plane with vertical for latitude\n    float latitudeApproximation = czm_fastApproximateAtan(sqrt(normal.x * normal.x + normal.y * normal.y), normal.z);\n    float longitudeApproximation = czm_fastApproximateAtan(normal.x, normal.y);\n    return vec2(latitudeApproximation, longitudeApproximation);\n}\n"},981767:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Compute a rational approximation to tanh(x)\n *\n * @param {float} x A real number input\n * @returns {float} An approximation for tanh(x)\n*/\nfloat czm_approximateTanh(float x) {\n    float x2 = x * x;\n    return max(-1.0, min(1.0, x * (27.0 + x2) / (27.0 + 9.0 * x2)));\n}\n"},413799:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Determines if the fragment is back facing\n *\n * @name czm_backFacing\n * @glslFunction \n * \n * @returns {bool} <code>true</code> if the fragment is back facing; otherwise, <code>false</code>.\n */\nbool czm_backFacing()\n{\n    // !gl_FrontFacing doesn't work as expected on Mac/Intel so use the more verbose form instead. See https://github.com/CesiumGS/cesium/pull/8494.\n    return gl_FrontFacing == false;\n}\n"},919085:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Branchless ternary operator to be used when it's inexpensive to explicitly\n * evaluate both possibilities for a float expression.\n *\n * @name czm_branchFreeTernary\n * @glslFunction\n *\n * @param {bool} comparison A comparison statement\n * @param {float} a Value to return if the comparison is true.\n * @param {float} b Value to return if the comparison is false.\n *\n * @returns {float} equivalent of comparison ? a : b\n */\nfloat czm_branchFreeTernary(bool comparison, float a, float b) {\n    float useA = float(comparison);\n    return a * useA + b * (1.0 - useA);\n}\n\n/**\n * Branchless ternary operator to be used when it's inexpensive to explicitly\n * evaluate both possibilities for a vec2 expression.\n *\n * @name czm_branchFreeTernary\n * @glslFunction\n *\n * @param {bool} comparison A comparison statement\n * @param {vec2} a Value to return if the comparison is true.\n * @param {vec2} b Value to return if the comparison is false.\n *\n * @returns {vec2} equivalent of comparison ? a : b\n */\nvec2 czm_branchFreeTernary(bool comparison, vec2 a, vec2 b) {\n    float useA = float(comparison);\n    return a * useA + b * (1.0 - useA);\n}\n\n/**\n * Branchless ternary operator to be used when it's inexpensive to explicitly\n * evaluate both possibilities for a vec3 expression.\n *\n * @name czm_branchFreeTernary\n * @glslFunction\n *\n * @param {bool} comparison A comparison statement\n * @param {vec3} a Value to return if the comparison is true.\n * @param {vec3} b Value to return if the comparison is false.\n *\n * @returns {vec3} equivalent of comparison ? a : b\n */\nvec3 czm_branchFreeTernary(bool comparison, vec3 a, vec3 b) {\n    float useA = float(comparison);\n    return a * useA + b * (1.0 - useA);\n}\n\n/**\n * Branchless ternary operator to be used when it's inexpensive to explicitly\n * evaluate both possibilities for a vec4 expression.\n *\n * @name czm_branchFreeTernary\n * @glslFunction\n *\n * @param {bool} comparison A comparison statement\n * @param {vec3} a Value to return if the comparison is true.\n * @param {vec3} b Value to return if the comparison is false.\n *\n * @returns {vec3} equivalent of comparison ? a : b\n */\nvec4 czm_branchFreeTernary(bool comparison, vec4 a, vec4 b) {\n    float useA = float(comparison);\n    return a * useA + b * (1.0 - useA);\n}\n"},892987:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="\nvec4 czm_cascadeColor(vec4 weights)\n{\n    return vec4(1.0, 0.0, 0.0, 1.0) * weights.x +\n           vec4(0.0, 1.0, 0.0, 1.0) * weights.y +\n           vec4(0.0, 0.0, 1.0, 1.0) * weights.z +\n           vec4(1.0, 0.0, 1.0, 1.0) * weights.w;\n}\n"},498969:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="\nuniform vec4 shadowMap_cascadeDistances;\n\nfloat czm_cascadeDistance(vec4 weights)\n{\n    return dot(shadowMap_cascadeDistances, weights);\n}\n"},505559:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="\nuniform mat4 shadowMap_cascadeMatrices[4];\n\nmat4 czm_cascadeMatrix(vec4 weights)\n{\n    return shadowMap_cascadeMatrices[0] * weights.x +\n           shadowMap_cascadeMatrices[1] * weights.y +\n           shadowMap_cascadeMatrices[2] * weights.z +\n           shadowMap_cascadeMatrices[3] * weights.w;\n}\n"},436749:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="\nuniform vec4 shadowMap_cascadeSplits[2];\n\nvec4 czm_cascadeWeights(float depthEye)\n{\n    // One component is set to 1.0 and all others set to 0.0.\n    vec4 near = step(shadowMap_cascadeSplits[0], vec4(depthEye));\n    vec4 far = step(depthEye, shadowMap_cascadeSplits[1]);\n    return near * far;\n}\n"},641179:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="float getSignedDistance(vec2 uv, highp sampler2D clippingDistance) {\n    float signedDistance = texture(clippingDistance, uv).r;\n    return (signedDistance - 0.5) * 2.0;\n}\n\nvoid czm_clipPolygons(highp sampler2D clippingDistance, int extentsLength, vec2 clippingPosition, int regionIndex) {\n    // Position is completely outside of polygons bounds\n    vec2 rectUv = clippingPosition;\n    if (regionIndex < 0 || rectUv.x <= 0.0 || rectUv.y <= 0.0 || rectUv.x >= 1.0 || rectUv.y >= 1.0) {\n        #ifdef CLIPPING_INVERSE \n            discard;\n        #endif\n        return;\n    }\n\n    vec2 clippingDistanceTextureDimensions = vec2(textureSize(clippingDistance, 0));\n    vec2 sampleOffset = max(1.0 / clippingDistanceTextureDimensions, vec2(0.005));\n    float dimension = float(extentsLength);\n    if (extentsLength > 2) {\n       dimension = ceil(log2(float(extentsLength)));\n    }\n\n    vec2 textureOffset = vec2(mod(float(regionIndex), dimension), floor(float(regionIndex) / dimension)) / dimension;\n    vec2 uv = textureOffset + rectUv / dimension;\n\n    float signedDistance = getSignedDistance(uv, clippingDistance);\n\n    #ifdef CLIPPING_INVERSE\n    if (signedDistance > 0.0)  {\n        discard;\n    }\n    #else\n    if (signedDistance < 0.0)  {\n        discard;\n    }\n    #endif\n}\n"},68787:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * DOC_TBA\n *\n * @name czm_columbusViewMorph\n * @glslFunction\n */\nvec4 czm_columbusViewMorph(vec4 position2D, vec4 position3D, float time)\n{\n    // Just linear for now.\n    vec3 p = mix(position2D.xyz, position3D.xyz, time);\n    return vec4(p, 1.0);\n}\n"},803270:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Compute the atmosphere color, applying Rayleigh and Mie scattering. This\n * builtin uses automatic uniforms so the atmophere settings are synced with the\n * state of the Scene, even in other contexts like Model.\n *\n * @name czm_computeAtmosphereColor\n * @glslFunction\n *\n * @param {vec3} positionWC Position of the fragment in world coords (low precision)\n * @param {vec3} lightDirection Light direction from the sun or other light source.\n * @param {vec3} rayleighColor The Rayleigh scattering color computed by a scattering function\n * @param {vec3} mieColor The Mie scattering color computed by a scattering function\n * @param {float} opacity The opacity computed by a scattering function.\n */\nvec4 czm_computeAtmosphereColor(\n    vec3 positionWC,\n    vec3 lightDirection,\n    vec3 rayleighColor,\n    vec3 mieColor,\n    float opacity\n) {\n    // Setup the primary ray: from the camera position to the vertex position.\n    vec3 cameraToPositionWC = positionWC - czm_viewerPositionWC;\n    vec3 cameraToPositionWCDirection = normalize(cameraToPositionWC);\n\n    float cosAngle = dot(cameraToPositionWCDirection, lightDirection);\n    float cosAngleSq = cosAngle * cosAngle;\n\n    float G = czm_atmosphereMieAnisotropy;\n    float GSq = G * G;\n\n    // The Rayleigh phase function.\n    float rayleighPhase = 3.0 / (50.2654824574) * (1.0 + cosAngleSq);\n    // The Mie phase function.\n    float miePhase = 3.0 / (25.1327412287) * ((1.0 - GSq) * (cosAngleSq + 1.0)) / (pow(1.0 + GSq - 2.0 * cosAngle * G, 1.5) * (2.0 + GSq));\n\n    // The final color is generated by combining the effects of the Rayleigh and Mie scattering.\n    vec3 rayleigh = rayleighPhase * rayleighColor;\n    vec3 mie = miePhase * mieColor;\n\n    vec3 color = (rayleigh + mie) * czm_atmosphereLightIntensity;\n\n    return vec4(color, opacity);\n}\n\n/**\n * Compute the atmosphere color, applying Rayleigh and Mie scattering. This\n * builtin uses automatic uniforms so the atmophere settings are synced with the\n * state of the Scene, even in other contexts like Model.\n *\n * @name czm_computeAtmosphereColor\n * @glslFunction\n *\n * @param {czm_ray} primaryRay Ray from the origin to sky fragment to in world coords (low precision)\n * @param {vec3} lightDirection Light direction from the sun or other light source.\n * @param {vec3} rayleighColor The Rayleigh scattering color computed by a scattering function\n * @param {vec3} mieColor The Mie scattering color computed by a scattering function\n * @param {float} opacity The opacity computed by a scattering function.\n */\nvec4 czm_computeAtmosphereColor(\n    czm_ray primaryRay,\n    vec3 lightDirection,\n    vec3 rayleighColor,\n    vec3 mieColor,\n    float opacity\n) {\n    vec3 direction = normalize(primaryRay.direction);\n\n    float cosAngle = dot(direction, lightDirection);\n    float cosAngleSq = cosAngle * cosAngle;\n\n    float G = czm_atmosphereMieAnisotropy;\n    float GSq = G * G;\n\n    // The Rayleigh phase function.\n    float rayleighPhase = 3.0 / (50.2654824574) * (1.0 + cosAngleSq);\n    // The Mie phase function.\n    float miePhase = 3.0 / (25.1327412287) * ((1.0 - GSq) * (cosAngleSq + 1.0)) / (pow(1.0 + GSq - 2.0 * cosAngle * G, 1.5) * (2.0 + GSq));\n\n    // The final color is generated by combining the effects of the Rayleigh and Mie scattering.\n    vec3 rayleigh = rayleighPhase * rayleighColor;\n    vec3 mie = miePhase * mieColor;\n\n    vec3 color = (rayleigh + mie) * czm_atmosphereLightIntensity;\n\n    return vec4(color, opacity);\n}\n\n"},225424:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Compute atmosphere scattering for the ground atmosphere and fog. This method\n * uses automatic uniforms so it is always synced with the scene settings.\n *\n * @name czm_computeGroundAtmosphereScattering\n * @glslfunction\n *\n * @param {vec3} positionWC The position of the fragment in world coordinates.\n * @param {vec3} lightDirection The direction of the light to calculate the scattering from.\n * @param {vec3} rayleighColor The variable the Rayleigh scattering will be written to.\n * @param {vec3} mieColor The variable the Mie scattering will be written to.\n * @param {float} opacity The variable the transmittance will be written to.\n */\nvoid czm_computeGroundAtmosphereScattering(vec3 positionWC, vec3 lightDirection, out vec3 rayleighColor, out vec3 mieColor, out float opacity) {\n    vec3 cameraToPositionWC = positionWC - czm_viewerPositionWC;\n    vec3 cameraToPositionWCDirection = normalize(cameraToPositionWC);\n    czm_ray primaryRay = czm_ray(czm_viewerPositionWC, cameraToPositionWCDirection);\n\n    float atmosphereInnerRadius = length(positionWC);\n\n    czm_computeScattering(\n        primaryRay,\n        length(cameraToPositionWC),\n        lightDirection,\n        atmosphereInnerRadius,\n        rayleighColor,\n        mieColor,\n        opacity\n    );\n}\n"},441786:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Returns a position in model coordinates relative to eye taking into\n * account the current scene mode: 3D, 2D, or Columbus view.\n * <p>\n * This uses standard position attributes, <code>position3DHigh</code>, \n * <code>position3DLow</code>, <code>position2DHigh</code>, and <code>position2DLow</code>, \n * and should be used when writing a vertex shader for an {@link Appearance}.\n * </p>\n *\n * @name czm_computePosition\n * @glslFunction\n *\n * @returns {vec4} The position relative to eye.\n *\n * @example\n * vec4 p = czm_computePosition();\n * v_positionEC = (czm_modelViewRelativeToEye * p).xyz;\n * gl_Position = czm_modelViewProjectionRelativeToEye * p;\n *\n * @see czm_translateRelativeToEye\n */\nvec4 czm_computePosition();\n"},865459:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * This function computes the colors contributed by Rayliegh and Mie scattering on a given ray, as well as\n * the transmittance value for the ray. This function uses automatic uniforms\n * so the atmosphere settings are always synced with the current scene.\n *\n * @name czm_computeScattering\n * @glslfunction\n *\n * @param {czm_ray} primaryRay The ray from the camera to the position.\n * @param {float} primaryRayLength The length of the primary ray.\n * @param {vec3} lightDirection The direction of the light to calculate the scattering from.\n * @param {vec3} rayleighColor The variable the Rayleigh scattering will be written to.\n * @param {vec3} mieColor The variable the Mie scattering will be written to.\n * @param {float} opacity The variable the transmittance will be written to.\n */\nvoid czm_computeScattering(\n    czm_ray primaryRay,\n    float primaryRayLength,\n    vec3 lightDirection,\n    float atmosphereInnerRadius,\n    out vec3 rayleighColor,\n    out vec3 mieColor,\n    out float opacity\n) {\n    const float ATMOSPHERE_THICKNESS = 111e3; // The thickness of the atmosphere in meters.\n    const int PRIMARY_STEPS_MAX = 16; // Maximum number of times the ray from the camera to the world position (primary ray) is sampled.\n    const int LIGHT_STEPS_MAX = 4; // Maximum number of times the light is sampled from the light source's intersection with the atmosphere to a sample position on the primary ray.\n\n    // Initialize the default scattering amounts to 0.\n    rayleighColor = vec3(0.0);\n    mieColor = vec3(0.0);\n    opacity = 0.0;\n\n    float atmosphereOuterRadius = atmosphereInnerRadius + ATMOSPHERE_THICKNESS;\n\n    vec3 origin = vec3(0.0);\n\n    // Calculate intersection from the camera to the outer ring of the atmosphere.\n    czm_raySegment primaryRayAtmosphereIntersect = czm_raySphereIntersectionInterval(primaryRay, origin, atmosphereOuterRadius);\n\n    // Return empty colors if no intersection with the atmosphere geometry.\n    if (primaryRayAtmosphereIntersect == czm_emptyRaySegment) {\n        return;\n    }\n\n    // To deal with smaller values of PRIMARY_STEPS (e.g. 4)\n    // we implement a split strategy: sky or horizon.\n    // For performance reasons, instead of a if/else branch\n    // a soft choice is implemented through a weight 0.0 <= w_stop_gt_lprl <= 1.0\n    float x = 1e-7 * primaryRayAtmosphereIntersect.stop / length(primaryRayLength);\n    // Value close to 0.0: close to the horizon\n    // Value close to 1.0: above in the sky\n    float w_stop_gt_lprl = 0.5 * (1.0 + czm_approximateTanh(x));\n\n    // The ray should start from the first intersection with the outer atmopshere, or from the camera position, if it is inside the atmosphere.\n    float start_0 = primaryRayAtmosphereIntersect.start;\n    primaryRayAtmosphereIntersect.start = max(primaryRayAtmosphereIntersect.start, 0.0);\n    // The ray should end at the exit from the atmosphere or at the distance to the vertex, whichever is smaller.\n    primaryRayAtmosphereIntersect.stop = min(primaryRayAtmosphereIntersect.stop, length(primaryRayLength));\n\n    // For the number of ray steps, distinguish inside or outside atmosphere (outer space)\n    // (1) from outer space we have to use more ray steps to get a realistic rendering\n    // (2) within atmosphere we need fewer steps for faster rendering\n    float x_o_a = start_0 - ATMOSPHERE_THICKNESS; // ATMOSPHERE_THICKNESS used as an ad-hoc constant, no precise meaning here, only the order of magnitude matters\n    float w_inside_atmosphere = 1.0 - 0.5 * (1.0 + czm_approximateTanh(x_o_a));\n    int PRIMARY_STEPS = PRIMARY_STEPS_MAX - int(w_inside_atmosphere * 12.0); // Number of times the ray from the camera to the world position (primary ray) is sampled.\n    int LIGHT_STEPS = LIGHT_STEPS_MAX - int(w_inside_atmosphere * 2.0); // Number of times the light is sampled from the light source's intersection with the atmosphere to a sample position on the primary ray.\n\n    // Setup for sampling positions along the ray - starting from the intersection with the outer ring of the atmosphere.\n    float rayPositionLength = primaryRayAtmosphereIntersect.start;\n    // (1) Outside the atmosphere: constant rayStepLength\n    // (2) Inside atmosphere: variable rayStepLength to compensate the rough rendering of the smaller number of ray steps\n    float totalRayLength = primaryRayAtmosphereIntersect.stop - rayPositionLength;\n    float rayStepLengthIncrease = w_inside_atmosphere * ((1.0 - w_stop_gt_lprl) * totalRayLength / (float(PRIMARY_STEPS * (PRIMARY_STEPS + 1)) / 2.0));\n    float rayStepLength = max(1.0 - w_inside_atmosphere, w_stop_gt_lprl) * totalRayLength / max(7.0 * w_inside_atmosphere, float(PRIMARY_STEPS));\n\n    vec3 rayleighAccumulation = vec3(0.0);\n    vec3 mieAccumulation = vec3(0.0);\n    vec2 opticalDepth = vec2(0.0);\n    vec2 heightScale = vec2(czm_atmosphereRayleighScaleHeight, czm_atmosphereMieScaleHeight);\n\n    // Sample positions on the primary ray.\n    for (int i = 0; i < PRIMARY_STEPS_MAX; ++i) {\n\n        // The loop should be: for (int i = 0; i < PRIMARY_STEPS; ++i) {...} but WebGL1 cannot\n        // loop with non-constant condition, so it has to break early instead\n        if (i >= PRIMARY_STEPS) {\n            break;\n        }\n\n        // Calculate sample position along viewpoint ray.\n        vec3 samplePosition = primaryRay.origin + primaryRay.direction * (rayPositionLength + rayStepLength);\n\n        // Calculate height of sample position above ellipsoid.\n        float sampleHeight = length(samplePosition) - atmosphereInnerRadius;\n\n        // Calculate and accumulate density of particles at the sample position.\n        vec2 sampleDensity = exp(-sampleHeight / heightScale) * rayStepLength;\n        opticalDepth += sampleDensity;\n\n        // Generate ray from the sample position segment to the light source, up to the outer ring of the atmosphere.\n        czm_ray lightRay = czm_ray(samplePosition, lightDirection);\n        czm_raySegment lightRayAtmosphereIntersect = czm_raySphereIntersectionInterval(lightRay, origin, atmosphereOuterRadius);\n\n        float lightStepLength = lightRayAtmosphereIntersect.stop / float(LIGHT_STEPS);\n        float lightPositionLength = 0.0;\n\n        vec2 lightOpticalDepth = vec2(0.0);\n\n        // Sample positions along the light ray, to accumulate incidence of light on the latest sample segment.\n        for (int j = 0; j < LIGHT_STEPS_MAX; ++j) {\n\n            // The loop should be: for (int j = 0; i < LIGHT_STEPS; ++j) {...} but WebGL1 cannot\n            // loop with non-constant condition, so it has to break early instead\n            if (j >= LIGHT_STEPS) {\n                break;\n            }\n\n            // Calculate sample position along light ray.\n            vec3 lightPosition = samplePosition + lightDirection * (lightPositionLength + lightStepLength * 0.5);\n\n            // Calculate height of the light sample position above ellipsoid.\n            float lightHeight = length(lightPosition) - atmosphereInnerRadius;\n\n            // Calculate density of photons at the light sample position.\n            lightOpticalDepth += exp(-lightHeight / heightScale) * lightStepLength;\n\n            // Increment distance on light ray.\n            lightPositionLength += lightStepLength;\n        }\n\n        // Compute attenuation via the primary ray and the light ray.\n        vec3 attenuation = exp(-((czm_atmosphereMieCoefficient * (opticalDepth.y + lightOpticalDepth.y)) + (czm_atmosphereRayleighCoefficient * (opticalDepth.x + lightOpticalDepth.x))));\n\n        // Accumulate the scattering.\n        rayleighAccumulation += sampleDensity.x * attenuation;\n        mieAccumulation += sampleDensity.y * attenuation;\n\n        // Increment distance on primary ray.\n        rayPositionLength += (rayStepLength += rayStepLengthIncrease);\n    }\n\n    // Compute the scattering amount.\n    rayleighColor = czm_atmosphereRayleighCoefficient * rayleighAccumulation;\n    mieColor = czm_atmosphereMieCoefficient * mieAccumulation;\n\n    // Compute the transmittance i.e. how much light is passing through the atmosphere.\n    opacity = length(exp(-((czm_atmosphereMieCoefficient * opticalDepth.y) + (czm_atmosphereRayleighCoefficient * opticalDepth.x))));\n}\n"},269453:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * @private\n */\nvec2 cordic(float angle)\n{\n// Scale the vector by the appropriate factor for the 24 iterations to follow.\n    vec2 vector = vec2(6.0725293500888267e-1, 0.0);\n// Iteration 1\n    float sense = (angle < 0.0) ? -1.0 : 1.0;\n //   float factor = sense * 1.0;  // 2^-0\n    mat2 rotation = mat2(1.0, sense, -sense, 1.0);\n    vector = rotation * vector;\n    angle -= sense * 7.8539816339744828e-1;  // atan(2^-0)\n// Iteration 2\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    float factor = sense * 5.0e-1;  // 2^-1\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 4.6364760900080609e-1;  // atan(2^-1)\n// Iteration 3\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 2.5e-1;  // 2^-2\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 2.4497866312686414e-1;  // atan(2^-2)\n// Iteration 4\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 1.25e-1;  // 2^-3\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 1.2435499454676144e-1;  // atan(2^-3)\n// Iteration 5\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 6.25e-2;  // 2^-4\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 6.2418809995957350e-2;  // atan(2^-4)\n// Iteration 6\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 3.125e-2;  // 2^-5\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 3.1239833430268277e-2;  // atan(2^-5)\n// Iteration 7\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 1.5625e-2;  // 2^-6\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 1.5623728620476831e-2;  // atan(2^-6)\n// Iteration 8\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 7.8125e-3;  // 2^-7\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 7.8123410601011111e-3;  // atan(2^-7)\n// Iteration 9\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 3.90625e-3;  // 2^-8\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 3.9062301319669718e-3;  // atan(2^-8)\n// Iteration 10\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 1.953125e-3;  // 2^-9\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 1.9531225164788188e-3;  // atan(2^-9)\n// Iteration 11\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 9.765625e-4;  // 2^-10\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 9.7656218955931946e-4;  // atan(2^-10)\n// Iteration 12\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 4.8828125e-4;  // 2^-11\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 4.8828121119489829e-4;  // atan(2^-11)\n// Iteration 13\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 2.44140625e-4;  // 2^-12\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 2.4414062014936177e-4;  // atan(2^-12)\n// Iteration 14\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 1.220703125e-4;  // 2^-13\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 1.2207031189367021e-4;  // atan(2^-13)\n// Iteration 15\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 6.103515625e-5;  // 2^-14\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 6.1035156174208773e-5;  // atan(2^-14)\n// Iteration 16\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 3.0517578125e-5;  // 2^-15\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 3.0517578115526096e-5;  // atan(2^-15)\n// Iteration 17\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 1.52587890625e-5;  // 2^-16\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 1.5258789061315762e-5;  // atan(2^-16)\n// Iteration 18\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 7.62939453125e-6;  // 2^-17\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 7.6293945311019700e-6;  // atan(2^-17)\n// Iteration 19\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 3.814697265625e-6;  // 2^-18\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 3.8146972656064961e-6;  // atan(2^-18)\n// Iteration 20\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 1.9073486328125e-6;  // 2^-19\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 1.9073486328101870e-6;  // atan(2^-19)\n// Iteration 21\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 9.5367431640625e-7;  // 2^-20\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 9.5367431640596084e-7;  // atan(2^-20)\n// Iteration 22\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 4.76837158203125e-7;  // 2^-21\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 4.7683715820308884e-7;  // atan(2^-21)\n// Iteration 23\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 2.384185791015625e-7;  // 2^-22\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 2.3841857910155797e-7;  // atan(2^-22)\n// Iteration 24\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 1.1920928955078125e-7;  // 2^-23\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n//    angle -= sense * 1.1920928955078068e-7;  // atan(2^-23)\n\n    return vector;\n}\n\n/**\n * Computes the cosine and sine of the provided angle using the CORDIC algorithm.\n *\n * @name czm_cosineAndSine\n * @glslFunction\n *\n * @param {float} angle The angle in radians.\n *\n * @returns {vec2} The resulting cosine of the angle (as the x coordinate) and sine of the angle (as the y coordinate).\n *\n * @example\n * vec2 v = czm_cosineAndSine(czm_piOverSix);\n * float cosine = v.x;\n * float sine = v.y;\n */\nvec2 czm_cosineAndSine(float angle)\n{\n    if (angle < -czm_piOverTwo || angle > czm_piOverTwo)\n    {\n        if (angle < 0.0)\n        {\n            return -cordic(angle + czm_pi);\n        }\n        else\n        {\n            return -cordic(angle - czm_pi);\n        }\n    }\n    else\n    {\n        return cordic(angle);\n    }\n}\n"},817515:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Decompresses texture coordinates that were packed into a single float.\n *\n * @name czm_decompressTextureCoordinates\n * @glslFunction\n *\n * @param {float} encoded The compressed texture coordinates.\n * @returns {vec2} The decompressed texture coordinates.\n */\n vec2 czm_decompressTextureCoordinates(float encoded)\n {\n    float temp = encoded / 4096.0;\n    float xZeroTo4095 = floor(temp);\n    float stx = xZeroTo4095 / 4095.0;\n    float sty = (encoded - xZeroTo4095 * 4096.0) / 4095.0;\n    return vec2(stx, sty);\n }\n"},240790:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="// emulated noperspective\n#if (__VERSION__ == 300 || defined(GL_EXT_frag_depth)) && !defined(LOG_DEPTH)\nout float v_WindowZ;\n#endif\n\n/**\n * Emulates GL_DEPTH_CLAMP, which is not available in WebGL 1 or 2.\n * GL_DEPTH_CLAMP clamps geometry that is outside the near and far planes, \n * capping the shadow volume. More information here: \n * https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_depth_clamp.txt.\n *\n * When GL_EXT_frag_depth is available we emulate GL_DEPTH_CLAMP by ensuring \n * no geometry gets clipped by setting the clip space z value to 0.0 and then\n * sending the unaltered screen space z value (using emulated noperspective\n * interpolation) to the frag shader where it is clamped to [0,1] and then\n * written with gl_FragDepth (see czm_writeDepthClamp). This technique is based on:\n * https://stackoverflow.com/questions/5960757/how-to-emulate-gl-depth-clamp-nv.\n *\n * When GL_EXT_frag_depth is not available, which is the case on some mobile \n * devices, we must attempt to fix this only in the vertex shader. \n * The approach is to clamp the z value to the far plane, which closes the \n * shadow volume but also distorts the geometry, so there can still be artifacts\n * on frustum seams.\n *\n * @name czm_depthClamp\n * @glslFunction\n *\n * @param {vec4} coords The vertex in clip coordinates.\n * @returns {vec4} The modified vertex.\n *\n * @example\n * gl_Position = czm_depthClamp(czm_modelViewProjection * vec4(position, 1.0));\n *\n * @see czm_writeDepthClamp\n */\nvec4 czm_depthClamp(vec4 coords)\n{\n#ifndef LOG_DEPTH\n#if __VERSION__ == 300 || defined(GL_EXT_frag_depth)\n    v_WindowZ = (0.5 * (coords.z / coords.w) + 0.5) * coords.w;\n    coords.z = 0.0;\n#else\n    coords.z = min(coords.z, coords.w);\n#endif\n#endif\n    return coords;\n}\n"},12624:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Computes a 3x3 rotation matrix that transforms vectors from an ellipsoid's east-north-up coordinate system \n * to eye coordinates.  In east-north-up coordinates, x points east, y points north, and z points along the \n * surface normal.  East-north-up can be used as an ellipsoid's tangent space for operations such as bump mapping.\n * <br /><br />\n * The ellipsoid is assumed to be centered at the model coordinate's origin.\n *\n * @name czm_eastNorthUpToEyeCoordinates\n * @glslFunction\n *\n * @param {vec3} positionMC The position on the ellipsoid in model coordinates.\n * @param {vec3} normalEC The normalized ellipsoid surface normal, at <code>positionMC</code>, in eye coordinates.\n *\n * @returns {mat3} A 3x3 rotation matrix that transforms vectors from the east-north-up coordinate system to eye coordinates.\n *\n * @example\n * // Transform a vector defined in the east-north-up coordinate \n * // system, (0, 0, 1) which is the surface normal, to eye \n * // coordinates.\n * mat3 m = czm_eastNorthUpToEyeCoordinates(positionMC, normalEC);\n * vec3 normalEC = m * vec3(0.0, 0.0, 1.0);\n */\nmat3 czm_eastNorthUpToEyeCoordinates(vec3 positionMC, vec3 normalEC)\n{\n    vec3 tangentMC = normalize(vec3(-positionMC.y, positionMC.x, 0.0));  // normalized surface tangent in model coordinates\n    vec3 tangentEC = normalize(czm_normal3D * tangentMC);                // normalized surface tangent in eye coordinates\n    vec3 bitangentEC = normalize(cross(normalEC, tangentEC));            // normalized surface bitangent in eye coordinates\n\n    return mat3(\n        tangentEC.x,   tangentEC.y,   tangentEC.z,\n        bitangentEC.x, bitangentEC.y, bitangentEC.z,\n        normalEC.x,    normalEC.y,    normalEC.z);\n}\n"},13500:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * DOC_TBA\n *\n * @name czm_ellipsoidContainsPoint\n * @glslFunction\n *\n */\nbool czm_ellipsoidContainsPoint(vec3 ellipsoid_inverseRadii, vec3 point)\n{\n    vec3 scaled = ellipsoid_inverseRadii * (czm_inverseModelView * vec4(point, 1.0)).xyz;\n    return (dot(scaled, scaled) <= 1.0);\n}\n"},943703:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Approximate uv coordinates based on the ellipsoid normal.\n *\n * @name czm_ellipsoidTextureCoordinates\n * @glslFunction\n */\nvec2 czm_ellipsoidTextureCoordinates(vec3 normal)\n{\n    return vec2(atan(normal.y, normal.x) * czm_oneOverTwoPi + 0.5, asin(normal.z) * czm_oneOverPi + 0.5);\n}\n"},915493:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Compares <code>left</code> and <code>right</code> componentwise. Returns <code>true</code>\n * if they are within <code>epsilon</code> and <code>false</code> otherwise. The inputs\n * <code>left</code> and <code>right</code> can be <code>float</code>s, <code>vec2</code>s,\n * <code>vec3</code>s, or <code>vec4</code>s.\n *\n * @name czm_equalsEpsilon\n * @glslFunction\n *\n * @param {} left The first vector.\n * @param {} right The second vector.\n * @param {float} epsilon The epsilon to use for equality testing.\n * @returns {bool} <code>true</code> if the components are within <code>epsilon</code> and <code>false</code> otherwise.\n *\n * @example\n * // GLSL declarations\n * bool czm_equalsEpsilon(float left, float right, float epsilon);\n * bool czm_equalsEpsilon(vec2 left, vec2 right, float epsilon);\n * bool czm_equalsEpsilon(vec3 left, vec3 right, float epsilon);\n * bool czm_equalsEpsilon(vec4 left, vec4 right, float epsilon);\n */\nbool czm_equalsEpsilon(vec4 left, vec4 right, float epsilon) {\n    return all(lessThanEqual(abs(left - right), vec4(epsilon)));\n}\n\nbool czm_equalsEpsilon(vec3 left, vec3 right, float epsilon) {\n    return all(lessThanEqual(abs(left - right), vec3(epsilon)));\n}\n\nbool czm_equalsEpsilon(vec2 left, vec2 right, float epsilon) {\n    return all(lessThanEqual(abs(left - right), vec2(epsilon)));\n}\n\nbool czm_equalsEpsilon(float left, float right, float epsilon) {\n    return (abs(left - right) <= epsilon);\n}\n"},493458:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * DOC_TBA\n *\n * @name czm_eyeOffset\n * @glslFunction\n *\n * @param {vec4} positionEC DOC_TBA.\n * @param {vec3} eyeOffset DOC_TBA.\n *\n * @returns {vec4} DOC_TBA.\n */\nvec4 czm_eyeOffset(vec4 positionEC, vec3 eyeOffset)\n{\n    // This equation is approximate in x and y.\n    vec4 p = positionEC;\n    vec4 zEyeOffset = normalize(p) * eyeOffset.z;\n    p.xy += eyeOffset.xy + zEyeOffset.xy;\n    p.z += zEyeOffset.z;\n    return p;\n}\n"},820789:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Transforms a position from eye to window coordinates.  The transformation\n * from eye to clip coordinates is done using {@link czm_projection}.\n * The transform from normalized device coordinates to window coordinates is\n * done using {@link czm_viewportTransformation}, which assumes a depth range\n * of <code>near = 0</code> and <code>far = 1</code>.\n * <br /><br />\n * This transform is useful when there is a need to manipulate window coordinates\n * in a vertex shader as done by {@link BillboardCollection}.\n *\n * @name czm_eyeToWindowCoordinates\n * @glslFunction\n *\n * @param {vec4} position The position in eye coordinates to transform.\n *\n * @returns {vec4} The transformed position in window coordinates.\n *\n * @see czm_modelToWindowCoordinates\n * @see czm_projection\n * @see czm_viewportTransformation\n * @see BillboardCollection\n *\n * @example\n * vec4 positionWC = czm_eyeToWindowCoordinates(positionEC);\n */\nvec4 czm_eyeToWindowCoordinates(vec4 positionEC)\n{\n    vec4 q = czm_projection * positionEC;                        // clip coordinates\n    q.xyz /= q.w;                                                // normalized device coordinates\n    q.xyz = (czm_viewportTransformation * vec4(q.xyz, 1.0)).xyz; // window coordinates\n    return q;\n}\n"},565274:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Approxiamtes atan over the range [0, 1]. Safe to flip output for negative input.\n *\n * Based on Michal Drobot's approximation from ShaderFastLibs, which in turn is based on\n * \"Efficient approximations for the arctangent function,\" Rajan, S. Sichun Wang Inkol, R. Joyal, A., May 2006.\n * Adapted from ShaderFastLibs under MIT License.\n *\n * Chosen for the following characteristics over range [0, 1]:\n * - basically no error at 0 and 1, important for getting around range limit (naive atan2 via atan requires infinite range atan)\n * - no visible artifacts from first-derivative discontinuities, unlike latitude via range-reduced sqrt asin approximations (at equator)\n *\n * The original code is x * (-0.1784 * abs(x) - 0.0663 * x * x + 1.0301);\n * Removed the abs() in here because it isn't needed, the input range is guaranteed as [0, 1] by how we're approximating atan2.\n *\n * @name czm_fastApproximateAtan\n * @glslFunction\n *\n * @param {float} x Value between 0 and 1 inclusive.\n *\n * @returns {float} Approximation of atan(x)\n */\nfloat czm_fastApproximateAtan(float x) {\n    return x * (-0.1784 * x - 0.0663 * x * x + 1.0301);\n}\n\n/**\n * Approximation of atan2.\n *\n * Range reduction math based on nvidia's cg reference implementation for atan2: http://developer.download.nvidia.com/cg/atan2.html\n * However, we replaced their atan curve with Michael Drobot's (see above).\n *\n * @name czm_fastApproximateAtan\n * @glslFunction\n *\n * @param {float} x Value between -1 and 1 inclusive.\n * @param {float} y Value between -1 and 1 inclusive.\n *\n * @returns {float} Approximation of atan2(x, y)\n */\nfloat czm_fastApproximateAtan(float x, float y) {\n    // atan approximations are usually only reliable over [-1, 1], or, in our case, [0, 1] due to modifications.\n    // So range-reduce using abs and by flipping whether x or y is on top.\n    float t = abs(x); // t used as swap and atan result.\n    float opposite = abs(y);\n    float adjacent = max(t, opposite);\n    opposite = min(t, opposite);\n\n    t = czm_fastApproximateAtan(opposite / adjacent);\n\n    // Undo range reduction\n    t = czm_branchFreeTernary(abs(y) > abs(x), czm_piOverTwo - t, t);\n    t = czm_branchFreeTernary(x < 0.0, czm_pi - t, t);\n    t = czm_branchFreeTernary(y < 0.0, -t, t);\n    return t;\n}\n"},247408:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Gets the color with fog at a distance from the camera.\n *\n * @name czm_fog\n * @glslFunction\n *\n * @param {float} distanceToCamera The distance to the camera in meters.\n * @param {vec3} color The original color.\n * @param {vec3} fogColor The color of the fog.\n *\n * @returns {vec3} The color adjusted for fog at the distance from the camera.\n */\nvec3 czm_fog(float distanceToCamera, vec3 color, vec3 fogColor)\n{\n    float scalar = distanceToCamera * czm_fogDensity;\n    float fog = 1.0 - exp(-(scalar * scalar));\n    return mix(color, fogColor, fog);\n}\n\n/**\n * Gets the color with fog at a distance from the camera.\n *\n * @name czm_fog\n * @glslFunction\n *\n * @param {float} distanceToCamera The distance to the camera in meters.\n * @param {vec3} color The original color.\n * @param {vec3} fogColor The color of the fog.\n * @param {float} fogModifierConstant A constant to modify the appearance of fog.\n *\n * @returns {vec3} The color adjusted for fog at the distance from the camera.\n */\nvec3 czm_fog(float distanceToCamera, vec3 color, vec3 fogColor, float fogModifierConstant)\n{\n    float scalar = distanceToCamera * czm_fogDensity;\n    float fog = 1.0 - exp(-((fogModifierConstant * scalar + fogModifierConstant) * (scalar * (1.0 + fogModifierConstant))));\n    return mix(color, fogColor, fog);\n}\n"},177627:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Converts a color from RGB space to linear space.\n *\n * @name czm_gammaCorrect\n * @glslFunction\n *\n * @param {vec3} color The color in RGB space.\n * @returns {vec3} The color in linear space.\n */\nvec3 czm_gammaCorrect(vec3 color) {\n#ifdef HDR\n    color = pow(color, vec3(czm_gamma));\n#endif\n    return color;\n}\n\nvec4 czm_gammaCorrect(vec4 color) {\n#ifdef HDR\n    color.rgb = pow(color.rgb, vec3(czm_gamma));\n#endif\n    return color;\n}\n"},624782:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * DOC_TBA\n *\n * @name czm_geodeticSurfaceNormal\n * @glslFunction\n *\n * @param {vec3} positionOnEllipsoid DOC_TBA\n * @param {vec3} ellipsoidCenter DOC_TBA\n * @param {vec3} oneOverEllipsoidRadiiSquared DOC_TBA\n * \n * @returns {vec3} DOC_TBA.\n */\nvec3 czm_geodeticSurfaceNormal(vec3 positionOnEllipsoid, vec3 ellipsoidCenter, vec3 oneOverEllipsoidRadiiSquared)\n{\n    return normalize((positionOnEllipsoid - ellipsoidCenter) * oneOverEllipsoidRadiiSquared);\n}\n"},195814:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * An czm_material with default values. Every material's czm_getMaterial\n * should use this default material as a base for the material it returns.\n * The default normal value is given by materialInput.normalEC.\n *\n * @name czm_getDefaultMaterial\n * @glslFunction\n *\n * @param {czm_materialInput} input The input used to construct the default material.\n *\n * @returns {czm_material} The default material.\n *\n * @see czm_materialInput\n * @see czm_material\n * @see czm_getMaterial\n */\nczm_material czm_getDefaultMaterial(czm_materialInput materialInput)\n{\n    czm_material material;\n    material.diffuse = vec3(0.0);\n    material.specular = 0.0;\n    material.shininess = 1.0;\n    material.normal = materialInput.normalEC;\n    material.emission = vec3(0.0);\n    material.alpha = 1.0;\n    return material;\n}\n"},9102:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Select which direction vector to use for dynamic atmosphere lighting based on an enum value\n *\n * @name czm_getDynamicAtmosphereLightDirection\n * @glslfunction\n * @see DynamicAtmosphereLightingType.js\n *\n * @param {vec3} positionWC the position of the vertex/fragment in world coordinates. This is normalized and returned when dynamic lighting is turned off.\n * @param {float} lightEnum The enum value for selecting between light sources.\n * @return {vec3} The normalized light direction vector. Depending on the enum value, it is either positionWC, czm_lightDirectionWC or czm_sunDirectionWC\n */\nvec3 czm_getDynamicAtmosphereLightDirection(vec3 positionWC, float lightEnum) {\n    const float NONE = 0.0;\n    const float SCENE_LIGHT = 1.0;\n    const float SUNLIGHT = 2.0;\n\n    vec3 lightDirection =\n        positionWC * float(lightEnum == NONE) +\n        czm_lightDirectionWC * float(lightEnum == SCENE_LIGHT) +\n        czm_sunDirectionWC * float(lightEnum == SUNLIGHT);\n    return normalize(lightDirection);\n}\n"},534173:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Calculates the intensity of diffusely reflected light.\n *\n * @name czm_getLambertDiffuse\n * @glslFunction\n *\n * @param {vec3} lightDirectionEC Unit vector pointing to the light source in eye coordinates.\n * @param {vec3} normalEC The surface normal in eye coordinates.\n *\n * @returns {float} The intensity of the diffuse reflection.\n *\n * @see czm_phong\n *\n * @example\n * float diffuseIntensity = czm_getLambertDiffuse(lightDirectionEC, normalEC);\n * float specularIntensity = czm_getSpecular(lightDirectionEC, toEyeEC, normalEC, 200);\n * vec3 color = (diffuseColor * diffuseIntensity) + (specularColor * specularIntensity);\n */\nfloat czm_getLambertDiffuse(vec3 lightDirectionEC, vec3 normalEC)\n{\n    return max(dot(lightDirectionEC, normalEC), 0.0);\n}\n"},348941:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Calculates the specular intensity of reflected light.\n *\n * @name czm_getSpecular\n * @glslFunction\n *\n * @param {vec3} lightDirectionEC Unit vector pointing to the light source in eye coordinates.\n * @param {vec3} toEyeEC Unit vector pointing to the eye position in eye coordinates.\n * @param {vec3} normalEC The surface normal in eye coordinates.\n * @param {float} shininess The sharpness of the specular reflection.  Higher values create a smaller, more focused specular highlight.\n *\n * @returns {float} The intensity of the specular highlight.\n *\n * @see czm_phong\n *\n * @example\n * float diffuseIntensity = czm_getLambertDiffuse(lightDirectionEC, normalEC);\n * float specularIntensity = czm_getSpecular(lightDirectionEC, toEyeEC, normalEC, 200);\n * vec3 color = (diffuseColor * diffuseIntensity) + (specularColor * specularIntensity);\n */\nfloat czm_getSpecular(vec3 lightDirectionEC, vec3 toEyeEC, vec3 normalEC, float shininess)\n{\n    vec3 toReflectedLight = reflect(-lightDirectionEC, normalEC);\n    float specular = max(dot(toReflectedLight, toEyeEC), 0.0);\n\n    // pow has undefined behavior if both parameters <= 0.\n    // Prevent this by making sure shininess is at least czm_epsilon2.\n    return pow(specular, max(shininess, czm_epsilon2));\n}\n"},431443:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * @private\n */\nvec4 czm_getWaterNoise(sampler2D normalMap, vec2 uv, float time, float angleInRadians)\n{\n    float cosAngle = cos(angleInRadians);\n    float sinAngle = sin(angleInRadians);\n\n    // time dependent sampling directions\n    vec2 s0 = vec2(1.0/17.0, 0.0);\n    vec2 s1 = vec2(-1.0/29.0, 0.0);\n    vec2 s2 = vec2(1.0/101.0, 1.0/59.0);\n    vec2 s3 = vec2(-1.0/109.0, -1.0/57.0);\n\n    // rotate sampling direction by specified angle\n    s0 = vec2((cosAngle * s0.x) - (sinAngle * s0.y), (sinAngle * s0.x) + (cosAngle * s0.y));\n    s1 = vec2((cosAngle * s1.x) - (sinAngle * s1.y), (sinAngle * s1.x) + (cosAngle * s1.y));\n    s2 = vec2((cosAngle * s2.x) - (sinAngle * s2.y), (sinAngle * s2.x) + (cosAngle * s2.y));\n    s3 = vec2((cosAngle * s3.x) - (sinAngle * s3.y), (sinAngle * s3.x) + (cosAngle * s3.y));\n\n    vec2 uv0 = (uv/103.0) + (time * s0);\n    vec2 uv1 = uv/107.0 + (time * s1) + vec2(0.23);\n    vec2 uv2 = uv/vec2(897.0, 983.0) + (time * s2) + vec2(0.51);\n    vec2 uv3 = uv/vec2(991.0, 877.0) + (time * s3) + vec2(0.71);\n\n    uv0 = fract(uv0);\n    uv1 = fract(uv1);\n    uv2 = fract(uv2);\n    uv3 = fract(uv3);\n    vec4 noise = (texture(normalMap, uv0)) +\n                 (texture(normalMap, uv1)) +\n                 (texture(normalMap, uv2)) +\n                 (texture(normalMap, uv3));\n\n    // average and scale to between -1 and 1\n    return ((noise / 4.0) - 0.5) * 2.0;\n}\n"},448358:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Adjusts the hue of a color.\n * \n * @name czm_hue\n * @glslFunction\n * \n * @param {vec3} rgb The color.\n * @param {float} adjustment The amount to adjust the hue of the color in radians.\n *\n * @returns {float} The color with the hue adjusted.\n *\n * @example\n * vec3 adjustHue = czm_hue(color, czm_pi); // The same as czm_hue(color, -czm_pi)\n */\nvec3 czm_hue(vec3 rgb, float adjustment)\n{\n    const mat3 toYIQ = mat3(0.299,     0.587,     0.114,\n                            0.595716, -0.274453, -0.321263,\n                            0.211456, -0.522591,  0.311135);\n    const mat3 toRGB = mat3(1.0,  0.9563,  0.6210,\n                            1.0, -0.2721, -0.6474,\n                            1.0, -1.107,   1.7046);\n    \n    vec3 yiq = toYIQ * rgb;\n    float hue = atan(yiq.z, yiq.y) + adjustment;\n    float chroma = sqrt(yiq.z * yiq.z + yiq.y * yiq.y);\n    \n    vec3 color = vec3(yiq.x, chroma * cos(hue), chroma * sin(hue));\n    return toRGB * color;\n}\n"},633899:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Converts a color in linear space to RGB space.\n *\n * @name czm_inverseGamma\n * @glslFunction\n *\n * @param {vec3} color The color in linear space.\n * @returns {vec3} The color in RGB space.\n */\nvec3 czm_inverseGamma(vec3 color) {\n    return pow(color, vec3(1.0 / czm_gamma));\n}\n"},393597:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Determines if a time interval is empty.\n *\n * @name czm_isEmpty\n * @glslFunction \n * \n * @param {czm_raySegment} interval The interval to test.\n * \n * @returns {bool} <code>true</code> if the time interval is empty; otherwise, <code>false</code>.\n *\n * @example\n * bool b0 = czm_isEmpty(czm_emptyRaySegment);      // true\n * bool b1 = czm_isEmpty(czm_raySegment(0.0, 1.0)); // false\n * bool b2 = czm_isEmpty(czm_raySegment(1.0, 1.0)); // false, contains 1.0.\n */\nbool czm_isEmpty(czm_raySegment interval)\n{\n    return (interval.stop < 0.0);\n}\n"},293367:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Determines if a time interval is empty.\n *\n * @name czm_isFull\n * @glslFunction \n * \n * @param {czm_raySegment} interval The interval to test.\n * \n * @returns {bool} <code>true</code> if the time interval is empty; otherwise, <code>false</code>.\n *\n * @example\n * bool b0 = czm_isEmpty(czm_emptyRaySegment);      // true\n * bool b1 = czm_isEmpty(czm_raySegment(0.0, 1.0)); // false\n * bool b2 = czm_isEmpty(czm_raySegment(1.0, 1.0)); // false, contains 1.0.\n */\nbool czm_isFull(czm_raySegment interval)\n{\n    return (interval.start == 0.0 && interval.stop == czm_infinity);\n}\n"},31862:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Computes the fraction of a Web Wercator rectangle at which a given geodetic latitude is located.\n *\n * @name czm_latitudeToWebMercatorFraction\n * @glslFunction\n *\n * @param {float} latitude The geodetic latitude, in radians.\n * @param {float} southMercatorY The Web Mercator coordinate of the southern boundary of the rectangle.\n * @param {float} oneOverMercatorHeight The total height of the rectangle in Web Mercator coordinates.\n *\n * @returns {float} The fraction of the rectangle at which the latitude occurs.  If the latitude is the southern\n *          boundary of the rectangle, the return value will be zero.  If it is the northern boundary, the return\n *          value will be 1.0.  Latitudes in between are mapped according to the Web Mercator projection.\n */ \nfloat czm_latitudeToWebMercatorFraction(float latitude, float southMercatorY, float oneOverMercatorHeight)\n{\n    float sinLatitude = sin(latitude);\n    float mercatorY = 0.5 * log((1.0 + sinLatitude) / (1.0 - sinLatitude));\n    \n    return (mercatorY - southMercatorY) * oneOverMercatorHeight;\n}\n"},610675:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Computes distance from an point in 2D to a line in 2D.\n *\n * @name czm_lineDistance\n * @glslFunction\n *\n * param {vec2} point1 A point along the line.\n * param {vec2} point2 A point along the line.\n * param {vec2} point A point that may or may not be on the line.\n * returns {float} The distance from the point to the line.\n */\nfloat czm_lineDistance(vec2 point1, vec2 point2, vec2 point) {\n    return abs((point2.y - point1.y) * point.x - (point2.x - point1.x) * point.y + point2.x * point1.y - point2.y * point1.x) / distance(point2, point1);\n}\n"},160958:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Converts a linear RGB color to an sRGB color.\n *\n * @param {vec3|vec4} linearIn The color in linear color space.\n * @returns {vec3|vec4} The color in sRGB color space. The vector type matches the input.\n */\nvec3 czm_linearToSrgb(vec3 linearIn) \n{\n    return pow(linearIn, vec3(1.0/2.2));\n}\n\nvec4 czm_linearToSrgb(vec4 linearIn) \n{\n    vec3 srgbOut = pow(linearIn.rgb, vec3(1.0/2.2));\n    return vec4(srgbOut, linearIn.a);\n}\n"},21038:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Computes the luminance of a color. \n *\n * @name czm_luminance\n * @glslFunction\n *\n * @param {vec3} rgb The color.\n * \n * @returns {float} The luminance.\n *\n * @example\n * float light = czm_luminance(vec3(0.0)); // 0.0\n * float dark = czm_luminance(vec3(1.0));  // ~1.0 \n */\nfloat czm_luminance(vec3 rgb)\n{\n    // Algorithm from Chapter 10 of Graphics Shaders.\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n    return dot(rgb, W);\n}\n"},363063:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Find the maximum component of a vector.\n *\n * @name czm_maximumComponent\n * @glslFunction\n *\n * @param {vec2|vec3|vec4} v The input vector.\n * @returns {float} The value of the largest component.\n */\nfloat czm_maximumComponent(vec2 v)\n{\n    return max(v.x, v.y);\n}\nfloat czm_maximumComponent(vec3 v)\n{\n    return max(max(v.x, v.y), v.z);\n}\nfloat czm_maximumComponent(vec4 v)\n{\n    return max(max(max(v.x, v.y), v.z), v.w);\n}\n"},973717:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Computes the size of a pixel in meters at a distance from the eye.\n * <p>\n * Use this version when passing in a custom pixel ratio. For example, passing in 1.0 will return meters per native device pixel.\n * </p>\n * @name czm_metersPerPixel\n * @glslFunction\n *\n * @param {vec3} positionEC The position to get the meters per pixel in eye coordinates.\n * @param {float} pixelRatio The scaling factor from pixel space to coordinate space\n *\n * @returns {float} The meters per pixel at positionEC.\n */\nfloat czm_metersPerPixel(vec4 positionEC, float pixelRatio)\n{\n    float width = czm_viewport.z;\n    float height = czm_viewport.w;\n    float pixelWidth;\n    float pixelHeight;\n\n    float top = czm_frustumPlanes.x;\n    float bottom = czm_frustumPlanes.y;\n    float left = czm_frustumPlanes.z;\n    float right = czm_frustumPlanes.w;\n\n    if (czm_sceneMode == czm_sceneMode2D || czm_orthographicIn3D == 1.0)\n    {\n        float frustumWidth = right - left;\n        float frustumHeight = top - bottom;\n        pixelWidth = frustumWidth / width;\n        pixelHeight = frustumHeight / height;\n    }\n    else\n    {\n        float distanceToPixel = -positionEC.z;\n        float inverseNear = 1.0 / czm_currentFrustum.x;\n        float tanTheta = top * inverseNear;\n        pixelHeight = 2.0 * distanceToPixel * tanTheta / height;\n        tanTheta = right * inverseNear;\n        pixelWidth = 2.0 * distanceToPixel * tanTheta / width;\n    }\n\n    return max(pixelWidth, pixelHeight) * pixelRatio;\n}\n\n/**\n * Computes the size of a pixel in meters at a distance from the eye.\n * <p>\n * Use this version when scaling by pixel ratio.\n * </p>\n * @name czm_metersPerPixel\n * @glslFunction\n *\n * @param {vec3} positionEC The position to get the meters per pixel in eye coordinates.\n *\n * @returns {float} The meters per pixel at positionEC.\n */\nfloat czm_metersPerPixel(vec4 positionEC)\n{\n    return czm_metersPerPixel(positionEC, czm_pixelRatio);\n}\n"},254805:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Transforms a position from model to window coordinates.  The transformation\n * from model to clip coordinates is done using {@link czm_modelViewProjection}.\n * The transform from normalized device coordinates to window coordinates is\n * done using {@link czm_viewportTransformation}, which assumes a depth range\n * of <code>near = 0</code> and <code>far = 1</code>.\n * <br /><br />\n * This transform is useful when there is a need to manipulate window coordinates\n * in a vertex shader as done by {@link BillboardCollection}.\n * <br /><br />\n * This function should not be confused with {@link czm_viewportOrthographic},\n * which is an orthographic projection matrix that transforms from window \n * coordinates to clip coordinates.\n *\n * @name czm_modelToWindowCoordinates\n * @glslFunction\n *\n * @param {vec4} position The position in model coordinates to transform.\n *\n * @returns {vec4} The transformed position in window coordinates.\n *\n * @see czm_eyeToWindowCoordinates\n * @see czm_modelViewProjection\n * @see czm_viewportTransformation\n * @see czm_viewportOrthographic\n * @see BillboardCollection\n *\n * @example\n * vec4 positionWC = czm_modelToWindowCoordinates(positionMC);\n */\nvec4 czm_modelToWindowCoordinates(vec4 position)\n{\n    vec4 positionEC = czm_modelView * position;\n    vec4 q = czm_projection * positionEC;\n    q.xyz /= q.w;                                                // normalized device coordinates\n    q.xyz = (czm_viewportTransformation * vec4(q.xyz, 1.0)).xyz; // window coordinates\n    return q;\n}\n"},548051:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * DOC_TBA\n *\n * @name czm_multiplyWithColorBalance\n * @glslFunction\n */\nvec3 czm_multiplyWithColorBalance(vec3 left, vec3 right)\n{\n    // Algorithm from Chapter 10 of Graphics Shaders.\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n    \n    vec3 target = left * right;\n    float leftLuminance = dot(left, W);\n    float rightLuminance = dot(right, W);\n    float targetLuminance = dot(target, W);\n    \n    return ((leftLuminance + rightLuminance) / (2.0 * targetLuminance)) * target;\n}\n"},191195:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Computes a value that scales with distance.  The scaling is clamped at the near and\n * far distances, and does not extrapolate.  This function works with the\n * {@link NearFarScalar} JavaScript class.\n *\n * @name czm_nearFarScalar\n * @glslFunction\n *\n * @param {vec4} nearFarScalar A vector with 4 components: Near distance (x), Near value (y), Far distance (z), Far value (w).\n * @param {float} cameraDistSq The square of the current distance from the camera.\n *\n * @returns {float} The value at this distance.\n */\nfloat czm_nearFarScalar(vec4 nearFarScalar, float cameraDistSq)\n{\n    float valueAtMin = nearFarScalar.y;\n    float valueAtMax = nearFarScalar.w;\n    float nearDistanceSq = nearFarScalar.x * nearFarScalar.x;\n    float farDistanceSq = nearFarScalar.z * nearFarScalar.z;\n\n    float t = (cameraDistSq - nearDistanceSq) / (farDistanceSq - nearDistanceSq);\n\n    t = pow(clamp(t, 0.0, 1.0), 0.2);\n\n    return mix(valueAtMin, valueAtMax, t);\n}\n"},738340:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i=" /**\n  * Decodes a unit-length vector in 'oct' encoding to a normalized 3-component Cartesian vector.\n  * The 'oct' encoding is described in \"A Survey of Efficient Representations of Independent Unit Vectors\",\n  * Cigolle et al 2014: http://jcgt.org/published/0003/02/01/\n  *\n  * @name czm_octDecode\n  * @param {vec2} encoded The oct-encoded, unit-length vector\n  * @param {float} range The maximum value of the SNORM range. The encoded vector is stored in log2(rangeMax+1) bits.\n  * @returns {vec3} The decoded and normalized vector\n  */\n  vec3 czm_octDecode(vec2 encoded, float range)\n  {\n      if (encoded.x == 0.0 && encoded.y == 0.0) {\n          return vec3(0.0, 0.0, 0.0);\n      }\n\n     encoded = encoded / range * 2.0 - 1.0;\n     vec3 v = vec3(encoded.x, encoded.y, 1.0 - abs(encoded.x) - abs(encoded.y));\n     if (v.z < 0.0)\n     {\n         v.xy = (1.0 - abs(v.yx)) * czm_signNotZero(v.xy);\n     }\n\n     return normalize(v);\n  }\n\n/**\n * Decodes a unit-length vector in 'oct' encoding to a normalized 3-component Cartesian vector.\n * The 'oct' encoding is described in \"A Survey of Efficient Representations of Independent Unit Vectors\",\n * Cigolle et al 2014: http://jcgt.org/published/0003/02/01/\n *\n * @name czm_octDecode\n * @param {vec2} encoded The oct-encoded, unit-length vector\n * @returns {vec3} The decoded and normalized vector\n */\n vec3 czm_octDecode(vec2 encoded)\n {\n    return czm_octDecode(encoded, 255.0);\n }\n\n /**\n * Decodes a unit-length vector in 'oct' encoding packed into a floating-point number to a normalized 3-component Cartesian vector.\n * The 'oct' encoding is described in \"A Survey of Efficient Representations of Independent Unit Vectors\",\n * Cigolle et al 2014: http://jcgt.org/published/0003/02/01/\n *\n * @name czm_octDecode\n * @param {float} encoded The oct-encoded, unit-length vector\n * @returns {vec3} The decoded and normalized vector\n */\n vec3 czm_octDecode(float encoded)\n {\n    float temp = encoded / 256.0;\n    float x = floor(temp);\n    float y = (temp - x) * 256.0;\n    return czm_octDecode(vec2(x, y));\n }\n\n/**\n * Decodes three unit-length vectors in 'oct' encoding packed into two floating-point numbers to normalized 3-component Cartesian vectors.\n * The 'oct' encoding is described in \"A Survey of Efficient Representations of Independent Unit Vectors\",\n * Cigolle et al 2014: http://jcgt.org/published/0003/02/01/\n *\n * @name czm_octDecode\n * @param {vec2} encoded The packed oct-encoded, unit-length vectors.\n * @param {vec3} vector1 One decoded and normalized vector.\n * @param {vec3} vector2 One decoded and normalized vector.\n * @param {vec3} vector3 One decoded and normalized vector.\n */\n  void czm_octDecode(vec2 encoded, out vec3 vector1, out vec3 vector2, out vec3 vector3)\n {\n    float temp = encoded.x / 65536.0;\n    float x = floor(temp);\n    float encodedFloat1 = (temp - x) * 65536.0;\n\n    temp = encoded.y / 65536.0;\n    float y = floor(temp);\n    float encodedFloat2 = (temp - y) * 65536.0;\n\n    vector1 = czm_octDecode(encodedFloat1);\n    vector2 = czm_octDecode(encodedFloat2);\n    vector3 = czm_octDecode(vec2(x, y));\n }\n\n"},674794:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Packs a depth value into a vec4 that can be represented by unsigned bytes.\n *\n * @name czm_packDepth\n * @glslFunction\n *\n * @param {float} depth The floating-point depth.\n * @returns {vec4} The packed depth.\n */\nvec4 czm_packDepth(float depth)\n{\n    // See Aras Pranckeviius' post Encoding Floats to RGBA\n    // http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\n    vec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n    enc = fract(enc);\n    enc -= enc.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\n    return enc;\n}\n"},584312:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="vec3 lambertianDiffuse(vec3 diffuseColor)\n{\n    return diffuseColor / czm_pi;\n}\n\nvec3 fresnelSchlick2(vec3 f0, vec3 f90, float VdotH)\n{\n    float versine = 1.0 - VdotH;\n    // pow(versine, 5.0) is slow. See https://stackoverflow.com/a/68793086/10082269\n    float versineSquared = versine * versine;\n    return f0 + (f90 - f0) * versineSquared * versineSquared * versine;\n}\n\n#ifdef USE_ANISOTROPY\n/**\n * @param {float} bitangentRoughness Material roughness (along the anisotropy bitangent)\n * @param {float} tangentialRoughness Anisotropic roughness (along the anisotropy tangent)\n * @param {vec3} lightDirection The direction from the fragment to the light source, transformed to tangent-bitangent-normal coordinates\n * @param {vec3} viewDirection The direction from the fragment to the camera, transformed to tangent-bitangent-normal coordinates\n */\nfloat smithVisibilityGGX_anisotropic(float bitangentRoughness, float tangentialRoughness, vec3 lightDirection, vec3 viewDirection)\n{\n    vec3 roughnessScale = vec3(tangentialRoughness, bitangentRoughness, 1.0);\n    float GGXV = lightDirection.z * length(roughnessScale * viewDirection);\n    float GGXL = viewDirection.z * length(roughnessScale * lightDirection);\n    float v = 0.5 / (GGXV + GGXL);\n    return clamp(v, 0.0, 1.0);\n}\n\n/**\n * @param {float} bitangentRoughness Material roughness (along the anisotropy bitangent)\n * @param {float} tangentialRoughness Anisotropic roughness (along the anisotropy tangent)\n * @param {vec3} halfwayDirection The unit vector halfway between light and view directions, transformed to tangent-bitangent-normal coordinates\n */\nfloat GGX_anisotropic(float bitangentRoughness, float tangentialRoughness, vec3 halfwayDirection)\n{\n    float roughnessSquared = bitangentRoughness * tangentialRoughness;\n    vec3 f = halfwayDirection * vec3(bitangentRoughness, tangentialRoughness, roughnessSquared);\n    float w2 = roughnessSquared / dot(f, f);\n    return roughnessSquared * w2 * w2 / czm_pi;\n}\n#endif\n\n/**\n * Estimate the geometric self-shadowing of the microfacets in a surface,\n * using the Smith Joint GGX visibility function.\n * Note: Vis = G / (4 * NdotL * NdotV)\n * see Eric Heitz. 2014. Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs. Journal of Computer Graphics Techniques, 3\n * see Real-Time Rendering. Page 331 to 336.\n * see https://google.github.io/filament/Filament.md.html#materialsystem/specularbrdf/geometricshadowing(specularg)\n *\n * @param {float} alphaRoughness The roughness of the material, expressed as the square of perceptual roughness.\n * @param {float} NdotL The cosine of the angle between the surface normal and the direction to the light source.\n * @param {float} NdotV The cosine of the angle between the surface normal and the direction to the camera.\n */\nfloat smithVisibilityGGX(float alphaRoughness, float NdotL, float NdotV)\n{\n    float alphaRoughnessSq = alphaRoughness * alphaRoughness;\n\n    float GGXV = NdotL * sqrt(NdotV * NdotV * (1.0 - alphaRoughnessSq) + alphaRoughnessSq);\n    float GGXL = NdotV * sqrt(NdotL * NdotL * (1.0 - alphaRoughnessSq) + alphaRoughnessSq);\n\n    float GGX = GGXV + GGXL;\n    if (GGX > 0.0)\n    {\n        return 0.5 / GGX;\n    }\n    return 0.0;\n}\n\n/**\n * Estimate the fraction of the microfacets in a surface that are aligned with \n * the halfway vector, which is aligned halfway between the directions from\n * the fragment to the camera and from the fragment to the light source.\n *\n * @param {float} alphaRoughness The roughness of the material, expressed as the square of perceptual roughness.\n * @param {float} NdotH The cosine of the angle between the surface normal and the halfway vector.\n * @return {float} The fraction of microfacets aligned to the halfway vector.\n */\nfloat GGX(float alphaRoughness, float NdotH)\n{\n    float alphaRoughnessSquared = alphaRoughness * alphaRoughness;\n    float f = (NdotH * alphaRoughnessSquared - NdotH) * NdotH + 1.0;\n    return alphaRoughnessSquared / (czm_pi * f * f);\n}\n\n/**\n * Compute the strength of the specular reflection due to direct lighting.\n *\n * @param {vec3} normal The surface normal.\n * @param {vec3} lightDirection The unit vector pointing from the fragment to the light source.\n * @param {vec3} viewDirection The unit vector pointing from the fragment to the camera.\n * @param {vec3} halfwayDirection The unit vector pointing from the fragment to halfway between the light source and the camera.\n * @param {float} alphaRoughness The roughness of the material, expressed as the square of perceptual roughness.\n * @return {float} The strength of the specular reflection.\n */\nfloat computeDirectSpecularStrength(vec3 normal, vec3 lightDirection, vec3 viewDirection, vec3 halfwayDirection, float alphaRoughness)\n{\n    float NdotL = clamp(dot(normal, lightDirection), 0.0, 1.0);\n    float NdotV = clamp(dot(normal, viewDirection), 0.0, 1.0);\n    float G = smithVisibilityGGX(alphaRoughness, NdotL, NdotV);\n    float NdotH = clamp(dot(normal, halfwayDirection), 0.0, 1.0);\n    float D = GGX(alphaRoughness, NdotH);\n    return G * D;\n}\n\n/**\n * Compute the diffuse and specular contributions using physically based\n * rendering. This function only handles direct lighting.\n * <p>\n * This function only handles the lighting calculations. Metallic/roughness\n * and specular/glossy must be handled separately. See {@MaterialStageFS}\n * </p>\n *\n * @name czm_pbrLighting\n * @glslFunction\n *\n * @param {vec3} viewDirectionEC Unit vector pointing from the fragment to the eye position\n * @param {vec3} normalEC The surface normal in eye coordinates\n * @param {vec3} lightDirectionEC Unit vector pointing to the light source in eye coordinates.\n * @param {czm_modelMaterial} The material properties.\n * @return {vec3} The computed HDR color\n */\nvec3 czm_pbrLighting(vec3 viewDirectionEC, vec3 normalEC, vec3 lightDirectionEC, czm_modelMaterial material)\n{\n    vec3 halfwayDirectionEC = normalize(viewDirectionEC + lightDirectionEC);\n    float VdotH = clamp(dot(viewDirectionEC, halfwayDirectionEC), 0.0, 1.0);\n    float NdotL = clamp(dot(normalEC, lightDirectionEC), 0.001, 1.0);\n\n    vec3 f0 = material.specular;\n    float reflectance = czm_maximumComponent(f0);\n    // Typical dielectrics will have reflectance 0.04, so f90 will be 1.0.\n    // In this case, at grazing angle, all incident energy is reflected.\n    vec3 f90 = vec3(clamp(reflectance * 25.0, 0.0, 1.0));\n    vec3 F = fresnelSchlick2(f0, f90, VdotH);\n\n    #if defined(USE_SPECULAR)\n        F *= material.specularWeight;\n    #endif\n\n    float alphaRoughness = material.roughness * material.roughness;\n    #ifdef USE_ANISOTROPY\n        mat3 tbn = mat3(material.anisotropicT, material.anisotropicB, normalEC);\n        vec3 lightDirection = lightDirectionEC * tbn;\n        vec3 viewDirection = viewDirectionEC * tbn;\n        vec3 halfwayDirection = halfwayDirectionEC * tbn;\n        float anisotropyStrength = material.anisotropyStrength;\n        float tangentialRoughness = mix(alphaRoughness, 1.0, anisotropyStrength * anisotropyStrength);\n        float bitangentRoughness = clamp(alphaRoughness, 0.001, 1.0);\n        float G = smithVisibilityGGX_anisotropic(bitangentRoughness, tangentialRoughness, lightDirection, viewDirection);\n        float D = GGX_anisotropic(bitangentRoughness, tangentialRoughness, halfwayDirection);\n        vec3 specularContribution = F * G * D;\n    #else\n        float specularStrength = computeDirectSpecularStrength(normalEC, lightDirectionEC, viewDirectionEC, halfwayDirectionEC, alphaRoughness);\n        vec3 specularContribution = F * specularStrength;\n    #endif\n\n    vec3 diffuseColor = material.diffuse;\n    // F here represents the specular contribution\n    vec3 diffuseContribution = (1.0 - F) * lambertianDiffuse(diffuseColor);\n\n    // Lo = (diffuse + specular) * Li * NdotL\n    return (diffuseContribution + specularContribution) * NdotL;\n}\n"},428395:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="// KhronosGroup https://github.com/KhronosGroup/ToneMapping/tree/main/PBR_Neutral\n\n// Input color is non-negative and resides in the Linear Rec. 709 color space.\n// Output color is also Linear Rec. 709, but in the [0, 1] range.\n\nvec3 czm_pbrNeutralTonemapping(vec3 color) {\n    const float startCompression = 0.8 - 0.04;\n    const float desaturation = 0.15;\n\n    float x = min(color.r, min(color.g, color.b));\n    float offset = czm_branchFreeTernary(x < 0.08, x - 6.25 * x * x, 0.04);\n    color -= offset;\n\n    float peak = max(color.r, max(color.g, color.b));\n    if (peak < startCompression) return color;\n\n    const float d = 1.0 - startCompression;\n    float newPeak = 1.0 - d * d / (peak + d - startCompression);\n    color *= newPeak / peak;\n\n    float g = 1.0 - 1.0 / (desaturation * (peak - newPeak) + 1.0);\n    return mix(color, newPeak * vec3(1.0, 1.0, 1.0), g);\n}\n"},696042:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="float czm_private_getLambertDiffuseOfMaterial(vec3 lightDirectionEC, czm_material material)\n{\n    return czm_getLambertDiffuse(lightDirectionEC, material.normal);\n}\n\nfloat czm_private_getSpecularOfMaterial(vec3 lightDirectionEC, vec3 toEyeEC, czm_material material)\n{\n    return czm_getSpecular(lightDirectionEC, toEyeEC, material.normal, material.shininess);\n}\n\n/**\n * Computes a color using the Phong lighting model.\n *\n * @name czm_phong\n * @glslFunction\n *\n * @param {vec3} toEye A normalized vector from the fragment to the eye in eye coordinates.\n * @param {czm_material} material The fragment's material.\n *\n * @returns {vec4} The computed color.\n *\n * @example\n * vec3 positionToEyeEC = // ...\n * czm_material material = // ...\n * vec3 lightDirectionEC = // ...\n * out_FragColor = czm_phong(normalize(positionToEyeEC), material, lightDirectionEC);\n *\n * @see czm_getMaterial\n */\nvec4 czm_phong(vec3 toEye, czm_material material, vec3 lightDirectionEC)\n{\n    // Diffuse from directional light sources at eye (for top-down)\n    float diffuse = czm_private_getLambertDiffuseOfMaterial(vec3(0.0, 0.0, 1.0), material);\n    if (czm_sceneMode == czm_sceneMode3D) {\n        // (and horizon views in 3D)\n        diffuse += czm_private_getLambertDiffuseOfMaterial(vec3(0.0, 1.0, 0.0), material);\n    }\n\n    float specular = czm_private_getSpecularOfMaterial(lightDirectionEC, toEye, material);\n\n    // Temporary workaround for adding ambient.\n    vec3 materialDiffuse = material.diffuse * 0.5;\n\n    vec3 ambient = materialDiffuse;\n    vec3 color = ambient + material.emission;\n    color += materialDiffuse * diffuse * czm_lightColor;\n    color += material.specular * specular * czm_lightColor;\n\n    return vec4(color, material.alpha);\n}\n\nvec4 czm_private_phong(vec3 toEye, czm_material material, vec3 lightDirectionEC)\n{\n    float diffuse = czm_private_getLambertDiffuseOfMaterial(lightDirectionEC, material);\n    float specular = czm_private_getSpecularOfMaterial(lightDirectionEC, toEye, material);\n\n    vec3 ambient = vec3(0.0);\n    vec3 color = ambient + material.emission;\n    color += material.diffuse * diffuse * czm_lightColor;\n    color += material.specular * specular * czm_lightColor;\n\n    return vec4(color, material.alpha);\n}\n"},820121:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Computes distance from a point to a plane.\n *\n * @name czm_planeDistance\n * @glslFunction\n *\n * param {vec4} plane A Plane in Hessian Normal Form. See Plane.js\n * param {vec3} point A point in the same space as the plane.\n * returns {float} The distance from the point to the plane.\n */\nfloat czm_planeDistance(vec4 plane, vec3 point) {\n    return (dot(plane.xyz, point) + plane.w);\n}\n\n/**\n * Computes distance from a point to a plane.\n *\n * @name czm_planeDistance\n * @glslFunction\n *\n * param {vec3} planeNormal Normal for a plane in Hessian Normal Form. See Plane.js\n * param {float} planeDistance Distance for a plane in Hessian Normal form. See Plane.js\n * param {vec3} point A point in the same space as the plane.\n * returns {float} The distance from the point to the plane.\n */\nfloat czm_planeDistance(vec3 planeNormal, float planeDistance, vec3 point) {\n    return (dot(planeNormal, point) + planeDistance);\n}\n"},147769:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Computes the point along a ray at the given time.  <code>time</code> can be positive, negative, or zero.\n *\n * @name czm_pointAlongRay\n * @glslFunction\n *\n * @param {czm_ray} ray The ray to compute the point along.\n * @param {float} time The time along the ray.\n * \n * @returns {vec3} The point along the ray at the given time.\n * \n * @example\n * czm_ray ray = czm_ray(vec3(0.0), vec3(1.0, 0.0, 0.0)); // origin, direction\n * vec3 v = czm_pointAlongRay(ray, 2.0); // (2.0, 0.0, 0.0)\n */\nvec3 czm_pointAlongRay(czm_ray ray, float time)\n{\n    return ray.origin + (time * ray.direction);\n}\n"},394839:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * DOC_TBA\n *\n * @name czm_rayEllipsoidIntersectionInterval\n * @glslFunction\n */\nczm_raySegment czm_rayEllipsoidIntersectionInterval(czm_ray ray, vec3 ellipsoid_center, vec3 ellipsoid_inverseRadii)\n{\n   // ray and ellipsoid center in eye coordinates.  radii in model coordinates.\n    vec3 q = ellipsoid_inverseRadii * (czm_inverseModelView * vec4(ray.origin, 1.0)).xyz;\n    vec3 w = ellipsoid_inverseRadii * (czm_inverseModelView * vec4(ray.direction, 0.0)).xyz;\n\n    q = q - ellipsoid_inverseRadii * (czm_inverseModelView * vec4(ellipsoid_center, 1.0)).xyz;\n\n    float q2 = dot(q, q);\n    float qw = dot(q, w);\n\n    if (q2 > 1.0) // Outside ellipsoid.\n    {\n        if (qw >= 0.0) // Looking outward or tangent (0 intersections).\n        {\n            return czm_emptyRaySegment;\n        }\n        else // qw < 0.0.\n        {\n            float qw2 = qw * qw;\n            float difference = q2 - 1.0; // Positively valued.\n            float w2 = dot(w, w);\n            float product = w2 * difference;\n\n            if (qw2 < product) // Imaginary roots (0 intersections).\n            {\n                return czm_emptyRaySegment;\n            }\n            else if (qw2 > product) // Distinct roots (2 intersections).\n            {\n                float discriminant = qw * qw - product;\n                float temp = -qw + sqrt(discriminant); // Avoid cancellation.\n                float root0 = temp / w2;\n                float root1 = difference / temp;\n                if (root0 < root1)\n                {\n                    czm_raySegment i = czm_raySegment(root0, root1);\n                    return i;\n                }\n                else\n                {\n                    czm_raySegment i = czm_raySegment(root1, root0);\n                    return i;\n                }\n            }\n            else // qw2 == product.  Repeated roots (2 intersections).\n            {\n                float root = sqrt(difference / w2);\n                czm_raySegment i = czm_raySegment(root, root);\n                return i;\n            }\n        }\n    }\n    else if (q2 < 1.0) // Inside ellipsoid (2 intersections).\n    {\n        float difference = q2 - 1.0; // Negatively valued.\n        float w2 = dot(w, w);\n        float product = w2 * difference; // Negatively valued.\n        float discriminant = qw * qw - product;\n        float temp = -qw + sqrt(discriminant); // Positively valued.\n        czm_raySegment i = czm_raySegment(0.0, temp / w2);\n        return i;\n    }\n    else // q2 == 1.0. On ellipsoid.\n    {\n        if (qw < 0.0) // Looking inward.\n        {\n            float w2 = dot(w, w);\n            czm_raySegment i = czm_raySegment(0.0, -qw / w2);\n            return i;\n        }\n        else // qw >= 0.0.  Looking outward or tangent.\n        {\n            return czm_emptyRaySegment;\n        }\n    }\n}\n"},932901:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Compute the intersection interval of a ray with a sphere.\n *\n * @name czm_raySphereIntersectionInterval\n * @glslFunction\n *\n * @param {czm_ray} ray The ray.\n * @param {vec3} center The center of the sphere.\n * @param {float} radius The radius of the sphere.\n * @return {czm_raySegment} The intersection interval of the ray with the sphere.\n */\nczm_raySegment czm_raySphereIntersectionInterval(czm_ray ray, vec3 center, float radius)\n{\n    vec3 o = ray.origin;\n    vec3 d = ray.direction;\n\n    vec3 oc = o - center;\n\n    float a = dot(d, d);\n    float b = 2.0 * dot(d, oc);\n    float c = dot(oc, oc) - (radius * radius);\n\n    float det = (b * b) - (4.0 * a * c);\n\n    if (det < 0.0) {\n        return czm_emptyRaySegment;\n    }\n\n    float sqrtDet = sqrt(det);\n\n    float t0 = (-b - sqrtDet) / (2.0 * a);\n    float t1 = (-b + sqrtDet) / (2.0 * a);\n\n    czm_raySegment result = czm_raySegment(t0, t1);\n    return result;\n}\n"},527105:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="float czm_readDepth(sampler2D depthTexture, vec2 texCoords)\n{\n    return czm_reverseLogDepth(texture(depthTexture, texCoords).r);\n}\n"},916117:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Reads a value previously transformed with {@link czm_writeNonPerspective}\n * by dividing it by `w`, the value used in the perspective divide.\n * This function is intended to be called in a fragment shader to access a\n * `varying` that should not be subject to perspective interpolation.\n * For example, screen-space texture coordinates. The value should have been\n * previously written in the vertex shader with a call to\n * {@link czm_writeNonPerspective}.\n *\n * @name czm_readNonPerspective\n * @glslFunction\n *\n * @param {float|vec2|vec3|vec4} value The non-perspective value to be read.\n * @param {float} oneOverW One over the perspective divide value, `w`. Usually this is simply `gl_FragCoord.w`.\n * @returns {float|vec2|vec3|vec4} The usable value.\n */\nfloat czm_readNonPerspective(float value, float oneOverW) {\n    return value * oneOverW;\n}\n\nvec2 czm_readNonPerspective(vec2 value, float oneOverW) {\n    return value * oneOverW;\n}\n\nvec3 czm_readNonPerspective(vec3 value, float oneOverW) {\n    return value * oneOverW;\n}\n\nvec4 czm_readNonPerspective(vec4 value, float oneOverW) {\n    return value * oneOverW;\n}\n"},755541:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="float czm_reverseLogDepth(float logZ)\n{\n#ifdef LOG_DEPTH\n    float near = czm_currentFrustum.x;\n    float far = czm_currentFrustum.y;\n    float log2Depth = logZ * czm_log2FarDepthFromNearPlusOne;\n    float depthFromNear = exp2(log2Depth) - 1.0;\n    return far * (1.0 - near / (depthFromNear + near)) / (far - near);\n#endif\n    return logZ;\n}\n"},463540:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Round a floating point value. This function exists because round() doesn't\n * exist in GLSL 1.00. \n *\n * @param {float|vec2|vec3|vec4} value The value to round\n * @param {float|vec2|vec3|vec3} The rounded value. The type matches the input.\n */\nfloat czm_round(float value) {\n  return floor(value + 0.5);\n}\n\nvec2 czm_round(vec2 value) {\n  return floor(value + 0.5);\n}\n\nvec3 czm_round(vec3 value) {\n  return floor(value + 0.5);\n}\n\nvec4 czm_round(vec4 value) {\n  return floor(value + 0.5);\n}\n"},199494:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Adjusts the saturation of a color.\n * \n * @name czm_saturation\n * @glslFunction\n * \n * @param {vec3} rgb The color.\n * @param {float} adjustment The amount to adjust the saturation of the color.\n *\n * @returns {float} The color with the saturation adjusted.\n *\n * @example\n * vec3 greyScale = czm_saturation(color, 0.0);\n * vec3 doubleSaturation = czm_saturation(color, 2.0);\n */\nvec3 czm_saturation(vec3 rgb, float adjustment)\n{\n    // Algorithm from Chapter 16 of OpenGL Shading Language\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n    vec3 intensity = vec3(dot(rgb, W));\n    return mix(intensity, rgb, adjustment);\n}\n"},82914:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="\nfloat czm_sampleShadowMap(highp samplerCube shadowMap, vec3 d)\n{\n    return czm_unpackDepth(czm_textureCube(shadowMap, d));\n}\n\nfloat czm_sampleShadowMap(highp sampler2D shadowMap, vec2 uv)\n{\n#ifdef USE_SHADOW_DEPTH_TEXTURE\n    return texture(shadowMap, uv).r;\n#else\n    return czm_unpackDepth(texture(shadowMap, uv));\n#endif\n}\n\nfloat czm_shadowDepthCompare(samplerCube shadowMap, vec3 uv, float depth)\n{\n    return step(depth, czm_sampleShadowMap(shadowMap, uv));\n}\n\nfloat czm_shadowDepthCompare(sampler2D shadowMap, vec2 uv, float depth)\n{\n    return step(depth, czm_sampleShadowMap(shadowMap, uv));\n}\n"},568758:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="\nfloat czm_private_shadowVisibility(float visibility, float nDotL, float normalShadingSmooth, float darkness)\n{\n#ifdef USE_NORMAL_SHADING\n#ifdef USE_NORMAL_SHADING_SMOOTH\n    float strength = clamp(nDotL / normalShadingSmooth, 0.0, 1.0);\n#else\n    float strength = step(0.0, nDotL);\n#endif\n    visibility *= strength;\n#endif\n\n    visibility = max(visibility, darkness);\n    return visibility;\n}\n\n#ifdef USE_CUBE_MAP_SHADOW\nfloat czm_shadowVisibility(samplerCube shadowMap, czm_shadowParameters shadowParameters)\n{\n    float depthBias = shadowParameters.depthBias;\n    float depth = shadowParameters.depth;\n    float nDotL = shadowParameters.nDotL;\n    float normalShadingSmooth = shadowParameters.normalShadingSmooth;\n    float darkness = shadowParameters.darkness;\n    vec3 uvw = shadowParameters.texCoords;\n\n    depth -= depthBias;\n    float visibility = czm_shadowDepthCompare(shadowMap, uvw, depth);\n    return czm_private_shadowVisibility(visibility, nDotL, normalShadingSmooth, darkness);\n}\n#else\nfloat czm_shadowVisibility(sampler2D shadowMap, czm_shadowParameters shadowParameters)\n{\n    float depthBias = shadowParameters.depthBias;\n    float depth = shadowParameters.depth;\n    float nDotL = shadowParameters.nDotL;\n    float normalShadingSmooth = shadowParameters.normalShadingSmooth;\n    float darkness = shadowParameters.darkness;\n    vec2 uv = shadowParameters.texCoords;\n\n    depth -= depthBias;\n#ifdef USE_SOFT_SHADOWS\n    vec2 texelStepSize = shadowParameters.texelStepSize;\n    float radius = 1.0;\n    float dx0 = -texelStepSize.x * radius;\n    float dy0 = -texelStepSize.y * radius;\n    float dx1 = texelStepSize.x * radius;\n    float dy1 = texelStepSize.y * radius;\n    float visibility = (\n        czm_shadowDepthCompare(shadowMap, uv, depth) +\n        czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy0), depth) +\n        czm_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy0), depth) +\n        czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy0), depth) +\n        czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, 0.0), depth) +\n        czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, 0.0), depth) +\n        czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy1), depth) +\n        czm_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy1), depth) +\n        czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy1), depth)\n    ) * (1.0 / 9.0);\n#else\n    float visibility = czm_shadowDepthCompare(shadowMap, uv, depth);\n#endif\n\n    return czm_private_shadowVisibility(visibility, nDotL, normalShadingSmooth, darkness);\n}\n#endif\n"},562348:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Returns 1.0 if the given value is positive or zero, and -1.0 if it is negative.  This is similar to the GLSL\n * built-in function <code>sign</code> except that returns 1.0 instead of 0.0 when the input value is 0.0.\n * \n * @name czm_signNotZero\n * @glslFunction\n *\n * @param {} value The value for which to determine the sign.\n * @returns {} 1.0 if the value is positive or zero, -1.0 if the value is negative.\n */\nfloat czm_signNotZero(float value)\n{\n    return value >= 0.0 ? 1.0 : -1.0;\n}\n\nvec2 czm_signNotZero(vec2 value)\n{\n    return vec2(czm_signNotZero(value.x), czm_signNotZero(value.y));\n}\n\nvec3 czm_signNotZero(vec3 value)\n{\n    return vec3(czm_signNotZero(value.x), czm_signNotZero(value.y), czm_signNotZero(value.z));\n}\n\nvec4 czm_signNotZero(vec4 value)\n{\n    return vec4(czm_signNotZero(value.x), czm_signNotZero(value.y), czm_signNotZero(value.z), czm_signNotZero(value.w));\n}\n"},19687:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Computes a color from the third order spherical harmonic coefficients and a normalized direction vector.\n * <p>\n * The order of the coefficients is [L00, L1_1, L10, L11, L2_2, L2_1, L20, L21, L22].\n * </p>\n *\n * @name czm_sphericalHarmonics\n * @glslFunction\n *\n * @param {vec3} normal The normalized direction.\n * @param {vec3[9]} coefficients The third order spherical harmonic coefficients.\n * @returns {vec3} The color at the direction.\n *\n * @see https://graphics.stanford.edu/papers/envmap/envmap.pdf\n */\nvec3 czm_sphericalHarmonics(vec3 normal, vec3 coefficients[9])\n{\n    vec3 L00 = coefficients[0];\n    vec3 L1_1 = coefficients[1];\n    vec3 L10 = coefficients[2];\n    vec3 L11 = coefficients[3];\n    vec3 L2_2 = coefficients[4];\n    vec3 L2_1 = coefficients[5];\n    vec3 L20 = coefficients[6];\n    vec3 L21 = coefficients[7];\n    vec3 L22 = coefficients[8];\n\n    float x = normal.x;\n    float y = normal.y;\n    float z = normal.z;\n\n    vec3 L =\n          L00\n        + L1_1 * y\n        + L10 * z\n        + L11 * x\n        + L2_2 * (y * x)\n        + L2_1 * (y * z)\n        + L20 * (3.0 * z * z - 1.0)\n        + L21 * (z * x)\n        + L22 * (x * x - y * y);\n        \n    return max(L, vec3(0.0));\n}\n"},501738:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Converts an sRGB color to a linear RGB color.\n *\n * @param {vec3|vec4} srgbIn The color in sRGB space\n * @returns {vec3|vec4} The color in linear color space. The vector type matches the input.\n */\nvec3 czm_srgbToLinear(vec3 srgbIn)\n{\n    return pow(srgbIn, vec3(2.2));\n}\n\nvec4 czm_srgbToLinear(vec4 srgbIn) \n{\n    vec3 linearOut = pow(srgbIn.rgb, vec3(2.2));\n    return vec4(linearOut, srgbIn.a);\n}\n"},660164:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Creates a matrix that transforms vectors from tangent space to eye space.\n *\n * @name czm_tangentToEyeSpaceMatrix\n * @glslFunction\n *\n * @param {vec3} normalEC The normal vector in eye coordinates.\n * @param {vec3} tangentEC The tangent vector in eye coordinates.\n * @param {vec3} bitangentEC The bitangent vector in eye coordinates.\n *\n * @returns {mat3} The matrix that transforms from tangent space to eye space.\n *\n * @example\n * mat3 tangentToEye = czm_tangentToEyeSpaceMatrix(normalEC, tangentEC, bitangentEC);\n * vec3 normal = tangentToEye * texture(normalMap, st).xyz;\n */\nmat3 czm_tangentToEyeSpaceMatrix(vec3 normalEC, vec3 tangentEC, vec3 bitangentEC)\n{\n    vec3 normal = normalize(normalEC);\n    vec3 tangent = normalize(tangentEC);\n    vec3 bitangent = normalize(bitangentEC);\n    return mat3(tangent.x  , tangent.y  , tangent.z,\n                bitangent.x, bitangent.y, bitangent.z,\n                normal.x   , normal.y   , normal.z);\n}\n"},480262:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * A wrapper around the texture (WebGL2) / textureCube (WebGL1)\n * function to allow for WebGL 1 support.\n * \n * @name czm_textureCube\n * @glslFunction\n *\n * @param {samplerCube} sampler The sampler.\n * @param {vec3} p The coordinate at which to sample the texture.\n */\nvec4 czm_textureCube(samplerCube sampler, vec3 p) {\n#if __VERSION__ == 300\n    return texture(sampler, p);\n#else\n    return textureCube(sampler, p);\n#endif\n}\n\n/**\n * A wrapper around the textureLod (WebGL2) / textureCube (WebGL1)\n * function to allow for WebGL 1 support in fragment shaders.\n *\n * @name czm_textureCubeLod\n * @glslFunction\n *\n * @param {samplerCube} sampler The sampler.\n * @param {vec3} p The coordinate at which to sample the texture.\n * @param {float} lod The mipmap level from which to sample.\n */\nvec4 czm_textureCube(samplerCube sampler, vec3 p, float lod) {\n#if __VERSION__ == 300\n    return textureLod(sampler, p, lod);\n#elif defined(GL_EXT_shader_texture_lod)\n    return textureCubeLodEXT(sampler, p, lod);\n#endif\n}"},608860:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Transforms a plane.\n * \n * @name czm_transformPlane\n * @glslFunction\n *\n * @param {vec4} plane The plane in Hessian Normal Form.\n * @param {mat4} transform The inverse-transpose of a transformation matrix.\n */\nvec4 czm_transformPlane(vec4 plane, mat4 transform) {\n    vec4 transformedPlane = transform * plane;\n    // Convert the transformed plane to Hessian Normal Form\n    float normalMagnitude = length(transformedPlane.xyz);\n    return transformedPlane / normalMagnitude;\n}\n"},980902:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Translates a position (or any <code>vec3</code>) that was encoded with {@link EncodedCartesian3},\n * and then provided to the shader as separate <code>high</code> and <code>low</code> bits to\n * be relative to the eye.  As shown in the example, the position can then be transformed in eye\n * or clip coordinates using {@link czm_modelViewRelativeToEye} or {@link czm_modelViewProjectionRelativeToEye},\n * respectively.\n * <p>\n * This technique, called GPU RTE, eliminates jittering artifacts when using large coordinates as\n * described in {@link http://help.agi.com/AGIComponents/html/BlogPrecisionsPrecisions.htm|Precisions, Precisions}.\n * </p>\n *\n * @name czm_translateRelativeToEye\n * @glslFunction\n *\n * @param {vec3} high The position's high bits.\n * @param {vec3} low The position's low bits.\n * @returns {vec3} The position translated to be relative to the camera's position.\n *\n * @example\n * in vec3 positionHigh;\n * in vec3 positionLow;\n *\n * void main()\n * {\n *   vec4 p = czm_translateRelativeToEye(positionHigh, positionLow);\n *   gl_Position = czm_modelViewProjectionRelativeToEye * p;\n * }\n *\n * @see czm_modelViewRelativeToEye\n * @see czm_modelViewProjectionRelativeToEye\n * @see czm_computePosition\n * @see EncodedCartesian3\n */\nvec4 czm_translateRelativeToEye(vec3 high, vec3 low)\n{\n    vec3 highDifference = high - czm_encodedCameraPositionMCHigh;\n    // This check handles the case when NaN values have gotten into `highDifference`.\n    // Such a thing could happen on devices running iOS.\n    if (length(highDifference) == 0.0) {  \n        highDifference = vec3(0);  \n    }\n    vec3 lowDifference = low - czm_encodedCameraPositionMCLow;\n\n    return vec4(highDifference + lowDifference, 1.0);\n}\n"},367309:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * @private\n */\nvec4 czm_translucentPhong(vec3 toEye, czm_material material, vec3 lightDirectionEC)\n{\n    // Diffuse from directional light sources at eye (for top-down and horizon views)\n    float diffuse = czm_getLambertDiffuse(vec3(0.0, 0.0, 1.0), material.normal);\n\n    if (czm_sceneMode == czm_sceneMode3D) {\n        // (and horizon views in 3D)\n        diffuse += czm_getLambertDiffuse(vec3(0.0, 1.0, 0.0), material.normal);\n    }\n\n    diffuse = clamp(diffuse, 0.0, 1.0);\n\n    float specular = czm_getSpecular(lightDirectionEC, toEye, material.normal, material.shininess);\n\n    // Temporary workaround for adding ambient.\n    vec3 materialDiffuse = material.diffuse * 0.5;\n\n    vec3 ambient = materialDiffuse;\n    vec3 color = ambient + material.emission;\n    color += materialDiffuse * diffuse * czm_lightColor;\n    color += material.specular * specular * czm_lightColor;\n\n    return vec4(color, material.alpha);\n}\n"},880691:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Returns the transpose of the matrix.  The input <code>matrix</code> can be\n * a <code>mat2</code>, <code>mat3</code>, or <code>mat4</code>.\n *\n * @name czm_transpose\n * @glslFunction\n *\n * @param {} matrix The matrix to transpose.\n *\n * @returns {} The transposed matrix.\n *\n * @example\n * // GLSL declarations\n * mat2 czm_transpose(mat2 matrix);\n * mat3 czm_transpose(mat3 matrix);\n * mat4 czm_transpose(mat4 matrix);\n *\n * // Transpose a 3x3 rotation matrix to find its inverse.\n * mat3 eastNorthUpToEye = czm_eastNorthUpToEyeCoordinates(\n *     positionMC, normalEC);\n * mat3 eyeToEastNorthUp = czm_transpose(eastNorthUpToEye);\n */\nmat2 czm_transpose(mat2 matrix)\n{\n    return mat2(\n        matrix[0][0], matrix[1][0],\n        matrix[0][1], matrix[1][1]);\n}\n\nmat3 czm_transpose(mat3 matrix)\n{\n    return mat3(\n        matrix[0][0], matrix[1][0], matrix[2][0],\n        matrix[0][1], matrix[1][1], matrix[2][1],\n        matrix[0][2], matrix[1][2], matrix[2][2]);\n}\n\nmat4 czm_transpose(mat4 matrix)\n{\n    return mat4(\n        matrix[0][0], matrix[1][0], matrix[2][0], matrix[3][0],\n        matrix[0][1], matrix[1][1], matrix[2][1], matrix[3][1],\n        matrix[0][2], matrix[1][2], matrix[2][2], matrix[3][2],\n        matrix[0][3], matrix[1][3], matrix[2][3], matrix[3][3]);\n}\n"},648777:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="vec2 getLookupUv(vec2 dimensions, int i) {\n    int pixY = i / int(dimensions.x);\n    int pixX = i - (pixY * int(dimensions.x));\n    float pixelWidth = 1.0 / dimensions.x;\n    float pixelHeight = 1.0 / dimensions.y;\n    float u = (float(pixX) + 0.5) * pixelWidth; // sample from center of pixel\n    float v = (float(pixY) + 0.5) * pixelHeight;\n    return vec2(u, v);\n}\n\nvec4 czm_unpackClippingExtents(highp sampler2D extentsTexture, int index) {\n    vec2 textureDimensions = vec2(textureSize(extentsTexture, 0));\n    return texture(extentsTexture, getLookupUv(textureDimensions, index));\n}"},231511:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Unpacks a vec4 depth value to a float in [0, 1) range.\n *\n * @name czm_unpackDepth\n * @glslFunction\n *\n * @param {vec4} packedDepth The packed depth.\n *\n * @returns {float} The floating-point depth in [0, 1) range.\n */\nfloat czm_unpackDepth(vec4 packedDepth)\n{\n    // See Aras Pranckeviius' post Encoding Floats to RGBA\n    // http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\n    return dot(packedDepth, vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n}\n"},293752:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Unpack an IEEE 754 single-precision float that is packed as a little-endian unsigned normalized vec4.\n *\n * @name czm_unpackFloat\n * @glslFunction\n *\n * @param {vec4} packedFloat The packed float.\n *\n * @returns {float} The floating-point depth in arbitrary range.\n */\nfloat czm_unpackFloat(vec4 packedFloat)\n{\n    // Convert to [0.0, 255.0] and round to integer\n    packedFloat = floor(packedFloat * 255.0 + 0.5);\n    float sign = 1.0 - step(128.0, packedFloat[3]) * 2.0;\n    float exponent = 2.0 * mod(packedFloat[3], 128.0) + step(128.0, packedFloat[2]) - 127.0;    \n    if (exponent == -127.0)\n    {\n        return 0.0;\n    }\n    float mantissa = mod(packedFloat[2], 128.0) * 65536.0 + packedFloat[1] * 256.0 + packedFloat[0] + float(0x800000);\n    float result = sign * exp2(exponent - 23.0) * mantissa;\n    return result;\n}\n"},617172:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Unpack unsigned integers of 1-4 bytes. in WebGL 1, there is no uint type,\n * so the return value is an int.\n * <p>\n * There are also precision limitations in WebGL 1. highp int is still limited\n * to 24 bits. Above the value of 2^24 = 16777216, precision loss may occur.\n * </p>\n *\n * @param {float|vec2|vec3|vec4} packed The packed value. For vectors, the components are listed in little-endian order.\n *\n * @return {int} The unpacked value.\n */\n int czm_unpackUint(float packedValue) {\n   float rounded = czm_round(packedValue * 255.0);\n   return int(rounded);\n }\n\n int czm_unpackUint(vec2 packedValue) {\n   vec2 rounded = czm_round(packedValue * 255.0);\n   return int(dot(rounded, vec2(1.0, 256.0)));\n }\n\n int czm_unpackUint(vec3 packedValue) {\n   vec3 rounded = czm_round(packedValue * 255.0);\n   return int(dot(rounded, vec3(1.0, 256.0, 65536.0)));\n }\n\n int czm_unpackUint(vec4 packedValue) {\n   vec4 rounded = czm_round(packedValue * 255.0);\n   return int(dot(rounded, vec4(1.0, 256.0, 65536.0, 16777216.0)));\n }\n"},169513:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Transform metadata values following the EXT_structural_metadata spec\n * by multiplying by scale and adding the offset. Operations are always\n * performed component-wise, even for matrices.\n * \n * @param {float|vec2|vec3|vec4|mat2|mat3|mat4} offset The offset to add\n * @param {float|vec2|vec3|vec4|mat2|mat3|mat4} scale The scale factor to multiply\n * @param {float|vec2|vec3|vec4|mat2|mat3|mat4} value The original value.\n *\n * @return {float|vec2|vec3|vec4|mat2|mat3|mat4} The transformed value of the same scalar/vector/matrix type as the input.\n */\nfloat czm_valueTransform(float offset, float scale, float value) {\n  return scale * value + offset;\n}\n\nvec2 czm_valueTransform(vec2 offset, vec2 scale, vec2 value) {\n  return scale * value + offset;\n}\n\nvec3 czm_valueTransform(vec3 offset, vec3 scale, vec3 value) {\n  return scale * value + offset;\n}\n\nvec4 czm_valueTransform(vec4 offset, vec4 scale, vec4 value) {\n  return scale * value + offset;\n}\n\nmat2 czm_valueTransform(mat2 offset, mat2 scale, mat2 value) {\n  return matrixCompMult(scale, value) + offset;\n}\n\nmat3 czm_valueTransform(mat3 offset, mat3 scale, mat3 value) {\n  return matrixCompMult(scale, value) + offset;\n}\n\nmat4 czm_valueTransform(mat4 offset, mat4 scale, mat4 value) {\n  return matrixCompMult(scale, value) + offset;\n}\n"},720547:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="#ifdef LOG_DEPTH\n// 1.0 at the near plane, increasing linearly from there.\nout float v_depthFromNearPlusOne;\n#ifdef SHADOW_MAP\nout vec3 v_logPositionEC;\n#endif\n#endif\n\nvec4 czm_updatePositionDepth(vec4 coords) {\n#if defined(LOG_DEPTH)\n\n#ifdef SHADOW_MAP\n    vec3 logPositionEC = (czm_inverseProjection * coords).xyz;\n    v_logPositionEC = logPositionEC;\n#endif\n\n    // With the very high far/near ratios used with the logarithmic depth\n    // buffer, floating point rounding errors can cause linear depth values\n    // to end up on the wrong side of the far plane, even for vertices that\n    // are really nowhere near it. Since we always write a correct logarithmic\n    // depth value in the fragment shader anyway, we just need to make sure\n    // such errors don't cause the primitive to be clipped entirely before\n    // we even get to the fragment shader.\n    coords.z = clamp(coords.z / coords.w, -1.0, 1.0) * coords.w;\n#endif\n\n    return coords;\n}\n\n/**\n * Writes the logarithmic depth to gl_Position using the already computed gl_Position.\n *\n * @name czm_vertexLogDepth\n * @glslFunction\n */\nvoid czm_vertexLogDepth()\n{\n#ifdef LOG_DEPTH\n    v_depthFromNearPlusOne = (gl_Position.w - czm_currentFrustum.x) + 1.0;\n    gl_Position = czm_updatePositionDepth(gl_Position);\n#endif\n}\n\n/**\n * Writes the logarithmic depth to gl_Position using the provided clip coordinates.\n * <p>\n * An example use case for this function would be moving the vertex in window coordinates\n * before converting back to clip coordinates. Use the original vertex clip coordinates.\n * </p>\n * @name czm_vertexLogDepth\n * @glslFunction\n *\n * @param {vec4} clipCoords The vertex in clip coordinates.\n *\n * @example\n * czm_vertexLogDepth(czm_projection * vec4(positionEyeCoordinates, 1.0));\n */\nvoid czm_vertexLogDepth(vec4 clipCoords)\n{\n#ifdef LOG_DEPTH\n    v_depthFromNearPlusOne = (clipCoords.w - czm_currentFrustum.x) + 1.0;\n    czm_updatePositionDepth(clipCoords);\n#endif\n}\n"},584783:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="vec4 czm_screenToEyeCoordinates(vec4 screenCoordinate)\n{\n    // Reconstruct NDC coordinates\n    float x = 2.0 * screenCoordinate.x - 1.0;\n    float y = 2.0 * screenCoordinate.y - 1.0;\n    float z = (screenCoordinate.z - czm_viewportTransformation[3][2]) / czm_viewportTransformation[2][2];\n    vec4 q = vec4(x, y, z, 1.0);\n\n    // Reverse the perspective division to obtain clip coordinates.\n    q /= screenCoordinate.w;\n\n    // Reverse the projection transformation to obtain eye coordinates.\n    if (!(czm_inverseProjection == mat4(0.0))) // IE and Edge sometimes do something weird with != between mat4s\n    {\n        q = czm_inverseProjection * q;\n    }\n    else\n    {\n        float top = czm_frustumPlanes.x;\n        float bottom = czm_frustumPlanes.y;\n        float left = czm_frustumPlanes.z;\n        float right = czm_frustumPlanes.w;\n\n        float near = czm_currentFrustum.x;\n        float far = czm_currentFrustum.y;\n\n        q.x = (q.x * (right - left) + left + right) * 0.5;\n        q.y = (q.y * (top - bottom) + bottom + top) * 0.5;\n        q.z = (q.z * (near - far) - near - far) * 0.5;\n        q.w = 1.0;\n    }\n\n    return q;\n}\n\n/**\n * Transforms a position from window to eye coordinates.\n * The transform from window to normalized device coordinates is done using components\n * of (@link czm_viewport} and {@link czm_viewportTransformation} instead of calculating\n * the inverse of <code>czm_viewportTransformation</code>. The transformation from\n * normalized device coordinates to clip coordinates is done using <code>fragmentCoordinate.w</code>,\n * which is expected to be the scalar used in the perspective divide. The transformation\n * from clip to eye coordinates is done using {@link czm_inverseProjection}.\n *\n * @name czm_windowToEyeCoordinates\n * @glslFunction\n *\n * @param {vec4} fragmentCoordinate The position in window coordinates to transform.\n *\n * @returns {vec4} The transformed position in eye coordinates.\n *\n * @see czm_modelToWindowCoordinates\n * @see czm_eyeToWindowCoordinates\n * @see czm_inverseProjection\n * @see czm_viewport\n * @see czm_viewportTransformation\n *\n * @example\n * vec4 positionEC = czm_windowToEyeCoordinates(gl_FragCoord);\n */\nvec4 czm_windowToEyeCoordinates(vec4 fragmentCoordinate)\n{\n    vec2 screenCoordXY = (fragmentCoordinate.xy - czm_viewport.xy) / czm_viewport.zw;\n    return czm_screenToEyeCoordinates(vec4(screenCoordXY, fragmentCoordinate.zw));\n}\n\nvec4 czm_screenToEyeCoordinates(vec2 screenCoordinateXY, float depthOrLogDepth)\n{\n    // See reverseLogDepth.glsl. This is separate to re-use the pow.\n#if defined(LOG_DEPTH) || defined(LOG_DEPTH_READ_ONLY)\n    float near = czm_currentFrustum.x;\n    float far = czm_currentFrustum.y;\n    float log2Depth = depthOrLogDepth * czm_log2FarDepthFromNearPlusOne;\n    float depthFromNear = exp2(log2Depth) - 1.0;\n    float depthFromCamera = depthFromNear + near;\n    vec4 screenCoord = vec4(screenCoordinateXY, far * (1.0 - near / depthFromCamera) / (far - near), 1.0);\n    vec4 eyeCoordinate = czm_screenToEyeCoordinates(screenCoord);\n    eyeCoordinate.w = 1.0 / depthFromCamera; // Better precision\n#else\n    vec4 screenCoord = vec4(screenCoordinateXY, depthOrLogDepth, 1.0);\n    vec4 eyeCoordinate = czm_screenToEyeCoordinates(screenCoord);\n#endif\n    return eyeCoordinate;\n}\n\n/**\n * Transforms a position given as window x/y and a depth or a log depth from window to eye coordinates.\n * This function produces more accurate results for window positions with log depth than\n * conventionally unpacking the log depth using czm_reverseLogDepth and using the standard version\n * of czm_windowToEyeCoordinates.\n *\n * @name czm_windowToEyeCoordinates\n * @glslFunction\n *\n * @param {vec2} fragmentCoordinateXY The XY position in window coordinates to transform.\n * @param {float} depthOrLogDepth A depth or log depth for the fragment.\n *\n * @see czm_modelToWindowCoordinates\n * @see czm_eyeToWindowCoordinates\n * @see czm_inverseProjection\n * @see czm_viewport\n * @see czm_viewportTransformation\n *\n * @returns {vec4} The transformed position in eye coordinates.\n */\nvec4 czm_windowToEyeCoordinates(vec2 fragmentCoordinateXY, float depthOrLogDepth)\n{\n    vec2 screenCoordXY = (fragmentCoordinateXY.xy - czm_viewport.xy) / czm_viewport.zw;\n    return czm_screenToEyeCoordinates(screenCoordXY, depthOrLogDepth);\n}\n"},10451:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="// emulated noperspective\n#if !defined(LOG_DEPTH)\nin float v_WindowZ;\n#endif\n\n/**\n * Emulates GL_DEPTH_CLAMP. Clamps a fragment to the near and far plane\n * by writing the fragment's depth. See czm_depthClamp for more details.\n *\n * @name czm_writeDepthClamp\n * @glslFunction\n *\n * @example\n * out_FragColor = color;\n * czm_writeDepthClamp();\n *\n * @see czm_depthClamp\n */\nvoid czm_writeDepthClamp()\n{\n#if (!defined(LOG_DEPTH) && (__VERSION__ == 300 || defined(GL_EXT_frag_depth)))\n    gl_FragDepth = clamp(v_WindowZ * gl_FragCoord.w, 0.0, 1.0);\n#endif\n}\n"},237688:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="#ifdef LOG_DEPTH\nin float v_depthFromNearPlusOne;\n\n#ifdef POLYGON_OFFSET\nuniform vec2 u_polygonOffset;\n#endif\n\n#endif\n\n/**\n * Writes the fragment depth to the logarithmic depth buffer.\n * <p>\n * Use this when the vertex shader does not call {@link czm_vertexLogDepth}, for example, when\n * ray-casting geometry using a full screen quad.\n * </p>\n * @name czm_writeLogDepth\n * @glslFunction\n *\n * @param {float} depth The depth coordinate, where 1.0 is on the near plane and\n *                      depth increases in eye-space units from there\n *\n * @example\n * czm_writeLogDepth((czm_projection * v_positionEyeCoordinates).w + 1.0);\n */\nvoid czm_writeLogDepth(float depth)\n{\n#if (defined(LOG_DEPTH) && (__VERSION__ == 300 || defined(GL_EXT_frag_depth)))\n    // Discard the vertex if it's not between the near and far planes.\n    // We allow a bit of epsilon on the near plane comparison because a 1.0\n    // from the vertex shader (indicating the vertex should be _on_ the near\n    // plane) will not necessarily come here as exactly 1.0.\n    if (depth <= 0.9999999 || depth > czm_farDepthFromNearPlusOne) {\n        discard;\n    }\n\n#ifdef POLYGON_OFFSET\n    // Polygon offset: m * factor + r * units\n    float factor = u_polygonOffset[0];\n    float units = u_polygonOffset[1];\n\n#if (__VERSION__ == 300 || defined(GL_OES_standard_derivatives))\n    // This factor doesn't work in IE 10\n    if (factor != 0.0) {\n        // m = sqrt(dZdX^2 + dZdY^2);\n        float x = dFdx(depth);\n        float y = dFdy(depth);\n        float m = sqrt(x * x + y * y);\n\n        // Apply the factor before computing the log depth.\n        depth += m * factor;\n    }\n#endif\n\n#endif\n\n    gl_FragDepth = log2(depth) * czm_oneOverLog2FarDepthFromNearPlusOne;\n\n#ifdef POLYGON_OFFSET\n    // Apply the units after the log depth.\n    gl_FragDepth += czm_epsilon7 * units;\n#endif\n\n#endif\n}\n\n/**\n * Writes the fragment depth to the logarithmic depth buffer.\n * <p>\n * Use this when the vertex shader calls {@link czm_vertexLogDepth}.\n * </p>\n *\n * @name czm_writeLogDepth\n * @glslFunction\n */\nvoid czm_writeLogDepth() {\n#ifdef LOG_DEPTH\n    czm_writeLogDepth(v_depthFromNearPlusOne);\n#endif\n}\n"},322556:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Transforms a value for non-perspective interpolation by multiplying\n * it by w, the value used in the perspective divide. This function is\n * intended to be called in a vertex shader to compute the value of a\n * `varying` that should not be subject to perspective interpolation.\n * For example, screen-space texture coordinates. The fragment shader\n * must call {@link czm_readNonPerspective} to retrieve the final\n * non-perspective value.\n *\n * @name czm_writeNonPerspective\n * @glslFunction\n *\n * @param {float|vec2|vec3|vec4} value The value to be interpolated without accounting for perspective.\n * @param {float} w The perspective divide value. Usually this is the computed `gl_Position.w`.\n * @returns {float|vec2|vec3|vec4} The transformed value, intended to be stored in a `varying` and read in the\n *          fragment shader with {@link czm_readNonPerspective}.\n */\nfloat czm_writeNonPerspective(float value, float w) {\n    return value * w;\n}\n\nvec2 czm_writeNonPerspective(vec2 value, float w) {\n    return value * w;\n}\n\nvec3 czm_writeNonPerspective(vec3 value, float w) {\n    return value * w;\n}\n\nvec4 czm_writeNonPerspective(vec4 value, float w) {\n    return value * w;\n}\n"},30284:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * @name czm_depthRangeStruct\n * @glslStruct\n */\nstruct czm_depthRangeStruct\n{\n    float near;\n    float far;\n};\n"},851714:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Holds material information that can be used for lighting. Returned by all czm_getMaterial functions.\n *\n * @name czm_material\n * @glslStruct\n *\n * @property {vec3} diffuse Incoming light that scatters evenly in all directions.\n * @property {float} specular Intensity of incoming light reflecting in a single direction.\n * @property {float} shininess The sharpness of the specular reflection.  Higher values create a smaller, more focused specular highlight.\n * @property {vec3} normal Surface's normal in eye coordinates. It is used for effects such as normal mapping. The default is the surface's unmodified normal.\n * @property {vec3} emission Light emitted by the material equally in all directions. The default is vec3(0.0), which emits no light.\n * @property {float} alpha Alpha of this material. 0.0 is completely transparent; 1.0 is completely opaque.\n */\nstruct czm_material\n{\n    vec3 diffuse;\n    float specular;\n    float shininess;\n    vec3 normal;\n    vec3 emission;\n    float alpha;\n};\n"},423340:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Used as input to every material's czm_getMaterial function.\n *\n * @name czm_materialInput\n * @glslStruct\n *\n * @property {float} s 1D texture coordinates.\n * @property {vec2} st 2D texture coordinates.\n * @property {vec3} str 3D texture coordinates.\n * @property {vec3} normalEC Unperturbed surface normal in eye coordinates.\n * @property {mat3} tangentToEyeMatrix Matrix for converting a tangent space normal to eye space.\n * @property {vec3} positionToEyeEC Vector from the fragment to the eye in eye coordinates.  The magnitude is the distance in meters from the fragment to the eye.\n * @property {float} height The height of the terrain in meters above or below the ellipsoid.  Only available for globe materials.\n * @property {float} slope The slope of the terrain in radians.  0 is flat; pi/2 is vertical.  Only available for globe materials.\n * @property {float} aspect The aspect of the terrain in radians.  0 is East, pi/2 is North, pi is West, 3pi/2 is South.  Only available for globe materials.\n* @property {float} waterMask The value of the water mask. 0 is land, 1 is water. Only available for globe materials.\n */\nstruct czm_materialInput\n{\n    float s;\n    vec2 st;\n    vec3 str;\n    vec3 normalEC;\n    mat3 tangentToEyeMatrix;\n    vec3 positionToEyeEC;\n    float height;\n    float slope;\n    float aspect;\n    float waterMask;\n};\n"},416407:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Struct for representing a material for a {@link Model}. The model\n * rendering pipeline will pass this struct between material, custom shaders,\n * and lighting stages. This is not to be confused with {@link czm_material}\n * which is used by the older Fabric materials system, although they are similar.\n * <p>\n * All color values (diffuse, specular, emissive) are in linear color space.\n * </p>\n *\n * @name czm_modelMaterial\n * @glslStruct\n *\n * @property {vec4} baseColor The base color of the material.\n * @property {vec3} diffuse Incoming light that scatters evenly in all directions.\n * @property {float} alpha Alpha of this material. 0.0 is completely transparent; 1.0 is completely opaque.\n * @property {vec3} specular Color of reflected light at normal incidence in PBR materials. This is sometimes referred to as f0 in the literature.\n * @property {float} roughness A number from 0.0 to 1.0 representing how rough the surface is. Values near 0.0 produce glossy surfaces, while values near 1.0 produce rough surfaces.\n * @property {vec3} normalEC Surface's normal in eye coordinates. It is used for effects such as normal mapping. The default is the surface's unmodified normal.\n * @property {float} occlusion Ambient occlusion recieved at this point on the material. 1.0 means fully lit, 0.0 means fully occluded.\n * @property {vec3} emissive Light emitted by the material equally in all directions. The default is vec3(0.0), which emits no light.\n */\nstruct czm_modelMaterial {\n    vec4 baseColor;\n    vec3 diffuse;\n    float alpha;\n    vec3 specular;\n    float roughness;\n    vec3 normalEC;\n    float occlusion;\n    vec3 emissive;\n#ifdef USE_SPECULAR\n    float specularWeight;\n#endif\n#ifdef USE_ANISOTROPY\n    vec3 anisotropicT;\n    vec3 anisotropicB;\n    float anisotropyStrength;\n#endif\n#ifdef USE_CLEARCOAT\n    float clearcoatFactor;\n    float clearcoatRoughness;\n    vec3 clearcoatNormal;\n    // Add clearcoatF0 when KHR_materials_ior is implemented\n#endif\n};\n"},171037:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * Struct for representing the output of a custom vertex shader.\n * \n * @name czm_modelVertexOutput\n * @glslStruct\n *\n * @see {@link CustomShader}\n * @see {@link Model}\n *\n * @property {vec3} positionMC The position of the vertex in model coordinates\n * @property {float} pointSize A custom value for gl_PointSize. This is only used for point primitives. \n */\nstruct czm_modelVertexOutput {\n  vec3 positionMC;\n  float pointSize;\n};\n"},41715:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * DOC_TBA\n *\n * @name czm_ray\n * @glslStruct\n */\nstruct czm_ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n"},229806:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="/**\n * DOC_TBA\n *\n * @name czm_raySegment\n * @glslStruct\n */\nstruct czm_raySegment\n{\n    float start;\n    float stop;\n};\n\n/**\n * DOC_TBA\n *\n * @name czm_emptyRaySegment\n * @glslConstant \n */\nconst czm_raySegment czm_emptyRaySegment = czm_raySegment(-czm_infinity, -czm_infinity);\n\n/**\n * DOC_TBA\n *\n * @name czm_fullRaySegment\n * @glslConstant \n */\nconst czm_raySegment czm_fullRaySegment = czm_raySegment(0.0, czm_infinity);\n"},731759:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="struct czm_shadowParameters\n{\n#ifdef USE_CUBE_MAP_SHADOW\n    vec3 texCoords;\n#else\n    vec2 texCoords;\n#endif\n\n    float depthBias;\n    float depth;\n    float nDotL;\n    vec2 texelStepSize;\n    float normalShadingSmooth;\n    float darkness;\n};\n"},239942:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="uniform sampler2D image;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    vec4 rampColor = texture(image, vec2(materialInput.aspect / (2.0 * czm_pi), 0.5));\n    rampColor = czm_gammaCorrect(rampColor);\n    material.diffuse = rampColor.rgb;\n    material.alpha = rampColor.a;\n    return material;\n}\n"},980360:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="uniform sampler2D image;\nuniform float strength;\nuniform vec2 repeat;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    vec2 st = materialInput.st;\n\n    vec2 centerPixel = fract(repeat * st);\n    float centerBump = texture(image, centerPixel).channel;\n\n    float imageWidth = float(imageDimensions.x);\n    vec2 rightPixel = fract(repeat * (st + vec2(1.0 / imageWidth, 0.0)));\n    float rightBump = texture(image, rightPixel).channel;\n\n    float imageHeight = float(imageDimensions.y);\n    vec2 leftPixel = fract(repeat * (st + vec2(0.0, 1.0 / imageHeight)));\n    float topBump = texture(image, leftPixel).channel;\n\n    vec3 normalTangentSpace = normalize(vec3(centerBump - rightBump, centerBump - topBump, clamp(1.0 - strength, 0.1, 1.0)));\n    vec3 normalEC = materialInput.tangentToEyeMatrix * normalTangentSpace;\n\n    material.normal = normalEC;\n    material.diffuse = vec3(0.01);\n\n    return material;\n}\n"},874099:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="uniform vec4 lightColor;\nuniform vec4 darkColor;\nuniform vec2 repeat;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    vec2 st = materialInput.st;\n\n    // From Stefan Gustavson's Procedural Textures in GLSL in OpenGL Insights\n    float b = mod(floor(repeat.s * st.s) + floor(repeat.t * st.t), 2.0);  // 0.0 or 1.0\n\n    // Find the distance from the closest separator (region between two colors)\n    float scaledWidth = fract(repeat.s * st.s);\n    scaledWidth = abs(scaledWidth - floor(scaledWidth + 0.5));\n    float scaledHeight = fract(repeat.t * st.t);\n    scaledHeight = abs(scaledHeight - floor(scaledHeight + 0.5));\n    float value = min(scaledWidth, scaledHeight);\n\n    vec4 currentColor = mix(lightColor, darkColor, b);\n    vec4 color = czm_antialias(lightColor, darkColor, currentColor, value, 0.03);\n\n    color = czm_gammaCorrect(color);\n    material.diffuse = color.rgb;\n    material.alpha = color.a;\n\n    return material;\n}\n"},360069:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="uniform vec4 lightColor;\nuniform vec4 darkColor;\nuniform vec2 repeat;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    // From Stefan Gustavson's Procedural Textures in GLSL in OpenGL Insights\n    float b = smoothstep(0.3, 0.32, length(fract(repeat * materialInput.st) - 0.5));  // 0.0 or 1.0\n\n    vec4 color = mix(lightColor, darkColor, b);\n    color = czm_gammaCorrect(color);\n    material.diffuse = color.rgb;\n    material.alpha = color.a;\n\n    return material;\n}\n"},70966:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="uniform sampler2D heights;\nuniform sampler2D colors;\n\n// This material expects heights to be sorted from lowest to highest.\n\nfloat getHeight(int idx, float invTexSize)\n{\n    vec2 uv = vec2((float(idx) + 0.5) * invTexSize, 0.5);\n#ifdef OES_texture_float\n    return texture(heights, uv).x;\n#else\n    return czm_unpackFloat(texture(heights, uv));\n#endif\n}\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    float height = materialInput.height;\n    float invTexSize = 1.0 / float(heightsDimensions.x);\n\n    float minHeight = getHeight(0, invTexSize);\n    float maxHeight = getHeight(heightsDimensions.x - 1, invTexSize);\n\n    // early-out when outside the height range\n    if (height < minHeight || height > maxHeight) {\n        material.diffuse = vec3(0.0);\n        material.alpha = 0.0;\n        return material;\n    }\n\n    // Binary search to find heights above and below.\n    int idxBelow = 0;\n    int idxAbove = heightsDimensions.x;\n    float heightBelow = minHeight;\n    float heightAbove = maxHeight;\n\n    // while loop not allowed, so use for loop with max iterations.\n    // maxIterations of 16 supports a texture size up to 65536 (2^16).\n    const int maxIterations = 16;\n    for (int i = 0; i < maxIterations; i++) {\n        if (idxBelow >= idxAbove - 1) {\n            break;\n        }\n\n        int idxMid = (idxBelow + idxAbove) / 2;\n        float heightTex = getHeight(idxMid, invTexSize);\n\n        if (height > heightTex) {\n            idxBelow = idxMid;\n            heightBelow = heightTex;\n        } else {\n            idxAbove = idxMid;\n            heightAbove = heightTex;\n        }\n    }\n\n    float lerper = heightBelow == heightAbove ? 1.0 : (height - heightBelow) / (heightAbove - heightBelow);\n    vec2 colorUv = vec2(invTexSize * (float(idxBelow) + 0.5 + lerper), 0.5);\n    vec4 color = texture(colors, colorUv);\n\n    // undo preumultiplied alpha\n    if (color.a > 0.0) \n    {\n        color.rgb /= color.a;\n    }\n    \n    color.rgb = czm_gammaCorrect(color.rgb);\n\n    material.diffuse = color.rgb;\n    material.alpha = color.a;\n    return material;\n}\n"},21561:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="uniform vec4 color;\nuniform float spacing;\nuniform float width;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    float distanceToContour = mod(materialInput.height, spacing);\n\n#if (__VERSION__ == 300 || defined(GL_OES_standard_derivatives))\n    float dxc = abs(dFdx(materialInput.height));\n    float dyc = abs(dFdy(materialInput.height));\n    float dF = max(dxc, dyc) * czm_pixelRatio * width;\n    float alpha = (distanceToContour < dF) ? 1.0 : 0.0;\n#else\n    // If no derivatives available (IE 10?), use pixel ratio\n    float alpha = (distanceToContour < (czm_pixelRatio * width)) ? 1.0 : 0.0;\n#endif\n\n    vec4 outColor = czm_gammaCorrect(vec4(color.rgb, alpha * color.a));\n    material.diffuse = outColor.rgb;\n    material.alpha = outColor.a;\n\n    return material;\n}\n"},831373:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="uniform sampler2D image;\nuniform float minimumHeight;\nuniform float maximumHeight;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    float scaledHeight = clamp((materialInput.height - minimumHeight) / (maximumHeight - minimumHeight), 0.0, 1.0);\n    vec4 rampColor = texture(image, vec2(scaledHeight, 0.5));\n    rampColor = czm_gammaCorrect(rampColor);\n    material.diffuse = rampColor.rgb;\n    material.alpha = rampColor.a;\n    return material;\n}\n"},375916:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="uniform vec4 fadeInColor;\nuniform vec4 fadeOutColor;\nuniform float maximumDistance;\nuniform bool repeat;\nuniform vec2 fadeDirection;\nuniform vec2 time;\n\nfloat getTime(float t, float coord)\n{\n    float scalar = 1.0 / maximumDistance;\n    float q  = distance(t, coord) * scalar;\n    if (repeat)\n    {\n        float r = distance(t, coord + 1.0) * scalar;\n        float s = distance(t, coord - 1.0) * scalar;\n        q = min(min(r, s), q);\n    }\n    return clamp(q, 0.0, 1.0);\n}\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    vec2 st = materialInput.st;\n    float s = getTime(time.x, st.s) * fadeDirection.s;\n    float t = getTime(time.y, st.t) * fadeDirection.t;\n\n    float u = length(vec2(s, t));\n    vec4 color = mix(fadeInColor, fadeOutColor, u);\n\n    color = czm_gammaCorrect(color);\n    material.emission = color.rgb;\n    material.alpha = color.a;\n\n    return material;\n}\n"},76846:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i='uniform vec4 color;\nuniform float cellAlpha;\nuniform vec2 lineCount;\nuniform vec2 lineThickness;\nuniform vec2 lineOffset;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    vec2 st = materialInput.st;\n\n    float scaledWidth = fract(lineCount.s * st.s - lineOffset.s);\n    scaledWidth = abs(scaledWidth - floor(scaledWidth + 0.5));\n    float scaledHeight = fract(lineCount.t * st.t - lineOffset.t);\n    scaledHeight = abs(scaledHeight - floor(scaledHeight + 0.5));\n\n    float value;\n\n    // Fuzz Factor - Controls blurriness of lines\n#if (__VERSION__ == 300 || defined(GL_OES_standard_derivatives))\n    const float fuzz = 1.2;\n    vec2 thickness = (lineThickness * czm_pixelRatio) - 1.0;\n\n    // From "3D Engine Design for Virtual Globes" by Cozzi and Ring, Listing 4.13.\n    vec2 dx = abs(dFdx(st));\n    vec2 dy = abs(dFdy(st));\n    vec2 dF = vec2(max(dx.s, dy.s), max(dx.t, dy.t)) * lineCount;\n    value = min(\n        smoothstep(dF.s * thickness.s, dF.s * (fuzz + thickness.s), scaledWidth),\n        smoothstep(dF.t * thickness.t, dF.t * (fuzz + thickness.t), scaledHeight));\n#else\n    // If no derivatives available (IE 10?), revert to view-dependent fuzz\n    const float fuzz = 0.05;\n\n    vec2 range = 0.5 - (lineThickness * 0.05);\n    value = min(\n        1.0 - smoothstep(range.s, range.s + fuzz, scaledWidth),\n        1.0 - smoothstep(range.t, range.t + fuzz, scaledHeight));\n#endif\n\n    // Edges taken from RimLightingMaterial.glsl\n    // See http://www.fundza.com/rman_shaders/surface/fake_rim/fake_rim1.html\n    float dRim = 1.0 - abs(dot(materialInput.normalEC, normalize(materialInput.positionToEyeEC)));\n    float sRim = smoothstep(0.8, 1.0, dRim);\n    value *= (1.0 - sRim);\n\n    vec4 halfColor;\n    halfColor.rgb = color.rgb * 0.5;\n    halfColor.a = color.a * (1.0 - ((1.0 - cellAlpha) * value));\n    halfColor = czm_gammaCorrect(halfColor);\n    material.diffuse = halfColor.rgb;\n    material.emission = halfColor.rgb;\n    material.alpha = halfColor.a;\n\n    return material;\n}\n'},320441:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="uniform sampler2D image;\nuniform float strength;\nuniform vec2 repeat;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    \n    vec4 textureValue = texture(image, fract(repeat * materialInput.st));\n    vec3 normalTangentSpace = textureValue.channels;\n    normalTangentSpace.xy = normalTangentSpace.xy * 2.0 - 1.0;\n    normalTangentSpace.z = clamp(1.0 - strength, 0.1, 1.0);\n    normalTangentSpace = normalize(normalTangentSpace);\n    vec3 normalEC = materialInput.tangentToEyeMatrix * normalTangentSpace;\n    \n    material.normal = normalEC;\n    \n    return material;\n}\n"},830539:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="uniform vec4 color;\n\nfloat getPointOnLine(vec2 p0, vec2 p1, float x)\n{\n    float slope = (p0.y - p1.y) / (p0.x - p1.x);\n    return slope * (x - p0.x) + p0.y;\n}\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    vec2 st = materialInput.st;\n\n#if (__VERSION__ == 300 || defined(GL_OES_standard_derivatives))\n    float base = 1.0 - abs(fwidth(st.s)) * 10.0 * czm_pixelRatio;\n#else\n     // If no derivatives available (IE 10?), 2.5% of the line will be the arrow head\n    float base = 0.975;\n#endif\n\n    vec2 center = vec2(1.0, 0.5);\n    float ptOnUpperLine = getPointOnLine(vec2(base, 1.0), center, st.s);\n    float ptOnLowerLine = getPointOnLine(vec2(base, 0.0), center, st.s);\n\n    float halfWidth = 0.15;\n    float s = step(0.5 - halfWidth, st.t);\n    s *= 1.0 - step(0.5 + halfWidth, st.t);\n    s *= 1.0 - step(base, st.s);\n\n    float t = step(base, materialInput.st.s);\n    t *= 1.0 - step(ptOnUpperLine, st.t);\n    t *= step(ptOnLowerLine, st.t);\n\n    // Find the distance from the closest separator (region between two colors)\n    float dist;\n    if (st.s < base)\n    {\n        float d1 = abs(st.t - (0.5 - halfWidth));\n        float d2 = abs(st.t - (0.5 + halfWidth));\n        dist = min(d1, d2);\n    }\n    else\n    {\n        float d1 = czm_infinity;\n        if (st.t < 0.5 - halfWidth && st.t > 0.5 + halfWidth)\n        {\n            d1 = abs(st.s - base);\n        }\n        float d2 = abs(st.t - ptOnUpperLine);\n        float d3 = abs(st.t - ptOnLowerLine);\n        dist = min(min(d1, d2), d3);\n    }\n\n    vec4 outsideColor = vec4(0.0);\n    vec4 currentColor = mix(outsideColor, color, clamp(s + t, 0.0, 1.0));\n    vec4 outColor = czm_antialias(outsideColor, color, currentColor, dist);\n\n    outColor = czm_gammaCorrect(outColor);\n    material.diffuse = outColor.rgb;\n    material.alpha = outColor.a;\n    return material;\n}\n"},227798:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="uniform vec4 color;\nuniform vec4 gapColor;\nuniform float dashLength;\nuniform float dashPattern;\nin float v_polylineAngle;\n\nconst float maskLength = 16.0;\n\nmat2 rotate(float rad) {\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat2(\n        c, s,\n        -s, c\n    );\n}\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    vec2 pos = rotate(v_polylineAngle) * gl_FragCoord.xy;\n\n    // Get the relative position within the dash from 0 to 1\n    float dashPosition = fract(pos.x / (dashLength * czm_pixelRatio));\n    // Figure out the mask index.\n    float maskIndex = floor(dashPosition * maskLength);\n    // Test the bit mask.\n    float maskTest = floor(dashPattern / pow(2.0, maskIndex));\n    vec4 fragColor = (mod(maskTest, 2.0) < 1.0) ? gapColor : color;\n    if (fragColor.a < 0.005) {   // matches 0/255 and 1/255\n        discard;\n    }\n\n    fragColor = czm_gammaCorrect(fragColor);\n    material.emission = fragColor.rgb;\n    material.alpha = fragColor.a;\n    return material;\n}\n"},207131:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="uniform vec4 color;\nuniform float glowPower;\nuniform float taperPower;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    vec2 st = materialInput.st;\n    float glow = glowPower / abs(st.t - 0.5) - (glowPower / 0.5);\n\n    if (taperPower <= 0.99999) {\n        glow *= min(1.0, taperPower / (0.5 - st.s * 0.5) - (taperPower / 0.5));\n    }\n\n    vec4 fragColor;\n    fragColor.rgb = max(vec3(glow - 1.0 + color.rgb), color.rgb);\n    fragColor.a = clamp(0.0, 1.0, glow) * color.a;\n    fragColor = czm_gammaCorrect(fragColor);\n\n    material.emission = fragColor.rgb;\n    material.alpha = fragColor.a;\n\n    return material;\n}\n"},889216:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="uniform vec4 color;\nuniform vec4 outlineColor;\nuniform float outlineWidth;\n\nin float v_width;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    vec2 st = materialInput.st;\n    float halfInteriorWidth =  0.5 * (v_width - outlineWidth) / v_width;\n    float b = step(0.5 - halfInteriorWidth, st.t);\n    b *= 1.0 - step(0.5 + halfInteriorWidth, st.t);\n\n    // Find the distance from the closest separator (region between two colors)\n    float d1 = abs(st.t - (0.5 - halfInteriorWidth));\n    float d2 = abs(st.t - (0.5 + halfInteriorWidth));\n    float dist = min(d1, d2);\n\n    vec4 currentColor = mix(outlineColor, color, b);\n    vec4 outColor = czm_antialias(outlineColor, color, currentColor, dist);\n    outColor = czm_gammaCorrect(outColor);\n\n    material.diffuse = outColor.rgb;\n    material.alpha = outColor.a;\n\n    return material;\n}\n"},865114:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="uniform vec4 color;\nuniform vec4 rimColor;\nuniform float width;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    // See http://www.fundza.com/rman_shaders/surface/fake_rim/fake_rim1.html\n    float d = 1.0 - dot(materialInput.normalEC, normalize(materialInput.positionToEyeEC));\n    float s = smoothstep(1.0 - width, 1.0, d);\n\n    vec4 outColor = czm_gammaCorrect(color);\n    vec4 outRimColor = czm_gammaCorrect(rimColor);\n\n    material.diffuse = outColor.rgb;\n    material.emission = outRimColor.rgb * s;\n    material.alpha = mix(outColor.a, outRimColor.a, s);\n\n    return material;\n}\n"},256773:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="uniform sampler2D image;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    vec4 rampColor = texture(image, vec2(materialInput.slope / (czm_pi / 2.0), 0.5));\n    rampColor = czm_gammaCorrect(rampColor);\n    material.diffuse = rampColor.rgb;\n    material.alpha = rampColor.a;\n    return material;\n}\n"},807783:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="uniform vec4 evenColor;\nuniform vec4 oddColor;\nuniform float offset;\nuniform float repeat;\nuniform bool horizontal;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    // Based on the Stripes Fragment Shader in the Orange Book (11.1.2)\n    float coord = mix(materialInput.st.s, materialInput.st.t, float(horizontal));\n    float value = fract((coord - offset) * (repeat * 0.5));\n    float dist = min(value, min(abs(value - 0.5), 1.0 - value));\n\n    vec4 currentColor = mix(evenColor, oddColor, step(0.5, value));\n    vec4 color = czm_antialias(evenColor, oddColor, currentColor, dist);\n    color = czm_gammaCorrect(color);\n\n    material.diffuse = color.rgb;\n    material.alpha = color.a;\n\n    return material;\n}\n"},551672:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="// Thanks for the contribution Jonas\n// http://29a.ch/2012/7/19/webgl-terrain-rendering-water-fog\n\nuniform sampler2D specularMap;\nuniform sampler2D normalMap;\nuniform vec4 baseWaterColor;\nuniform vec4 blendColor;\nuniform float frequency;\nuniform float animationSpeed;\nuniform float amplitude;\nuniform float specularIntensity;\nuniform float fadeFactor;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    float time = czm_frameNumber * animationSpeed;\n\n    // fade is a function of the distance from the fragment and the frequency of the waves\n    float fade = max(1.0, (length(materialInput.positionToEyeEC) / 10000000000.0) * frequency * fadeFactor);\n\n    float specularMapValue = texture(specularMap, materialInput.st).r;\n\n    // note: not using directional motion at this time, just set the angle to 0.0;\n    vec4 noise = czm_getWaterNoise(normalMap, materialInput.st * frequency, time, 0.0);\n    vec3 normalTangentSpace = noise.xyz * vec3(1.0, 1.0, (1.0 / amplitude));\n\n    // fade out the normal perturbation as we move further from the water surface\n    normalTangentSpace.xy /= fade;\n\n    // attempt to fade out the normal perturbation as we approach non water areas (low specular map value)\n    normalTangentSpace = mix(vec3(0.0, 0.0, 50.0), normalTangentSpace, specularMapValue);\n\n    normalTangentSpace = normalize(normalTangentSpace);\n\n    // get ratios for alignment of the new normal vector with a vector perpendicular to the tangent plane\n    float tsPerturbationRatio = clamp(dot(normalTangentSpace, vec3(0.0, 0.0, 1.0)), 0.0, 1.0);\n\n    // fade out water effect as specular map value decreases\n    material.alpha = mix(blendColor.a, baseWaterColor.a, specularMapValue) * specularMapValue;\n\n    // base color is a blend of the water and non-water color based on the value from the specular map\n    // may need a uniform blend factor to better control this\n    material.diffuse = mix(blendColor.rgb, baseWaterColor.rgb, specularMapValue);\n\n    // diffuse highlights are based on how perturbed the normal is\n    material.diffuse += (0.1 * tsPerturbationRatio);\n\n    material.diffuse = material.diffuse;\n\n    material.normal = normalize(materialInput.tangentToEyeMatrix * normalTangentSpace);\n\n    material.specular = specularIntensity;\n    material.shininess = 10.0;\n\n    return material;\n}\n"},733185:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="uniform vec4 waterColor;\nuniform vec4 landColor;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    vec4 outColor = mix(landColor, waterColor, materialInput.waterMask);\n    outColor = czm_gammaCorrect(outColor);\n\n    material.diffuse = outColor.rgb;\n    material.alpha = outColor.a;\n\n    return material;\n}\n"},208276:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="in vec4 v_color;\nin vec4 v_outlineColor;\nin float v_innerPercent;\nin float v_pixelDistance;\nin vec4 v_pickColor;\nin float v_splitDirection;\n\nvoid main()\n{\n    if (v_splitDirection < 0.0 && gl_FragCoord.x > czm_splitPosition) discard;\n    if (v_splitDirection > 0.0 && gl_FragCoord.x < czm_splitPosition) discard;\n\n    // The distance in UV space from this fragment to the center of the point, at most 0.5.\n    float distanceToCenter = length(gl_PointCoord - vec2(0.5));\n    // The max distance stops one pixel shy of the edge to leave space for anti-aliasing.\n    float maxDistance = max(0.0, 0.5 - v_pixelDistance);\n    float wholeAlpha = 1.0 - smoothstep(maxDistance, 0.5, distanceToCenter);\n    float innerAlpha = 1.0 - smoothstep(maxDistance * v_innerPercent, 0.5 * v_innerPercent, distanceToCenter);\n\n    vec4 color = mix(v_outlineColor, v_color, innerAlpha);\n    color.a *= wholeAlpha;\n\n// Fully transparent parts of the billboard are not pickable.\n#if !defined(OPAQUE) && !defined(TRANSLUCENT)\n    if (color.a < 0.005)   // matches 0/255 and 1/255\n    {\n        discard;\n    }\n#else\n// The billboard is rendered twice. The opaque pass discards translucent fragments\n// and the translucent pass discards opaque fragments.\n#ifdef OPAQUE\n    if (color.a < 0.995)   // matches < 254/255\n    {\n        discard;\n    }\n#else\n    if (color.a >= 0.995)  // matches 254/255 and 255/255\n    {\n        discard;\n    }\n#endif\n#endif\n\n    out_FragColor = czm_gammaCorrect(color);\n    czm_writeLogDepth();\n}\n"},510148:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i='uniform float u_maxTotalPointSize;\n\nin vec4 positionHighAndSize;\nin vec4 positionLowAndOutline;\nin vec4 compressedAttribute0;                                        // color, outlineColor, pick color\nin vec4 compressedAttribute1;                                        // show, translucency by distance, some free space\nin vec4 scaleByDistance;                                             // near, nearScale, far, farScale\nin vec4 distanceDisplayConditionAndDisableDepthAndSplitDirection;    // near, far, disableDepthTestDistance, splitDirection\n\nout vec4 v_color;\nout vec4 v_outlineColor;\nout float v_innerPercent;\nout float v_pixelDistance;\nout vec4 v_pickColor;\nout float v_splitDirection;\n\nconst float SHIFT_LEFT8 = 256.0;\nconst float SHIFT_RIGHT8 = 1.0 / 256.0;\n\nvoid main()\n{\n    // Modifying this shader may also require modifications to PointPrimitive._computeScreenSpacePosition\n\n    // unpack attributes\n    vec3 positionHigh = positionHighAndSize.xyz;\n    vec3 positionLow = positionLowAndOutline.xyz;\n    float outlineWidthBothSides = 2.0 * positionLowAndOutline.w;\n    float totalSize = positionHighAndSize.w + outlineWidthBothSides;\n    float outlinePercent = outlineWidthBothSides / totalSize;\n    // Scale in response to browser-zoom.\n    totalSize *= czm_pixelRatio;\n\n    float temp = compressedAttribute1.x * SHIFT_RIGHT8;\n    float show = floor(temp);\n\n#ifdef EYE_DISTANCE_TRANSLUCENCY\n    vec4 translucencyByDistance;\n    translucencyByDistance.x = compressedAttribute1.z;\n    translucencyByDistance.z = compressedAttribute1.w;\n\n    translucencyByDistance.y = ((temp - floor(temp)) * SHIFT_LEFT8) / 255.0;\n\n    temp = compressedAttribute1.y * SHIFT_RIGHT8;\n    translucencyByDistance.w = ((temp - floor(temp)) * SHIFT_LEFT8) / 255.0;\n#endif\n\n    ///////////////////////////////////////////////////////////////////////////\n\n    vec4 color;\n    vec4 outlineColor;\n    vec4 pickColor;\n\n    // compressedAttribute0.z => pickColor.rgb\n\n    temp = compressedAttribute0.z * SHIFT_RIGHT8;\n    pickColor.b = (temp - floor(temp)) * SHIFT_LEFT8;\n    temp = floor(temp) * SHIFT_RIGHT8;\n    pickColor.g = (temp - floor(temp)) * SHIFT_LEFT8;\n    pickColor.r = floor(temp);\n\n    // compressedAttribute0.x => color.rgb\n\n    temp = compressedAttribute0.x * SHIFT_RIGHT8;\n    color.b = (temp - floor(temp)) * SHIFT_LEFT8;\n    temp = floor(temp) * SHIFT_RIGHT8;\n    color.g = (temp - floor(temp)) * SHIFT_LEFT8;\n    color.r = floor(temp);\n\n    // compressedAttribute0.y => outlineColor.rgb\n\n    temp = compressedAttribute0.y * SHIFT_RIGHT8;\n    outlineColor.b = (temp - floor(temp)) * SHIFT_LEFT8;\n    temp = floor(temp) * SHIFT_RIGHT8;\n    outlineColor.g = (temp - floor(temp)) * SHIFT_LEFT8;\n    outlineColor.r = floor(temp);\n\n    // compressedAttribute0.w => color.a, outlineColor.a, pickColor.a\n\n    temp = compressedAttribute0.w * SHIFT_RIGHT8;\n    pickColor.a = (temp - floor(temp)) * SHIFT_LEFT8;\n    pickColor = pickColor / 255.0;\n\n    temp = floor(temp) * SHIFT_RIGHT8;\n    outlineColor.a = (temp - floor(temp)) * SHIFT_LEFT8;\n    outlineColor /= 255.0;\n    color.a = floor(temp);\n    color /= 255.0;\n\n    ///////////////////////////////////////////////////////////////////////////\n\n    vec4 p = czm_translateRelativeToEye(positionHigh, positionLow);\n    vec4 positionEC = czm_modelViewRelativeToEye * p;\n\n    ///////////////////////////////////////////////////////////////////////////\n\n#if defined(EYE_DISTANCE_SCALING) || defined(EYE_DISTANCE_TRANSLUCENCY) || defined(DISTANCE_DISPLAY_CONDITION) || defined(DISABLE_DEPTH_DISTANCE)\n    float lengthSq;\n    if (czm_sceneMode == czm_sceneMode2D)\n    {\n        // 2D camera distance is a special case\n        // treat all billboards as flattened to the z=0.0 plane\n        lengthSq = czm_eyeHeight2D.y;\n    }\n    else\n    {\n        lengthSq = dot(positionEC.xyz, positionEC.xyz);\n    }\n#endif\n\n#ifdef EYE_DISTANCE_SCALING\n    totalSize *= czm_nearFarScalar(scaleByDistance, lengthSq);\n#endif\n    if (totalSize > 0.0) {\n        // Add padding for anti-aliasing on both sides.\n        totalSize += 3.0;\n    }\n\n    // Clamp to max point size.\n    totalSize = min(totalSize, u_maxTotalPointSize);\n    // If size is too small, push vertex behind near plane for clipping.\n    // Note that context.minimumAliasedPointSize "will be at most 1.0".\n    if (totalSize < 1.0)\n    {\n        positionEC.xyz = vec3(0.0);\n        totalSize = 1.0;\n    }\n\n    float translucency = 1.0;\n#ifdef EYE_DISTANCE_TRANSLUCENCY\n    translucency = czm_nearFarScalar(translucencyByDistance, lengthSq);\n    // push vertex behind near plane for clipping\n    if (translucency < 0.004)\n    {\n        positionEC.xyz = vec3(0.0);\n    }\n#endif\n\n#ifdef DISTANCE_DISPLAY_CONDITION\n    float nearSq = distanceDisplayConditionAndDisableDepthAndSplitDirection.x;\n    float farSq = distanceDisplayConditionAndDisableDepthAndSplitDirection.y;\n    if (lengthSq < nearSq || lengthSq > farSq) {\n        // push vertex behind camera to force it to be clipped\n        positionEC.xyz = vec3(0.0, 0.0, 1.0);\n    }\n#endif\n\n    gl_Position = czm_projection * positionEC;\n    czm_vertexLogDepth();\n\n#ifdef DISABLE_DEPTH_DISTANCE\n    float disableDepthTestDistance = distanceDisplayConditionAndDisableDepthAndSplitDirection.z;\n    if (disableDepthTestDistance == 0.0 && czm_minimumDisableDepthTestDistance != 0.0)\n    {\n        disableDepthTestDistance = czm_minimumDisableDepthTestDistance;\n    }\n\n    if (disableDepthTestDistance != 0.0)\n    {\n        // Don\'t try to "multiply both sides" by w.  Greater/less-than comparisons won\'t work for negative values of w.\n        float zclip = gl_Position.z / gl_Position.w;\n        bool clipped = (zclip < -1.0 || zclip > 1.0);\n        if (!clipped && (disableDepthTestDistance < 0.0 || (lengthSq > 0.0 && lengthSq < disableDepthTestDistance)))\n        {\n            // Position z on the near plane.\n            gl_Position.z = -gl_Position.w;\n#ifdef LOG_DEPTH\n            czm_vertexLogDepth(vec4(czm_currentFrustum.x));\n#endif\n        }\n    }\n#endif\n\n    v_color = color;\n    v_color.a *= translucency * show;\n    v_outlineColor = outlineColor;\n    v_outlineColor.a *= translucency * show;\n\n    v_innerPercent = 1.0 - outlinePercent;\n    v_pixelDistance = 2.0 / totalSize;\n    gl_PointSize = totalSize * show;\n    gl_Position *= show;\n\n    v_pickColor = pickColor;\n    v_splitDirection = distanceDisplayConditionAndDisableDepthAndSplitDirection.w;\n}\n'},78149:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="void clipLineSegmentToNearPlane(\n    vec3 p0,\n    vec3 p1,\n    out vec4 positionWC,\n    out bool clipped,\n    out bool culledByNearPlane,\n    out vec4 clippedPositionEC)\n{\n    culledByNearPlane = false;\n    clipped = false;\n\n    vec3 p0ToP1 = p1 - p0;\n    float magnitude = length(p0ToP1);\n    vec3 direction = normalize(p0ToP1);\n\n    // Distance that p0 is behind the near plane. Negative means p0 is\n    // in front of the near plane.\n    float endPoint0Distance =  czm_currentFrustum.x + p0.z;\n\n    // Camera looks down -Z.\n    // When moving a point along +Z: LESS VISIBLE\n    //   * Points in front of the camera move closer to the camera.\n    //   * Points behind the camrea move farther away from the camera.\n    // When moving a point along -Z: MORE VISIBLE\n    //   * Points in front of the camera move farther away from the camera.\n    //   * Points behind the camera move closer to the camera.\n\n    // Positive denominator: -Z, becoming more visible\n    // Negative denominator: +Z, becoming less visible\n    // Nearly zero: parallel to near plane\n    float denominator = -direction.z;\n\n    if (endPoint0Distance > 0.0 && abs(denominator) < czm_epsilon7)\n    {\n        // p0 is behind the near plane and the line to p1 is nearly parallel to\n        // the near plane, so cull the segment completely.\n        culledByNearPlane = true;\n    }\n    else if (endPoint0Distance > 0.0)\n    {\n        // p0 is behind the near plane, and the line to p1 is moving distinctly\n        // toward or away from it.\n\n        // t = (-plane distance - dot(plane normal, ray origin)) / dot(plane normal, ray direction)\n        float t = endPoint0Distance / denominator;\n        if (t < 0.0 || t > magnitude)\n        {\n            // Near plane intersection is not between the two points.\n            // We already confirmed p0 is behind the naer plane, so now\n            // we know the entire segment is behind it.\n            culledByNearPlane = true;\n        }\n        else\n        {\n            // Segment crosses the near plane, update p0 to lie exactly on it.\n            p0 = p0 + t * direction;\n\n            // Numerical noise might put us a bit on the wrong side of the near plane.\n            // Don't let that happen.\n            p0.z = min(p0.z, -czm_currentFrustum.x);\n\n            clipped = true;\n        }\n    }\n\n    clippedPositionEC = vec4(p0, 1.0);\n    positionWC = czm_eyeToWindowCoordinates(clippedPositionEC);\n}\n\nvec4 getPolylineWindowCoordinatesEC(vec4 positionEC, vec4 prevEC, vec4 nextEC, float expandDirection, float width, bool usePrevious, out float angle)\n{\n    // expandDirection +1 is to the _left_ when looking from positionEC toward nextEC.\n\n#ifdef POLYLINE_DASH\n    // Compute the window coordinates of the points.\n    vec4 positionWindow = czm_eyeToWindowCoordinates(positionEC);\n    vec4 previousWindow = czm_eyeToWindowCoordinates(prevEC);\n    vec4 nextWindow = czm_eyeToWindowCoordinates(nextEC);\n\n    // Determine the relative screen space direction of the line.\n    vec2 lineDir;\n    if (usePrevious) {\n        lineDir = normalize(positionWindow.xy - previousWindow.xy);\n    }\n    else {\n        lineDir = normalize(nextWindow.xy - positionWindow.xy);\n    }\n    angle = atan(lineDir.x, lineDir.y) - 1.570796327; // precomputed atan(1,0)\n\n    // Quantize the angle so it doesn't change rapidly between segments.\n    angle = floor(angle / czm_piOverFour + 0.5) * czm_piOverFour;\n#endif\n\n    vec4 clippedPrevWC, clippedPrevEC;\n    bool prevSegmentClipped, prevSegmentCulled;\n    clipLineSegmentToNearPlane(prevEC.xyz, positionEC.xyz, clippedPrevWC, prevSegmentClipped, prevSegmentCulled, clippedPrevEC);\n\n    vec4 clippedNextWC, clippedNextEC;\n    bool nextSegmentClipped, nextSegmentCulled;\n    clipLineSegmentToNearPlane(nextEC.xyz, positionEC.xyz, clippedNextWC, nextSegmentClipped, nextSegmentCulled, clippedNextEC);\n\n    bool segmentClipped, segmentCulled;\n    vec4 clippedPositionWC, clippedPositionEC;\n    clipLineSegmentToNearPlane(positionEC.xyz, usePrevious ? prevEC.xyz : nextEC.xyz, clippedPositionWC, segmentClipped, segmentCulled, clippedPositionEC);\n\n    if (segmentCulled)\n    {\n        return vec4(0.0, 0.0, 0.0, 1.0);\n    }\n\n    vec2 directionToPrevWC = normalize(clippedPrevWC.xy - clippedPositionWC.xy);\n    vec2 directionToNextWC = normalize(clippedNextWC.xy - clippedPositionWC.xy);\n\n    // If a segment was culled, we can't use the corresponding direction\n    // computed above. We should never see both of these be true without\n    // `segmentCulled` above also being true.\n    if (prevSegmentCulled)\n    {\n        directionToPrevWC = -directionToNextWC;\n    }\n    else if (nextSegmentCulled)\n    {\n        directionToNextWC = -directionToPrevWC;\n    }\n\n    vec2 thisSegmentForwardWC, otherSegmentForwardWC;\n    if (usePrevious)\n    {\n        thisSegmentForwardWC = -directionToPrevWC;\n        otherSegmentForwardWC = directionToNextWC;\n    }\n    else\n    {\n        thisSegmentForwardWC = directionToNextWC;\n        otherSegmentForwardWC =  -directionToPrevWC;\n    }\n\n    vec2 thisSegmentLeftWC = vec2(-thisSegmentForwardWC.y, thisSegmentForwardWC.x);\n\n    vec2 leftWC = thisSegmentLeftWC;\n    float expandWidth = width * 0.5;\n\n    // When lines are split at the anti-meridian, the position may be at the\n    // same location as the next or previous position, and we need to handle\n    // that to avoid producing NaNs.\n    if (!czm_equalsEpsilon(prevEC.xyz - positionEC.xyz, vec3(0.0), czm_epsilon1) && !czm_equalsEpsilon(nextEC.xyz - positionEC.xyz, vec3(0.0), czm_epsilon1))\n    {\n        vec2 otherSegmentLeftWC = vec2(-otherSegmentForwardWC.y, otherSegmentForwardWC.x);\n\n        vec2 leftSumWC = thisSegmentLeftWC + otherSegmentLeftWC;\n        float leftSumLength = length(leftSumWC);\n        leftWC = leftSumLength < czm_epsilon6 ? thisSegmentLeftWC : (leftSumWC / leftSumLength);\n\n        // The sine of the angle between the two vectors is given by the formula\n        //         |a x b| = |a||b|sin(theta)\n        // which is\n        //     float sinAngle = length(cross(vec3(leftWC, 0.0), vec3(-thisSegmentForwardWC, 0.0)));\n        // Because the z components of both vectors are zero, the x and y coordinate will be zero.\n        // Therefore, the sine of the angle is just the z component of the cross product.\n        vec2 u = -thisSegmentForwardWC;\n        vec2 v = leftWC;\n        float sinAngle = abs(u.x * v.y - u.y * v.x);\n        expandWidth = clamp(expandWidth / sinAngle, 0.0, width * 2.0);\n    }\n\n    vec2 offset = leftWC * expandDirection * expandWidth * czm_pixelRatio;\n    return vec4(clippedPositionWC.xy + offset, -clippedPositionWC.z, 1.0) * (czm_projection * clippedPositionEC).w;\n}\n\nvec4 getPolylineWindowCoordinates(vec4 position, vec4 previous, vec4 next, float expandDirection, float width, bool usePrevious, out float angle)\n{\n    vec4 positionEC = czm_modelViewRelativeToEye * position;\n    vec4 prevEC = czm_modelViewRelativeToEye * previous;\n    vec4 nextEC = czm_modelViewRelativeToEye * next;\n    return getPolylineWindowCoordinatesEC(positionEC, prevEC, nextEC, expandDirection, width, usePrevious, angle);\n}\n"},682091:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="#ifdef VECTOR_TILE\nuniform vec4 u_highlightColor;\n#endif\n\nin vec2 v_st;\n\nvoid main()\n{\n    czm_materialInput materialInput;\n\n    vec2 st = v_st;\n    st.t = czm_readNonPerspective(st.t, gl_FragCoord.w);\n\n    materialInput.s = st.s;\n    materialInput.st = st;\n    materialInput.str = vec3(st, 0.0);\n\n    czm_material material = czm_getMaterial(materialInput);\n    out_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n#ifdef VECTOR_TILE\n    out_FragColor *= u_highlightColor;\n#endif\n\n    czm_writeLogDepth();\n}\n"},749513:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i='in vec4 v_startPlaneNormalEcAndHalfWidth;\nin vec4 v_endPlaneNormalEcAndBatchId;\nin vec4 v_rightPlaneEC; // Technically can compute distance for this here\nin vec4 v_endEcAndStartEcX;\nin vec4 v_texcoordNormalizationAndStartEcYZ;\n\n#ifdef PER_INSTANCE_COLOR\nin vec4 v_color;\n#endif\n\nvoid main(void)\n{\n    float logDepthOrDepth = czm_branchFreeTernary(czm_sceneMode == czm_sceneMode2D, gl_FragCoord.z, czm_unpackDepth(texture(czm_globeDepthTexture, gl_FragCoord.xy / czm_viewport.zw)));\n    vec3 ecStart = vec3(v_endEcAndStartEcX.w, v_texcoordNormalizationAndStartEcYZ.zw);\n\n    // Discard for sky\n    if (logDepthOrDepth == 0.0) {\n#ifdef DEBUG_SHOW_VOLUME\n        out_FragColor = vec4(1.0, 0.0, 0.0, 0.5);\n        return;\n#else // DEBUG_SHOW_VOLUME\n        discard;\n#endif // DEBUG_SHOW_VOLUME\n    }\n\n    vec4 eyeCoordinate = czm_windowToEyeCoordinates(gl_FragCoord.xy, logDepthOrDepth);\n    eyeCoordinate /= eyeCoordinate.w;\n\n    float halfMaxWidth = v_startPlaneNormalEcAndHalfWidth.w * czm_metersPerPixel(eyeCoordinate);\n    // Check distance of the eye coordinate against the right-facing plane\n    float widthwiseDistance = czm_planeDistance(v_rightPlaneEC, eyeCoordinate.xyz);\n\n    // Check eye coordinate against the mitering planes\n    float distanceFromStart = czm_planeDistance(v_startPlaneNormalEcAndHalfWidth.xyz, -dot(ecStart, v_startPlaneNormalEcAndHalfWidth.xyz), eyeCoordinate.xyz);\n    float distanceFromEnd = czm_planeDistance(v_endPlaneNormalEcAndBatchId.xyz, -dot(v_endEcAndStartEcX.xyz, v_endPlaneNormalEcAndBatchId.xyz), eyeCoordinate.xyz);\n\n    if (abs(widthwiseDistance) > halfMaxWidth || distanceFromStart < 0.0 || distanceFromEnd < 0.0) {\n#ifdef DEBUG_SHOW_VOLUME\n        out_FragColor = vec4(1.0, 0.0, 0.0, 0.5);\n        return;\n#else // DEBUG_SHOW_VOLUME\n        discard;\n#endif // DEBUG_SHOW_VOLUME\n    }\n\n    // Check distance of the eye coordinate against start and end planes with normals in the right plane.\n    // For computing unskewed lengthwise texture coordinate.\n    // Can also be used for clipping extremely pointy miters, but in practice unnecessary because of miter breaking.\n\n    // aligned plane: cross the right plane normal with miter plane normal, then cross the result with right again to point it more "forward"\n    vec3 alignedPlaneNormal;\n\n    // start aligned plane\n    alignedPlaneNormal = cross(v_rightPlaneEC.xyz, v_startPlaneNormalEcAndHalfWidth.xyz);\n    alignedPlaneNormal = normalize(cross(alignedPlaneNormal, v_rightPlaneEC.xyz));\n    distanceFromStart = czm_planeDistance(alignedPlaneNormal, -dot(alignedPlaneNormal, ecStart), eyeCoordinate.xyz);\n\n    // end aligned plane\n    alignedPlaneNormal = cross(v_rightPlaneEC.xyz, v_endPlaneNormalEcAndBatchId.xyz);\n    alignedPlaneNormal = normalize(cross(alignedPlaneNormal, v_rightPlaneEC.xyz));\n    distanceFromEnd = czm_planeDistance(alignedPlaneNormal, -dot(alignedPlaneNormal, v_endEcAndStartEcX.xyz), eyeCoordinate.xyz);\n\n#ifdef PER_INSTANCE_COLOR\n    out_FragColor = czm_gammaCorrect(v_color);\n#else // PER_INSTANCE_COLOR\n    // Clamp - distance to aligned planes may be negative due to mitering,\n    // so fragment texture coordinate might be out-of-bounds.\n    float s = clamp(distanceFromStart / (distanceFromStart + distanceFromEnd), 0.0, 1.0);\n    s = (s * v_texcoordNormalizationAndStartEcYZ.x) + v_texcoordNormalizationAndStartEcYZ.y;\n    float t = (widthwiseDistance + halfMaxWidth) / (2.0 * halfMaxWidth);\n\n    czm_materialInput materialInput;\n\n    materialInput.s = s;\n    materialInput.st = vec2(s, t);\n    materialInput.str = vec3(s, t, 0.0);\n\n    czm_material material = czm_getMaterial(materialInput);\n    out_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n#endif // PER_INSTANCE_COLOR\n\n    // Premultiply alpha. Required for classification primitives on translucent globe.\n    out_FragColor.rgb *= out_FragColor.a;\n\n    czm_writeDepthClamp();\n}\n'},632577:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="in vec3 v_forwardDirectionEC;\nin vec3 v_texcoordNormalizationAndHalfWidth;\nin float v_batchId;\n\n#ifdef PER_INSTANCE_COLOR\nin vec4 v_color;\n#else\nin vec2 v_alignedPlaneDistances;\nin float v_texcoordT;\n#endif\n\nfloat rayPlaneDistanceUnsafe(vec3 origin, vec3 direction, vec3 planeNormal, float planeDistance) {\n    // We don't expect the ray to ever be parallel to the plane\n    return (-planeDistance - dot(planeNormal, origin)) / dot(planeNormal, direction);\n}\n\nvoid main(void)\n{\n    vec4 eyeCoordinate = gl_FragCoord;\n    eyeCoordinate /= eyeCoordinate.w;\n\n#ifdef PER_INSTANCE_COLOR\n    out_FragColor = czm_gammaCorrect(v_color);\n#else // PER_INSTANCE_COLOR\n    // Use distances for planes aligned with segment to prevent skew in dashing\n    float distanceFromStart = rayPlaneDistanceUnsafe(eyeCoordinate.xyz, -v_forwardDirectionEC, v_forwardDirectionEC.xyz, v_alignedPlaneDistances.x);\n    float distanceFromEnd = rayPlaneDistanceUnsafe(eyeCoordinate.xyz, v_forwardDirectionEC, -v_forwardDirectionEC.xyz, v_alignedPlaneDistances.y);\n\n    // Clamp - distance to aligned planes may be negative due to mitering\n    distanceFromStart = max(0.0, distanceFromStart);\n    distanceFromEnd = max(0.0, distanceFromEnd);\n\n    float s = distanceFromStart / (distanceFromStart + distanceFromEnd);\n    s = (s * v_texcoordNormalizationAndHalfWidth.x) + v_texcoordNormalizationAndHalfWidth.y;\n\n    czm_materialInput materialInput;\n\n    materialInput.s = s;\n    materialInput.st = vec2(s, v_texcoordT);\n    materialInput.str = vec3(s, v_texcoordT, 0.0);\n\n    czm_material material = czm_getMaterial(materialInput);\n    out_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n#endif // PER_INSTANCE_COLOR\n}\n"},700241:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i='in vec3 position3DHigh;\nin vec3 position3DLow;\n\nin vec4 startHiAndForwardOffsetX;\nin vec4 startLoAndForwardOffsetY;\nin vec4 startNormalAndForwardOffsetZ;\nin vec4 endNormalAndTextureCoordinateNormalizationX;\nin vec4 rightNormalAndTextureCoordinateNormalizationY;\nin vec4 startHiLo2D;\nin vec4 offsetAndRight2D;\nin vec4 startEndNormals2D;\nin vec2 texcoordNormalization2D;\n\nin float batchId;\n\nout vec3 v_forwardDirectionEC;\nout vec3 v_texcoordNormalizationAndHalfWidth;\nout float v_batchId;\n\n// For materials\n#ifdef WIDTH_VARYING\nout float v_width;\n#endif\n#ifdef ANGLE_VARYING\nout float v_polylineAngle;\n#endif\n\n#ifdef PER_INSTANCE_COLOR\nout vec4 v_color;\n#else\nout vec2 v_alignedPlaneDistances;\nout float v_texcoordT;\n#endif\n\n// Morphing planes using SLERP or NLERP doesn\'t seem to work, so instead draw the material directly on the shadow volume.\n// Morph views are from very far away and aren\'t meant to be used precisely, so this should be sufficient.\nvoid main()\n{\n    v_batchId = batchId;\n\n    // Start position\n    vec4 posRelativeToEye2D = czm_translateRelativeToEye(vec3(0.0, startHiLo2D.xy), vec3(0.0, startHiLo2D.zw));\n    vec4 posRelativeToEye3D = czm_translateRelativeToEye(startHiAndForwardOffsetX.xyz, startLoAndForwardOffsetY.xyz);\n    vec4 posRelativeToEye = czm_columbusViewMorph(posRelativeToEye2D, posRelativeToEye3D, czm_morphTime);\n    vec3 posEc2D = (czm_modelViewRelativeToEye * posRelativeToEye2D).xyz;\n    vec3 posEc3D = (czm_modelViewRelativeToEye * posRelativeToEye3D).xyz;\n    vec3 startEC = (czm_modelViewRelativeToEye * posRelativeToEye).xyz;\n\n    // Start plane\n    vec4 startPlane2D;\n    vec4 startPlane3D;\n    startPlane2D.xyz = czm_normal * vec3(0.0, startEndNormals2D.xy);\n    startPlane3D.xyz = czm_normal * startNormalAndForwardOffsetZ.xyz;\n    startPlane2D.w = -dot(startPlane2D.xyz, posEc2D);\n    startPlane3D.w = -dot(startPlane3D.xyz, posEc3D);\n\n    // Right plane\n    vec4 rightPlane2D;\n    vec4 rightPlane3D;\n    rightPlane2D.xyz = czm_normal * vec3(0.0, offsetAndRight2D.zw);\n    rightPlane3D.xyz = czm_normal * rightNormalAndTextureCoordinateNormalizationY.xyz;\n    rightPlane2D.w = -dot(rightPlane2D.xyz, posEc2D);\n    rightPlane3D.w = -dot(rightPlane3D.xyz, posEc3D);\n\n    // End position\n    posRelativeToEye2D = posRelativeToEye2D + vec4(0.0, offsetAndRight2D.xy, 0.0);\n    posRelativeToEye3D = posRelativeToEye3D + vec4(startHiAndForwardOffsetX.w, startLoAndForwardOffsetY.w, startNormalAndForwardOffsetZ.w, 0.0);\n    posRelativeToEye = czm_columbusViewMorph(posRelativeToEye2D, posRelativeToEye3D, czm_morphTime);\n    posEc2D = (czm_modelViewRelativeToEye * posRelativeToEye2D).xyz;\n    posEc3D = (czm_modelViewRelativeToEye * posRelativeToEye3D).xyz;\n    vec3 endEC = (czm_modelViewRelativeToEye * posRelativeToEye).xyz;\n    vec3 forwardEc3D = czm_normal * normalize(vec3(startHiAndForwardOffsetX.w, startLoAndForwardOffsetY.w, startNormalAndForwardOffsetZ.w));\n    vec3 forwardEc2D = czm_normal * normalize(vec3(0.0, offsetAndRight2D.xy));\n\n    // End plane\n    vec4 endPlane2D;\n    vec4 endPlane3D;\n    endPlane2D.xyz = czm_normal * vec3(0.0, startEndNormals2D.zw);\n    endPlane3D.xyz = czm_normal * endNormalAndTextureCoordinateNormalizationX.xyz;\n    endPlane2D.w = -dot(endPlane2D.xyz, posEc2D);\n    endPlane3D.w = -dot(endPlane3D.xyz, posEc3D);\n\n    // Forward direction\n    v_forwardDirectionEC = normalize(endEC - startEC);\n\n    vec2 cleanTexcoordNormalization2D;\n    cleanTexcoordNormalization2D.x = abs(texcoordNormalization2D.x);\n    cleanTexcoordNormalization2D.y = czm_branchFreeTernary(texcoordNormalization2D.y > 1.0, 0.0, abs(texcoordNormalization2D.y));\n    vec2 cleanTexcoordNormalization3D;\n    cleanTexcoordNormalization3D.x = abs(endNormalAndTextureCoordinateNormalizationX.w);\n    cleanTexcoordNormalization3D.y = rightNormalAndTextureCoordinateNormalizationY.w;\n    cleanTexcoordNormalization3D.y = czm_branchFreeTernary(cleanTexcoordNormalization3D.y > 1.0, 0.0, abs(cleanTexcoordNormalization3D.y));\n\n    v_texcoordNormalizationAndHalfWidth.xy = mix(cleanTexcoordNormalization2D, cleanTexcoordNormalization3D, czm_morphTime);\n\n#ifdef PER_INSTANCE_COLOR\n    v_color = czm_batchTable_color(batchId);\n#else // PER_INSTANCE_COLOR\n    // For computing texture coordinates\n\n    v_alignedPlaneDistances.x = -dot(v_forwardDirectionEC, startEC);\n    v_alignedPlaneDistances.y = -dot(-v_forwardDirectionEC, endEC);\n#endif // PER_INSTANCE_COLOR\n\n#ifdef WIDTH_VARYING\n    float width = czm_batchTable_width(batchId);\n    float halfWidth = width * 0.5;\n    v_width = width;\n    v_texcoordNormalizationAndHalfWidth.z = halfWidth;\n#else\n    float halfWidth = 0.5 * czm_batchTable_width(batchId);\n    v_texcoordNormalizationAndHalfWidth.z = halfWidth;\n#endif\n\n    // Compute a normal along which to "push" the position out, extending the miter depending on view distance.\n    // Position has already been "pushed" by unit length along miter normal, and miter normals are encoded in the planes.\n    // Decode the normal to use at this specific vertex, push the position back, and then push to where it needs to be.\n    // Since this is morphing, compute both 3D and 2D positions and then blend.\n\n    // ****** 3D ******\n    // Check distance to the end plane and start plane, pick the plane that is closer\n    vec4 positionEc3D = czm_modelViewRelativeToEye * czm_translateRelativeToEye(position3DHigh, position3DLow); // w = 1.0, see czm_computePosition\n    float absStartPlaneDistance = abs(czm_planeDistance(startPlane3D, positionEc3D.xyz));\n    float absEndPlaneDistance = abs(czm_planeDistance(endPlane3D, positionEc3D.xyz));\n    vec3 planeDirection = czm_branchFreeTernary(absStartPlaneDistance < absEndPlaneDistance, startPlane3D.xyz, endPlane3D.xyz);\n    vec3 upOrDown = normalize(cross(rightPlane3D.xyz, planeDirection)); // Points "up" for start plane, "down" at end plane.\n    vec3 normalEC = normalize(cross(planeDirection, upOrDown));         // In practice, the opposite seems to work too.\n\n    // Nudge the top vertex upwards to prevent flickering\n    vec3 geodeticSurfaceNormal = normalize(cross(normalEC, forwardEc3D));\n    geodeticSurfaceNormal *= float(0.0 <= rightNormalAndTextureCoordinateNormalizationY.w && rightNormalAndTextureCoordinateNormalizationY.w <= 1.0);\n    geodeticSurfaceNormal *= MAX_TERRAIN_HEIGHT;\n    positionEc3D.xyz += geodeticSurfaceNormal;\n\n    // Determine if this vertex is on the "left" or "right"\n    normalEC *= sign(endNormalAndTextureCoordinateNormalizationX.w);\n\n    // A "perfect" implementation would push along normals according to the angle against forward.\n    // In practice, just pushing the normal out by halfWidth is sufficient for morph views.\n    positionEc3D.xyz += halfWidth * max(0.0, czm_metersPerPixel(positionEc3D)) * normalEC; // prevent artifacts when czm_metersPerPixel is negative (behind camera)\n\n    // ****** 2D ******\n    // Check distance to the end plane and start plane, pick the plane that is closer\n    vec4 positionEc2D = czm_modelViewRelativeToEye * czm_translateRelativeToEye(position2DHigh.zxy, position2DLow.zxy); // w = 1.0, see czm_computePosition\n    absStartPlaneDistance = abs(czm_planeDistance(startPlane2D, positionEc2D.xyz));\n    absEndPlaneDistance = abs(czm_planeDistance(endPlane2D, positionEc2D.xyz));\n    planeDirection = czm_branchFreeTernary(absStartPlaneDistance < absEndPlaneDistance, startPlane2D.xyz, endPlane2D.xyz);\n    upOrDown = normalize(cross(rightPlane2D.xyz, planeDirection)); // Points "up" for start plane, "down" at end plane.\n    normalEC = normalize(cross(planeDirection, upOrDown));         // In practice, the opposite seems to work too.\n\n    // Nudge the top vertex upwards to prevent flickering\n    geodeticSurfaceNormal = normalize(cross(normalEC, forwardEc2D));\n    geodeticSurfaceNormal *= float(0.0 <= texcoordNormalization2D.y && texcoordNormalization2D.y <= 1.0);\n    geodeticSurfaceNormal *= MAX_TERRAIN_HEIGHT;\n    positionEc2D.xyz += geodeticSurfaceNormal;\n\n    // Determine if this vertex is on the "left" or "right"\n    normalEC *= sign(texcoordNormalization2D.x);\n#ifndef PER_INSTANCE_COLOR\n    // Use vertex\'s sidedness to compute its texture coordinate.\n    v_texcoordT = clamp(sign(texcoordNormalization2D.x), 0.0, 1.0);\n#endif\n\n    // A "perfect" implementation would push along normals according to the angle against forward.\n    // In practice, just pushing the normal out by halfWidth is sufficient for morph views.\n    positionEc2D.xyz += halfWidth * max(0.0, czm_metersPerPixel(positionEc2D)) * normalEC; // prevent artifacts when czm_metersPerPixel is negative (behind camera)\n\n    // Blend for actual position\n    gl_Position = czm_projection * mix(positionEc2D, positionEc3D, czm_morphTime);\n\n#ifdef ANGLE_VARYING\n    // Approximate relative screen space direction of the line.\n    vec2 approxLineDirection = normalize(vec2(v_forwardDirectionEC.x, -v_forwardDirectionEC.y));\n    approxLineDirection.y = czm_branchFreeTernary(approxLineDirection.x == 0.0 && approxLineDirection.y == 0.0, -1.0, approxLineDirection.y);\n    v_polylineAngle = czm_fastApproximateAtan(approxLineDirection.x, approxLineDirection.y);\n#endif\n}\n'},575513:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i='in vec3 position3DHigh;\nin vec3 position3DLow;\n\n// In 2D and in 3D, texture coordinate normalization component signs encodes:\n// * X sign - sidedness relative to right plane\n// * Y sign - is negative OR magnitude is greater than 1.0 if vertex is on bottom of volume\n#ifndef COLUMBUS_VIEW_2D\nin vec4 startHiAndForwardOffsetX;\nin vec4 startLoAndForwardOffsetY;\nin vec4 startNormalAndForwardOffsetZ;\nin vec4 endNormalAndTextureCoordinateNormalizationX;\nin vec4 rightNormalAndTextureCoordinateNormalizationY;\n#else\nin vec4 startHiLo2D;\nin vec4 offsetAndRight2D;\nin vec4 startEndNormals2D;\nin vec2 texcoordNormalization2D;\n#endif\n\nin float batchId;\n\nout vec4 v_startPlaneNormalEcAndHalfWidth;\nout vec4 v_endPlaneNormalEcAndBatchId;\nout vec4 v_rightPlaneEC;\nout vec4 v_endEcAndStartEcX;\nout vec4 v_texcoordNormalizationAndStartEcYZ;\n\n// For materials\n#ifdef WIDTH_VARYING\nout float v_width;\n#endif\n#ifdef ANGLE_VARYING\nout float v_polylineAngle;\n#endif\n\n#ifdef PER_INSTANCE_COLOR\nout vec4 v_color;\n#endif\n\nvoid main()\n{\n#ifdef COLUMBUS_VIEW_2D\n    vec3 ecStart = (czm_modelViewRelativeToEye * czm_translateRelativeToEye(vec3(0.0, startHiLo2D.xy), vec3(0.0, startHiLo2D.zw))).xyz;\n\n    vec3 forwardDirectionEC = czm_normal * vec3(0.0, offsetAndRight2D.xy);\n    vec3 ecEnd = forwardDirectionEC + ecStart;\n    forwardDirectionEC = normalize(forwardDirectionEC);\n\n    // Right plane\n    v_rightPlaneEC.xyz = czm_normal * vec3(0.0, offsetAndRight2D.zw);\n    v_rightPlaneEC.w = -dot(v_rightPlaneEC.xyz, ecStart);\n\n    // start plane\n    vec4 startPlaneEC;\n    startPlaneEC.xyz =  czm_normal * vec3(0.0, startEndNormals2D.xy);\n    startPlaneEC.w = -dot(startPlaneEC.xyz, ecStart);\n\n    // end plane\n    vec4 endPlaneEC;\n    endPlaneEC.xyz =  czm_normal * vec3(0.0, startEndNormals2D.zw);\n    endPlaneEC.w = -dot(endPlaneEC.xyz, ecEnd);\n\n    v_texcoordNormalizationAndStartEcYZ.x = abs(texcoordNormalization2D.x);\n    v_texcoordNormalizationAndStartEcYZ.y = texcoordNormalization2D.y;\n\n#else // COLUMBUS_VIEW_2D\n    vec3 ecStart = (czm_modelViewRelativeToEye * czm_translateRelativeToEye(startHiAndForwardOffsetX.xyz, startLoAndForwardOffsetY.xyz)).xyz;\n    vec3 offset = czm_normal * vec3(startHiAndForwardOffsetX.w, startLoAndForwardOffsetY.w, startNormalAndForwardOffsetZ.w);\n    vec3 ecEnd = ecStart + offset;\n\n    vec3 forwardDirectionEC = normalize(offset);\n\n    // start plane\n    vec4 startPlaneEC;\n    startPlaneEC.xyz = czm_normal * startNormalAndForwardOffsetZ.xyz;\n    startPlaneEC.w = -dot(startPlaneEC.xyz, ecStart);\n\n    // end plane\n    vec4 endPlaneEC;\n    endPlaneEC.xyz = czm_normal * endNormalAndTextureCoordinateNormalizationX.xyz;\n    endPlaneEC.w = -dot(endPlaneEC.xyz, ecEnd);\n\n    // Right plane\n    v_rightPlaneEC.xyz = czm_normal * rightNormalAndTextureCoordinateNormalizationY.xyz;\n    v_rightPlaneEC.w = -dot(v_rightPlaneEC.xyz, ecStart);\n\n    v_texcoordNormalizationAndStartEcYZ.x = abs(endNormalAndTextureCoordinateNormalizationX.w);\n    v_texcoordNormalizationAndStartEcYZ.y = rightNormalAndTextureCoordinateNormalizationY.w;\n\n#endif // COLUMBUS_VIEW_2D\n\n    v_endEcAndStartEcX.xyz = ecEnd;\n    v_endEcAndStartEcX.w = ecStart.x;\n    v_texcoordNormalizationAndStartEcYZ.zw = ecStart.yz;\n\n#ifdef PER_INSTANCE_COLOR\n    v_color = czm_batchTable_color(batchId);\n#endif // PER_INSTANCE_COLOR\n\n    // Compute a normal along which to "push" the position out, extending the miter depending on view distance.\n    // Position has already been "pushed" by unit length along miter normal, and miter normals are encoded in the planes.\n    // Decode the normal to use at this specific vertex, push the position back, and then push to where it needs to be.\n    vec4 positionRelativeToEye = czm_computePosition();\n\n    // Check distance to the end plane and start plane, pick the plane that is closer\n    vec4 positionEC = czm_modelViewRelativeToEye * positionRelativeToEye; // w = 1.0, see czm_computePosition\n    float absStartPlaneDistance = abs(czm_planeDistance(startPlaneEC, positionEC.xyz));\n    float absEndPlaneDistance = abs(czm_planeDistance(endPlaneEC, positionEC.xyz));\n    vec3 planeDirection = czm_branchFreeTernary(absStartPlaneDistance < absEndPlaneDistance, startPlaneEC.xyz, endPlaneEC.xyz);\n    vec3 upOrDown = normalize(cross(v_rightPlaneEC.xyz, planeDirection)); // Points "up" for start plane, "down" at end plane.\n    vec3 normalEC = normalize(cross(planeDirection, upOrDown));           // In practice, the opposite seems to work too.\n\n    // Extrude bottom vertices downward for far view distances, like for GroundPrimitives\n    upOrDown = cross(forwardDirectionEC, normalEC);\n    upOrDown = float(czm_sceneMode == czm_sceneMode3D) * upOrDown;\n    upOrDown = float(v_texcoordNormalizationAndStartEcYZ.y > 1.0 || v_texcoordNormalizationAndStartEcYZ.y < 0.0) * upOrDown;\n    upOrDown = min(GLOBE_MINIMUM_ALTITUDE, czm_geometricToleranceOverMeter * length(positionRelativeToEye.xyz)) * upOrDown;\n    positionEC.xyz += upOrDown;\n\n    v_texcoordNormalizationAndStartEcYZ.y = czm_branchFreeTernary(v_texcoordNormalizationAndStartEcYZ.y > 1.0, 0.0, abs(v_texcoordNormalizationAndStartEcYZ.y));\n\n    // Determine distance along normalEC to push for a volume of appropriate width.\n    // Make volumes about double pixel width for a conservative fit - in practice the\n    // extra cost here is minimal compared to the loose volume heights.\n    //\n    // N = normalEC (guaranteed "right-facing")\n    // R = rightEC\n    // p = angle between N and R\n    // w = distance to push along R if R == N\n    // d = distance to push along N\n    //\n    //   N   R\n    //  {  p| }      * cos(p) = dot(N, R) = w / d\n    //  d  |  |w    * d = w / dot(N, R)\n    //    { | }\n    //       o---------- polyline segment ----\x3e\n    //\n    float width = czm_batchTable_width(batchId);\n#ifdef WIDTH_VARYING\n    v_width = width;\n#endif\n\n    v_startPlaneNormalEcAndHalfWidth.xyz = startPlaneEC.xyz;\n    v_startPlaneNormalEcAndHalfWidth.w = width * 0.5;\n\n    v_endPlaneNormalEcAndBatchId.xyz = endPlaneEC.xyz;\n    v_endPlaneNormalEcAndBatchId.w = batchId;\n\n    width = width * max(0.0, czm_metersPerPixel(positionEC)); // width = distance to push along R\n    width = width / dot(normalEC, v_rightPlaneEC.xyz); // width = distance to push along N\n\n    // Determine if this vertex is on the "left" or "right"\n#ifdef COLUMBUS_VIEW_2D\n        normalEC *= sign(texcoordNormalization2D.x);\n#else\n        normalEC *= sign(endNormalAndTextureCoordinateNormalizationX.w);\n#endif\n\n    positionEC.xyz += width * normalEC;\n    gl_Position = czm_depthClamp(czm_projection * positionEC);\n\n#ifdef ANGLE_VARYING\n    // Approximate relative screen space direction of the line.\n    vec2 approxLineDirection = normalize(vec2(forwardDirectionEC.x, -forwardDirectionEC.y));\n    approxLineDirection.y = czm_branchFreeTernary(approxLineDirection.x == 0.0 && approxLineDirection.y == 0.0, -1.0, approxLineDirection.y);\n    v_polylineAngle = czm_fastApproximateAtan(approxLineDirection.x, approxLineDirection.y);\n#endif\n}\n'},710807:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="#ifdef TEXTURE_COORDINATES\n#ifdef SPHERICAL\nin vec4 v_sphericalExtents;\n#else // SPHERICAL\nin vec2 v_inversePlaneExtents;\nin vec4 v_westPlane;\nin vec4 v_southPlane;\n#endif // SPHERICAL\nin vec3 v_uvMinAndSphericalLongitudeRotation;\nin vec3 v_uMaxAndInverseDistance;\nin vec3 v_vMaxAndInverseDistance;\n#endif // TEXTURE_COORDINATES\n\n#ifdef PER_INSTANCE_COLOR\nin vec4 v_color;\n#endif\n\n#ifdef NORMAL_EC\nvec3 getEyeCoordinate3FromWindowCoordinate(vec2 fragCoord, float logDepthOrDepth) {\n    vec4 eyeCoordinate = czm_windowToEyeCoordinates(fragCoord, logDepthOrDepth);\n    return eyeCoordinate.xyz / eyeCoordinate.w;\n}\n\nvec3 vectorFromOffset(vec4 eyeCoordinate, vec2 positiveOffset) {\n    vec2 glFragCoordXY = gl_FragCoord.xy;\n    // Sample depths at both offset and negative offset\n    float upOrRightLogDepth = czm_unpackDepth(texture(czm_globeDepthTexture, (glFragCoordXY + positiveOffset) / czm_viewport.zw));\n    float downOrLeftLogDepth = czm_unpackDepth(texture(czm_globeDepthTexture, (glFragCoordXY - positiveOffset) / czm_viewport.zw));\n    // Explicitly evaluate both paths\n    // Necessary for multifrustum and for edges of the screen\n    bvec2 upOrRightInBounds = lessThan(glFragCoordXY + positiveOffset, czm_viewport.zw);\n    float useUpOrRight = float(upOrRightLogDepth > 0.0 && upOrRightInBounds.x && upOrRightInBounds.y);\n    float useDownOrLeft = float(useUpOrRight == 0.0);\n    vec3 upOrRightEC = getEyeCoordinate3FromWindowCoordinate(glFragCoordXY + positiveOffset, upOrRightLogDepth);\n    vec3 downOrLeftEC = getEyeCoordinate3FromWindowCoordinate(glFragCoordXY - positiveOffset, downOrLeftLogDepth);\n    return (upOrRightEC - (eyeCoordinate.xyz / eyeCoordinate.w)) * useUpOrRight + ((eyeCoordinate.xyz / eyeCoordinate.w) - downOrLeftEC) * useDownOrLeft;\n}\n#endif // NORMAL_EC\n\nvoid main(void)\n{\n#ifdef REQUIRES_EC\n    float logDepthOrDepth = czm_unpackDepth(texture(czm_globeDepthTexture, gl_FragCoord.xy / czm_viewport.zw));\n    vec4 eyeCoordinate = czm_windowToEyeCoordinates(gl_FragCoord.xy, logDepthOrDepth);\n#endif\n\n#ifdef REQUIRES_WC\n    vec4 worldCoordinate4 = czm_inverseView * eyeCoordinate;\n    vec3 worldCoordinate = worldCoordinate4.xyz / worldCoordinate4.w;\n#endif\n\n#ifdef TEXTURE_COORDINATES\n    vec2 uv;\n#ifdef SPHERICAL\n    // Treat world coords as a sphere normal for spherical coordinates\n    vec2 sphericalLatLong = czm_approximateSphericalCoordinates(worldCoordinate);\n    sphericalLatLong.y += v_uvMinAndSphericalLongitudeRotation.z;\n    sphericalLatLong.y = czm_branchFreeTernary(sphericalLatLong.y < czm_pi, sphericalLatLong.y, sphericalLatLong.y - czm_twoPi);\n    uv.x = (sphericalLatLong.y - v_sphericalExtents.y) * v_sphericalExtents.w;\n    uv.y = (sphericalLatLong.x - v_sphericalExtents.x) * v_sphericalExtents.z;\n#else // SPHERICAL\n    // Unpack planes and transform to eye space\n    uv.x = czm_planeDistance(v_westPlane, eyeCoordinate.xyz / eyeCoordinate.w) * v_inversePlaneExtents.x;\n    uv.y = czm_planeDistance(v_southPlane, eyeCoordinate.xyz / eyeCoordinate.w) * v_inversePlaneExtents.y;\n#endif // SPHERICAL\n#endif // TEXTURE_COORDINATES\n\n#ifdef PICK\n#ifdef CULL_FRAGMENTS\n    // When classifying translucent geometry, logDepthOrDepth == 0.0\n    // indicates a region that should not be classified, possibly due to there\n    // being opaque pixels there in another buffer.\n    // Check for logDepthOrDepth != 0.0 to make sure this should be classified.\n    if (0.0 <= uv.x && uv.x <= 1.0 && 0.0 <= uv.y && uv.y <= 1.0 || logDepthOrDepth != 0.0) {\n        out_FragColor.a = 1.0; // 0.0 alpha leads to discard from ShaderSource.createPickFragmentShaderSource\n        czm_writeDepthClamp();\n    }\n#else // CULL_FRAGMENTS\n        out_FragColor.a = 1.0;\n#endif // CULL_FRAGMENTS\n#else // PICK\n\n#ifdef CULL_FRAGMENTS\n    // When classifying translucent geometry, logDepthOrDepth == 0.0\n    // indicates a region that should not be classified, possibly due to there\n    // being opaque pixels there in another buffer.\n    if (uv.x <= 0.0 || 1.0 <= uv.x || uv.y <= 0.0 || 1.0 <= uv.y || logDepthOrDepth == 0.0) {\n        discard;\n    }\n#endif\n\n#ifdef NORMAL_EC\n    // Compute normal by sampling adjacent pixels in 2x2 block in screen space\n    vec3 downUp = vectorFromOffset(eyeCoordinate, vec2(0.0, 1.0));\n    vec3 leftRight = vectorFromOffset(eyeCoordinate, vec2(1.0, 0.0));\n    vec3 normalEC = normalize(cross(leftRight, downUp));\n#endif\n\n\n#ifdef PER_INSTANCE_COLOR\n\n    vec4 color = czm_gammaCorrect(v_color);\n#ifdef FLAT\n    out_FragColor = color;\n#else // FLAT\n    czm_materialInput materialInput;\n    materialInput.normalEC = normalEC;\n    materialInput.positionToEyeEC = -eyeCoordinate.xyz;\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    material.diffuse = color.rgb;\n    material.alpha = color.a;\n\n    out_FragColor = czm_phong(normalize(-eyeCoordinate.xyz), material, czm_lightDirectionEC);\n#endif // FLAT\n\n    // Premultiply alpha. Required for classification primitives on translucent globe.\n    out_FragColor.rgb *= out_FragColor.a;\n\n#else // PER_INSTANCE_COLOR\n\n    // Material support.\n    // USES_ is distinct from REQUIRES_, because some things are dependencies of each other or\n    // dependencies for culling but might not actually be used by the material.\n\n    czm_materialInput materialInput;\n\n#ifdef USES_NORMAL_EC\n    materialInput.normalEC = normalEC;\n#endif\n\n#ifdef USES_POSITION_TO_EYE_EC\n    materialInput.positionToEyeEC = -eyeCoordinate.xyz;\n#endif\n\n#ifdef USES_TANGENT_TO_EYE\n    materialInput.tangentToEyeMatrix = czm_eastNorthUpToEyeCoordinates(worldCoordinate, normalEC);\n#endif\n\n#ifdef USES_ST\n    // Remap texture coordinates from computed (approximately aligned with cartographic space) to the desired\n    // texture coordinate system, which typically forms a tight oriented bounding box around the geometry.\n    // Shader is provided a set of reference points for remapping.\n    materialInput.st.x = czm_lineDistance(v_uvMinAndSphericalLongitudeRotation.xy, v_uMaxAndInverseDistance.xy, uv) * v_uMaxAndInverseDistance.z;\n    materialInput.st.y = czm_lineDistance(v_uvMinAndSphericalLongitudeRotation.xy, v_vMaxAndInverseDistance.xy, uv) * v_vMaxAndInverseDistance.z;\n#endif\n\n    czm_material material = czm_getMaterial(materialInput);\n\n#ifdef FLAT\n    out_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n#else // FLAT\n    out_FragColor = czm_phong(normalize(-eyeCoordinate.xyz), material, czm_lightDirectionEC);\n#endif // FLAT\n\n    // Premultiply alpha. Required for classification primitives on translucent globe.\n    out_FragColor.rgb *= out_FragColor.a;\n\n#endif // PER_INSTANCE_COLOR\n    czm_writeDepthClamp();\n#endif // PICK\n}\n"},753543:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i='in vec3 position3DHigh;\nin vec3 position3DLow;\nin float batchId;\n\n#ifdef EXTRUDED_GEOMETRY\nin vec3 extrudeDirection;\n\nuniform float u_globeMinimumAltitude;\n#endif // EXTRUDED_GEOMETRY\n\n#ifdef PER_INSTANCE_COLOR\nout vec4 v_color;\n#endif // PER_INSTANCE_COLOR\n\n#ifdef TEXTURE_COORDINATES\n#ifdef SPHERICAL\nout vec4 v_sphericalExtents;\n#else // SPHERICAL\nout vec2 v_inversePlaneExtents;\nout vec4 v_westPlane;\nout vec4 v_southPlane;\n#endif // SPHERICAL\nout vec3 v_uvMinAndSphericalLongitudeRotation;\nout vec3 v_uMaxAndInverseDistance;\nout vec3 v_vMaxAndInverseDistance;\n#endif // TEXTURE_COORDINATES\n\nvoid main()\n{\n    vec4 position = czm_computePosition();\n\n#ifdef EXTRUDED_GEOMETRY\n    float delta = min(u_globeMinimumAltitude, czm_geometricToleranceOverMeter * length(position.xyz));\n    delta *= czm_sceneMode == czm_sceneMode3D ? 1.0 : 0.0;\n\n    //extrudeDirection is zero for the top layer\n    position = position + vec4(extrudeDirection * delta, 0.0);\n#endif\n\n#ifdef TEXTURE_COORDINATES\n#ifdef SPHERICAL\n    v_sphericalExtents = czm_batchTable_sphericalExtents(batchId);\n    v_uvMinAndSphericalLongitudeRotation.z = czm_batchTable_longitudeRotation(batchId);\n#else // SPHERICAL\n#ifdef COLUMBUS_VIEW_2D\n    vec4 planes2D_high = czm_batchTable_planes2D_HIGH(batchId);\n    vec4 planes2D_low = czm_batchTable_planes2D_LOW(batchId);\n\n    // If the primitive is split across the IDL (planes2D_high.x > planes2D_high.w):\n    // - If this vertex is on the east side of the IDL (position3DLow.y > 0.0, comparison with position3DHigh may produce artifacts)\n    // - existing "east" is on the wrong side of the world, far away (planes2D_high/low.w)\n    // - so set "east" as beyond the eastmost extent of the projection (idlSplitNewPlaneHiLow)\n    vec2 idlSplitNewPlaneHiLow = vec2(EAST_MOST_X_HIGH - (WEST_MOST_X_HIGH - planes2D_high.w), EAST_MOST_X_LOW - (WEST_MOST_X_LOW - planes2D_low.w));\n    bool idlSplit = planes2D_high.x > planes2D_high.w && position3DLow.y > 0.0;\n    planes2D_high.w = czm_branchFreeTernary(idlSplit, idlSplitNewPlaneHiLow.x, planes2D_high.w);\n    planes2D_low.w = czm_branchFreeTernary(idlSplit, idlSplitNewPlaneHiLow.y, planes2D_low.w);\n\n    // - else, if this vertex is on the west side of the IDL (position3DLow.y < 0.0)\n    // - existing "west" is on the wrong side of the world, far away (planes2D_high/low.x)\n    // - so set "west" as beyond the westmost extent of the projection (idlSplitNewPlaneHiLow)\n    idlSplit = planes2D_high.x > planes2D_high.w && position3DLow.y < 0.0;\n    idlSplitNewPlaneHiLow = vec2(WEST_MOST_X_HIGH - (EAST_MOST_X_HIGH - planes2D_high.x), WEST_MOST_X_LOW - (EAST_MOST_X_LOW - planes2D_low.x));\n    planes2D_high.x = czm_branchFreeTernary(idlSplit, idlSplitNewPlaneHiLow.x, planes2D_high.x);\n    planes2D_low.x = czm_branchFreeTernary(idlSplit, idlSplitNewPlaneHiLow.y, planes2D_low.x);\n\n    vec3 southWestCorner = (czm_modelViewRelativeToEye * czm_translateRelativeToEye(vec3(0.0, planes2D_high.xy), vec3(0.0, planes2D_low.xy))).xyz;\n    vec3 northWestCorner = (czm_modelViewRelativeToEye * czm_translateRelativeToEye(vec3(0.0, planes2D_high.x, planes2D_high.z), vec3(0.0, planes2D_low.x, planes2D_low.z))).xyz;\n    vec3 southEastCorner = (czm_modelViewRelativeToEye * czm_translateRelativeToEye(vec3(0.0, planes2D_high.w, planes2D_high.y), vec3(0.0, planes2D_low.w, planes2D_low.y))).xyz;\n#else // COLUMBUS_VIEW_2D\n    // 3D case has smaller "plane extents," so planes encoded as a 64 bit position and 2 vec3s for distances/direction\n    vec3 southWestCorner = (czm_modelViewRelativeToEye * czm_translateRelativeToEye(czm_batchTable_southWest_HIGH(batchId), czm_batchTable_southWest_LOW(batchId))).xyz;\n    vec3 northWestCorner = czm_normal * czm_batchTable_northward(batchId) + southWestCorner;\n    vec3 southEastCorner = czm_normal * czm_batchTable_eastward(batchId) + southWestCorner;\n#endif // COLUMBUS_VIEW_2D\n\n    vec3 eastWard = southEastCorner - southWestCorner;\n    float eastExtent = length(eastWard);\n    eastWard /= eastExtent;\n\n    vec3 northWard = northWestCorner - southWestCorner;\n    float northExtent = length(northWard);\n    northWard /= northExtent;\n\n    v_westPlane = vec4(eastWard, -dot(eastWard, southWestCorner));\n    v_southPlane = vec4(northWard, -dot(northWard, southWestCorner));\n    v_inversePlaneExtents = vec2(1.0 / eastExtent, 1.0 / northExtent);\n#endif // SPHERICAL\n    vec4 uvMinAndExtents = czm_batchTable_uvMinAndExtents(batchId);\n    vec4 uMaxVmax = czm_batchTable_uMaxVmax(batchId);\n\n    v_uMaxAndInverseDistance = vec3(uMaxVmax.xy, uvMinAndExtents.z);\n    v_vMaxAndInverseDistance = vec3(uMaxVmax.zw, uvMinAndExtents.w);\n    v_uvMinAndSphericalLongitudeRotation.xy = uvMinAndExtents.xy;\n#endif // TEXTURE_COORDINATES\n\n#ifdef PER_INSTANCE_COLOR\n    v_color = czm_batchTable_color(batchId);\n#endif\n\n    gl_Position = czm_depthClamp(czm_modelViewProjectionRelativeToEye * position);\n}\n'},488961:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});const i="#ifdef VECTOR_TILE\nuniform vec4 u_highlightColor;\n#endif\n\nvoid main(void)\n{\n#ifdef VECTOR_TILE\n    out_FragColor = czm_gammaCorrect(u_highlightColor);\n#else\n    out_FragColor = vec4(1.0);\n#endif\n    czm_writeDepthClamp();\n}\n"}}]);